const e="https://cdn.jsdelivr.net/npm/trusted-issuer-registry@0.0",t=`${e}/test`;class BufferSourceConverter{static isArrayBuffer(e){return"[object ArrayBuffer]"===Object.prototype.toString.call(e)}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||0===e.byteOffset&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const r=BufferSourceConverter.toUint8Array(e),s=BufferSourceConverter.toUint8Array(t);if(r.length!==s.byteLength)return!1;for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}static concat(...e){let t;t=!Array.isArray(e[0])||e[1]instanceof Function?Array.isArray(e[0])&&e[1]instanceof Function?e[0]:e[e.length-1]instanceof Function?e.slice(0,e.length-1):e:e[0];let r=0;for(const e of t)r+=e.byteLength;const s=new Uint8Array(r);let a=0;for(const e of t){const t=this.toUint8Array(e);s.set(t,a),a+=t.length}return e[e.length-1]instanceof Function?this.toView(s,e[e.length-1]):s.buffer}}const r="string",s=/^[0-9a-f\s]+$/i,a=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,i=/^[a-zA-Z0-9-_]+$/;class Utf8Converter{static fromString(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r.buffer}static toString(e){const t=BufferSourceConverter.toUint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return decodeURIComponent(escape(r))}}class Utf16Converter{static toString(e,t=!1){const r=BufferSourceConverter.toArrayBuffer(e),s=new DataView(r);let a="";for(let e=0;e<r.byteLength;e+=2){const r=s.getUint16(e,t);a+=String.fromCharCode(r)}return a}static fromString(e,t=!1){const r=new ArrayBuffer(2*e.length),s=new DataView(r);for(let r=0;r<e.length;r++)s.setUint16(2*r,e.charCodeAt(r),t);return r}}class Convert{static isHex(e){return typeof e===r&&s.test(e)}static isBase64(e){return typeof e===r&&a.test(e)}static isBase64Url(e){return typeof e===r&&i.test(e)}static ToString(e,t="utf8"){const r=BufferSourceConverter.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);case"utf16le":return Utf16Converter.toString(r,!0);case"utf16":case"utf16be":return Utf16Converter.toString(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return Utf16Converter.fromString(e,!0);case"utf16":case"utf16be":return Utf16Converter.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=BufferSourceConverter.toUint8Array(e);if("undefined"!=typeof btoa){const e=this.ToString(t,"binary");return btoa(e)}return Buffer.from(t).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!Convert.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!Convert.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=Convert.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return Utf8Converter.fromString(e);case"utf16":case"utf16be":return Utf16Converter.fromString(e);case"utf16le":case"usc2":return Utf16Converter.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=Convert.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return Utf8Converter.toString(e);case"utf16":case"utf16be":return Utf16Converter.toString(e);case"utf16le":case"usc2":return Utf16Converter.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);return r.buffer}static ToBinary(e){const t=BufferSourceConverter.toUint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return r}static ToHex(e){const t=BufferSourceConverter.toUint8Array(e);let r="";const s=t.length;for(let e=0;e<s;e++){const s=t[e];s<16&&(r+="0"),r+=s.toString(16)}return r}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!Convert.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const r=new Uint8Array(t.length/2);for(let e=0;e<t.length;e+=2){const s=t.slice(e,e+2);r[e/2]=parseInt(s,16)}return r.buffer}static ToUtf16String(e,t=!1){return Utf16Converter.toString(e,t)}static FromUtf16String(e,t=!1){return Utf16Converter.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}static formatString(e){return(null==e?void 0:e.replace(/[\n\r\t ]/g,""))||""}}
/*!
 Copyright (c) Peculiar Ventures, LLC
*/
function getParametersValue(e,t,r){var s;return e instanceof Object==!1?r:null!==(s=e[t])&&void 0!==s?s:r}function bufferToHexCodes(e,t=0,r=e.byteLength-t,s=!1){let a="";for(const i of new Uint8Array(e,t,r)){const e=i.toString(16).toUpperCase();1===e.length&&(a+="0"),a+=e,s&&(a+=" ")}return a.trim()}function utilFromBase(e,t){let r=0;if(1===e.length)return e[0];for(let s=e.length-1;s>=0;s--)r+=e[e.length-1-s]*Math.pow(2,t*s);return r}function utilToBase(e,t,r=-1){const s=r;let a=e,i=0,n=Math.pow(2,t);for(let r=1;r<8;r++){if(e<n){let e;if(s<0)e=new ArrayBuffer(r),i=r;else{if(s<r)return new ArrayBuffer(0);e=new ArrayBuffer(s),i=s}const n=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);n[i-e-1]=Math.floor(a/r),a-=n[i-e-1]*r}return e}n*=Math.pow(2,t)}return new ArrayBuffer(0)}function utilConcatBuf(...e){let t=0,r=0;for(const r of e)t+=r.byteLength;const s=new ArrayBuffer(t),a=new Uint8Array(s);for(const t of e)a.set(new Uint8Array(t),r),r+=t.byteLength;return s}function utilConcatView(...e){let t=0,r=0;for(const r of e)t+=r.length;const s=new ArrayBuffer(t),a=new Uint8Array(s);for(const t of e)a.set(t,r),r+=t.length;return a}function utilDecodeTC(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&!(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const s=utilFromBase(r,8),a=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(a);for(let t=0;t<this.valueHex.byteLength;t++)i[t]=e[t];i[0]&=127;return utilFromBase(i,8)-s}function isEqualBuffer(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),s=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}function padNumber(e,t){const r=e.toString(10);if(t<r.length)return"";const s=t-r.length,a=new Array(s);for(let e=0;e<s;e++)a[e]="0";return a.join("").concat(r)}Convert.DEFAULT_UTF8_ENCODING="utf8";const n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function toBase64(e,t=!1,r=!1,s=!1){let a=0,i=0,l=0,c="";const u=t?o:n;if(s){let t=0;for(let r=0;r<e.length;r++)if(0!==e.charCodeAt(r)){t=r;break}e=e.slice(t)}for(;a<e.length;){const t=e.charCodeAt(a++);a>=e.length&&(i=1);const s=e.charCodeAt(a++);a>=e.length&&(l=1);const n=e.charCodeAt(a++),o=t>>2,h=(3&t)<<4|s>>4;let m=(15&s)<<2|n>>6,f=63&n;1===i?m=f=64:1===l&&(f=64),c+=r?64===m?`${u.charAt(o)}${u.charAt(h)}`:64===f?`${u.charAt(o)}${u.charAt(h)}${u.charAt(m)}`:`${u.charAt(o)}${u.charAt(h)}${u.charAt(m)}${u.charAt(f)}`:`${u.charAt(o)}${u.charAt(h)}${u.charAt(m)}${u.charAt(f)}`}return c}function fromBase64(e,t=!1,r=!1){const s=t?o:n;function indexOf(e){for(let t=0;t<64;t++)if(s.charAt(t)===e)return t;return 64}function test(e){return 64===e?0:e}let a=0,i="";for(;a<e.length;){const t=indexOf(e.charAt(a++)),r=a>=e.length?0:indexOf(e.charAt(a++)),s=a>=e.length?0:indexOf(e.charAt(a++)),n=a>=e.length?0:indexOf(e.charAt(a++)),o=test(t)<<2|test(r)>>4,l=(15&test(r))<<4|test(s)>>2,c=(3&test(s))<<6|test(n);i+=String.fromCharCode(o),64!==s&&(i+=String.fromCharCode(l)),64!==n&&(i+=String.fromCharCode(c))}if(r){let e=-1;for(let t=i.length-1;t>=0;t--)if(0!==i.charCodeAt(t)){e=t;break}i=-1!==e?i.slice(0,e+1):""}return i}function arrayBufferToString(e){let t="";const r=new Uint8Array(e);for(const e of r)t+=String.fromCharCode(e);return t}function stringToArrayBuffer(e){const t=e.length,r=new ArrayBuffer(t),s=new Uint8Array(r);for(let r=0;r<t;r++)s[r]=e.charCodeAt(r);return r}const l=Math.log(2);function nearestPowerOf2(e){const t=Math.log(e)/l,r=Math.floor(t),s=Math.round(t);return r===s?r:s}function clearProps(e,t){for(const r of t)delete e[r]}
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */function assertBigInt(){if("undefined"==typeof BigInt)throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function concat(e){let t=0,r=0;for(let r=0;r<e.length;r++){t+=e[r].byteLength}const s=new Uint8Array(t);for(let t=0;t<e.length;t++){const a=e[t];s.set(new Uint8Array(a),r),r+=a.byteLength}return s.buffer}function checkBufferParams(e,t,r,s){return t instanceof Uint8Array?t.byteLength?r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):s<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-s<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):(e.error="Wrong parameter: inputBuffer has zero length",!1):(e.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class ViewWriter{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return concat(this.items)}}const c=[new Uint8Array([1])],u="0123456789",h="name",m="valueHexView",f="",g=new ArrayBuffer(0),d=new Uint8Array(0),p="EndOfContent",S="OCTET STRING",y="BIT STRING";function HexBlock(e){var t;return(t=class extends e{get valueHex(){return this.valueHexView.slice().buffer}set valueHex(e){this.valueHexView=new Uint8Array(e)}constructor(...e){var t;super(...e);const r=e[0]||{};this.isHexOnly=null!==(t=r.isHexOnly)&&void 0!==t&&t,this.valueHexView=r.valueHex?BufferSourceConverter.toUint8Array(r.valueHex):d}fromBER(e,t,r){const s=e instanceof ArrayBuffer?new Uint8Array(e):e;if(!checkBufferParams(this,s,t,r))return-1;const a=t+r;return this.valueHexView=s.subarray(t,a),this.valueHexView.length?(this.blockLength=r,a):(this.warnings.push("Zero buffer length"),t)}toBER(e=!1){return this.isHexOnly?e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",g)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:Convert.ToHex(this.valueHexView)}}}).NAME="hexBlock",t}class LocalBaseBlock{static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}constructor({blockLength:e=0,error:t="",warnings:r=[],valueBeforeDecode:s=d}={}){this.blockLength=e,this.error=t,this.warnings=r,this.valueBeforeDecodeView=BufferSourceConverter.toUint8Array(s)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:Convert.ToHex(this.valueBeforeDecodeView)}}}LocalBaseBlock.NAME="baseBlock";class ValueBlock extends LocalBaseBlock{fromBER(e,t,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}ValueBlock.NAME="valueBlock";class LocalIdentificationBlock extends(HexBlock(LocalBaseBlock)){constructor({idBlock:e={}}={}){var t,r,s,a;super(),e?(this.isHexOnly=null!==(t=e.isHexOnly)&&void 0!==t&&t,this.valueHexView=e.valueHex?BufferSourceConverter.toUint8Array(e.valueHex):d,this.tagClass=null!==(r=e.tagClass)&&void 0!==r?r:-1,this.tagNumber=null!==(s=e.tagNumber)&&void 0!==s?s:-1,this.isConstructed=null!==(a=e.isConstructed)&&void 0!==a&&a):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",g}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const r=new Uint8Array(1);if(!e){let e=this.tagNumber;e&=31,t|=e,r[0]=t}return r.buffer}if(!this.isHexOnly){const r=utilToBase(this.tagNumber,7),s=new Uint8Array(r),a=r.byteLength,i=new Uint8Array(a+1);if(i[0]=31|t,!e){for(let e=0;e<a-1;e++)i[e+1]=128|s[e];i[a]=s[a-1]}return i.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=31|t,!e){const e=this.valueHexView;for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHexView.byteLength]=e[e.length-1]}return r.buffer}fromBER(e,t,r){const s=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,s,t,r))return-1;const a=s.subarray(t,t+r);if(0===a.length)return this.error="Zero buffer length",-1;switch(192&a[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=!(32&~a[0]),this.isHexOnly=!1;const i=31&a[0];if(31!==i)this.tagNumber=i,this.blockLength=1;else{let e=1,t=this.valueHexView=new Uint8Array(255),r=255;for(;128&a[e];){if(t[e-1]=127&a[e],e++,e>=a.length)return this.error="End of input reached before message was fully decoded",-1;if(e===r){r+=255;const e=new Uint8Array(r);for(let r=0;r<t.length;r++)e[r]=t[r];t=this.valueHexView=new Uint8Array(r)}}this.blockLength=e+1,t[e-1]=127&a[e];const s=new Uint8Array(e);for(let r=0;r<e;r++)s[r]=t[r];t=this.valueHexView=new Uint8Array(e),t.set(s),this.blockLength<=9?this.tagNumber=utilFromBase(t,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}LocalIdentificationBlock.NAME="identificationBlock";class LocalLengthBlock extends LocalBaseBlock{constructor({lenBlock:e={}}={}){var t,r,s;super(),this.isIndefiniteForm=null!==(t=e.isIndefiniteForm)&&void 0!==t&&t,this.longFormUsed=null!==(r=e.longFormUsed)&&void 0!==r&&r,this.length=null!==(s=e.length)&&void 0!==s?s:0}fromBER(e,t,r){const s=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,s,t,r))return-1;const a=s.subarray(t,t+r);if(0===a.length)return this.error="Zero buffer length",-1;if(255===a[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===a[0],this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&a[0]),!1===this.longFormUsed)return this.length=a[0],this.blockLength=1,t+this.blockLength;const i=127&a[0];if(i>8)return this.error="Too big integer",-1;if(i+1>a.length)return this.error="End of input reached before message was fully decoded",-1;const n=t+1,o=s.subarray(n,n+i);return 0===o[i-1]&&this.warnings.push("Needlessly long encoded length"),this.length=utilFromBase(o,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=128),t;if(this.longFormUsed){const s=utilToBase(this.length,8);if(s.byteLength>127)return this.error="Too big length",g;if(t=new ArrayBuffer(s.byteLength+1),e)return t;const a=new Uint8Array(s);r=new Uint8Array(t),r[0]=128|s.byteLength;for(let e=0;e<s.byteLength;e++)r[e+1]=a[e];return t}return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}LocalLengthBlock.NAME="lengthBlock";const w={};class BaseBlock extends LocalBaseBlock{constructor({name:e="",optional:t=!1,primitiveSchema:r,...s}={},a){super(s),this.name=e,this.optional=t,r&&(this.primitiveSchema=r),this.idBlock=new LocalIdentificationBlock(s),this.lenBlock=new LocalLengthBlock(s),this.valueBlock=a?new a(s):new ValueBlock(s)}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e,t){const r=t||new ViewWriter;t||prepareIndefiniteForm(this);const s=this.idBlock.toBER(e);if(r.write(s),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,r),r.write(new ArrayBuffer(2));else{const t=this.valueBlock.toBER(e);this.lenBlock.length=t.byteLength;const s=this.lenBlock.toBER(e);r.write(s),r.write(t)}return t?g:r.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return"ascii"===e?this.onAsciiEncoding():Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;return isEqualBuffer(this.toBER(),e.toBER())}}function prepareIndefiniteForm(e){var t;if(e instanceof w.Constructed)for(const t of e.valueBlock.value)prepareIndefiniteForm(t)&&(e.lenBlock.isIndefiniteForm=!0);return!!(null===(t=e.lenBlock)||void 0===t?void 0:t.isIndefiniteForm)}BaseBlock.NAME="BaseBlock";class BaseStringBlock extends BaseBlock{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor({value:e="",...t}={},r){super(t,r),e&&this.fromString(e)}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}BaseStringBlock.NAME="BaseStringBlock";class LocalPrimitiveValueBlock extends(HexBlock(ValueBlock)){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}var v,b,A,k,C,V,B,I,N,P,E,D,O,x,R,K,U,T,L,H,q,j,M,J,_,F,$,W,G;LocalPrimitiveValueBlock.NAME="PrimitiveValueBlock";class Primitive extends BaseBlock{constructor(e={}){super(e,LocalPrimitiveValueBlock),this.idBlock.isConstructed=!1}}function localFromBER(e,t=0,r=e.length){const s=t;let a=new BaseBlock({},ValueBlock);const i=new LocalBaseBlock;if(!checkBufferParams(i,e,t,r))return a.error=i.error,{offset:-1,result:a};if(!e.subarray(t,t+r).length)return a.error="Zero buffer length",{offset:-1,result:a};let n=a.idBlock.fromBER(e,t,r);if(a.idBlock.warnings.length&&a.warnings.concat(a.idBlock.warnings),-1===n)return a.error=a.idBlock.error,{offset:-1,result:a};if(t=n,r-=a.idBlock.blockLength,n=a.lenBlock.fromBER(e,t,r),a.lenBlock.warnings.length&&a.warnings.concat(a.lenBlock.warnings),-1===n)return a.error=a.lenBlock.error,{offset:-1,result:a};if(t=n,r-=a.lenBlock.blockLength,!a.idBlock.isConstructed&&a.lenBlock.isIndefiniteForm)return a.error="Indefinite length form used for primitive encoding form",{offset:-1,result:a};let o=BaseBlock;if(1===a.idBlock.tagClass){if(a.idBlock.tagNumber>=37&&!1===a.idBlock.isHexOnly)return a.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:a};switch(a.idBlock.tagNumber){case 0:if(a.idBlock.isConstructed&&a.lenBlock.length>0)return a.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:a};o=w.EndOfContent;break;case 1:o=w.Boolean;break;case 2:o=w.Integer;break;case 3:o=w.BitString;break;case 4:o=w.OctetString;break;case 5:o=w.Null;break;case 6:o=w.ObjectIdentifier;break;case 10:o=w.Enumerated;break;case 12:o=w.Utf8String;break;case 13:o=w.RelativeObjectIdentifier;break;case 14:o=w.TIME;break;case 15:return a.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:a};case 16:o=w.Sequence;break;case 17:o=w.Set;break;case 18:o=w.NumericString;break;case 19:o=w.PrintableString;break;case 20:o=w.TeletexString;break;case 21:o=w.VideotexString;break;case 22:o=w.IA5String;break;case 23:o=w.UTCTime;break;case 24:o=w.GeneralizedTime;break;case 25:o=w.GraphicString;break;case 26:o=w.VisibleString;break;case 27:o=w.GeneralString;break;case 28:o=w.UniversalString;break;case 29:o=w.CharacterString;break;case 30:o=w.BmpString;break;case 31:o=w.DATE;break;case 32:o=w.TimeOfDay;break;case 33:o=w.DateTime;break;case 34:o=w.Duration;break;default:{const e=a.idBlock.isConstructed?new w.Constructed:new w.Primitive;e.idBlock=a.idBlock,e.lenBlock=a.lenBlock,e.warnings=a.warnings,a=e}}}else o=a.idBlock.isConstructed?w.Constructed:w.Primitive;return a=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecodeView=e.valueBeforeDecodeView,r}(a,o),n=a.fromBER(e,t,a.lenBlock.isIndefiniteForm?r:a.lenBlock.length),a.valueBeforeDecodeView=e.subarray(s,s+a.blockLength),{offset:n,result:a}}function fromBER(e){if(!e.byteLength){const e=new BaseBlock({},ValueBlock);return e.error="Input buffer has zero length",{offset:-1,result:e}}return localFromBER(BufferSourceConverter.toUint8Array(e).slice(),0,e.byteLength)}function checkLen(e,t){return e?1:t}v=Primitive,w.Primitive=v,Primitive.NAME="PRIMITIVE";class LocalConstructedValueBlock extends ValueBlock{constructor({value:e=[],isIndefiniteForm:t=!1,...r}={}){super(r),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,r){const s=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,s,t,r))return-1;if(this.valueBeforeDecodeView=s.subarray(t,t+r),0===this.valueBeforeDecodeView.length)return this.warnings.push("Zero buffer length"),t;let a=t;for(;checkLen(this.isIndefiniteForm,r)>0;){const e=localFromBER(s,a,r);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(a=e.offset,this.blockLength+=e.result.blockLength,r-=e.result.blockLength,this.value.push(e.result),this.isIndefiniteForm&&e.result.constructor.NAME===p)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===p?this.value.pop():this.warnings.push("No EndOfContent block encoded")),a}toBER(e,t){const r=t||new ViewWriter;for(let t=0;t<this.value.length;t++)this.value[t].toBER(e,r);return t?g:r.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}LocalConstructedValueBlock.NAME="ConstructedValueBlock";class Constructed extends BaseBlock{constructor(e={}){super(e,LocalConstructedValueBlock),this.idBlock.isConstructed=!0}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){const e=[];for(const t of this.valueBlock.value)e.push(t.toString("ascii").split("\n").map(e=>`  ${e}`).join("\n"));const t=3===this.idBlock.tagClass?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :\n${e.join("\n")}`:`${t} :`}}b=Constructed,w.Constructed=b,Constructed.NAME="CONSTRUCTED";class LocalEndOfContentValueBlock extends ValueBlock{fromBER(e,t,r){return t}toBER(e){return g}}LocalEndOfContentValueBlock.override="EndOfContentValueBlock";class EndOfContent extends BaseBlock{constructor(e={}){super(e,LocalEndOfContentValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}A=EndOfContent,w.EndOfContent=A,EndOfContent.NAME=p;class Null extends BaseBlock{constructor(e={}){super(e,ValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e,t){const r=new ArrayBuffer(2);if(!e){const e=new Uint8Array(r);e[0]=5,e[1]=0}return t&&t.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}k=Null,w.Null=k,Null.NAME="NULL";class LocalBooleanValueBlock extends(HexBlock(ValueBlock)){get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=BufferSourceConverter.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}fromBER(e,t,r){const s=BufferSourceConverter.toUint8Array(e);return checkBufferParams(this,s,t,r)?(this.valueHexView=s.subarray(t,t+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,utilDecodeTC.call(this),this.blockLength=r,t+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}LocalBooleanValueBlock.NAME="BooleanValueBlock";class Boolean extends BaseBlock{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor(e={}){super(e,LocalBooleanValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}}C=Boolean,w.Boolean=C,Boolean.NAME="BOOLEAN";class LocalOctetStringValueBlock extends(HexBlock(LocalConstructedValueBlock)){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,r){let s=0;if(this.isConstructed){if(this.isHexOnly=!1,s=LocalConstructedValueBlock.prototype.fromBER.call(this,e,t,r),-1===s)return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.NAME;if(t===p){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==S)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e,t){return this.isConstructed?LocalConstructedValueBlock.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}LocalOctetStringValueBlock.NAME="OctetStringValueBlock";class OctetString extends BaseBlock{constructor({idBlock:e={},lenBlock:t={},...r}={}){var s,a;null!==(s=r.isConstructed)&&void 0!==s||(r.isConstructed=!!(null===(a=r.value)||void 0===a?void 0:a.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},LocalOctetStringValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r)return 0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const s=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+r);try{if(s.byteLength){const e=localFromBER(s,0,s.byteLength);-1!==e.offset&&e.offset===r&&(this.valueBlock.value=[e.result])}}catch{}}return super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return Constructed.prototype.onAsciiEncoding.call(this);return`${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const e=[];for(const t of this.valueBlock.value)t instanceof V&&e.push(t.valueBlock.valueHexView);return BufferSourceConverter.concat(e)}}V=OctetString,w.OctetString=V,OctetString.NAME=S;class LocalBitStringValueBlock extends(HexBlock(LocalConstructedValueBlock)){constructor({unusedBits:e=0,isConstructed:t=!1,...r}={}){super(r),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,r){if(!r)return t;let s=-1;if(this.isConstructed){if(s=LocalConstructedValueBlock.prototype.fromBER.call(this,e,t,r),-1===s)return s;for(const e of this.value){const t=e.constructor.NAME;if(t===p){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==y)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const r=e.valueBlock;if(this.unusedBits>0&&r.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=r.unusedBits}return s}const a=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,a,t,r))return-1;const i=a.subarray(t,t+r);if(this.unusedBits=i[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const e=i.subarray(1);try{if(e.byteLength){const t=localFromBER(e,0,e.byteLength);-1!==t.offset&&t.offset===r-1&&(this.value=[t.result])}}catch{}}return this.valueHexView=i.subarray(1),this.blockLength=i.length,t+r}toBER(e,t){if(this.isConstructed)return LocalConstructedValueBlock.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return g;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}LocalBitStringValueBlock.NAME="BitStringValueBlock";class BitString extends BaseBlock{constructor({idBlock:e={},lenBlock:t={},...r}={}){var s,a;null!==(s=r.isConstructed)&&void 0!==s||(r.isConstructed=!!(null===(a=r.value)||void 0===a?void 0:a.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},LocalBitStringValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return Constructed.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const r of t)e.push(r.toString(2).padStart(8,"0"));const r=e.join("");return`${this.constructor.NAME} : ${r.substring(0,r.length-this.valueBlock.unusedBits)}`}}}function viewAdd(e,t){const r=new Uint8Array([0]),s=new Uint8Array(e),a=new Uint8Array(t);let i=s.slice(0);const n=i.length-1,o=a.slice(0),l=o.length-1;let c=0;let u=0;for(let e=l<n?n:l;e>=0;e--,u++){if(!0==u<o.length)c=i[n-u]+o[l-u]+r[0];else c=i[n-u]+r[0];if(r[0]=c/10,!0==u>=i.length)i=utilConcatView(new Uint8Array([c%10]),i);else i[n-u]=c%10}return r[0]>0&&(i=utilConcatView(r,i)),i}function power2(e){if(e>=c.length)for(let t=c.length;t<=e;t++){const e=new Uint8Array([0]);let r=c[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const s=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=s[0]/10,r[t]=s[0]%10}e[0]>0&&(r=utilConcatView(e,r)),c.push(r)}return c[e]}function viewSub(e,t){let r=0;const s=new Uint8Array(e),a=new Uint8Array(t),i=s.slice(0),n=i.length-1,o=a.slice(0),l=o.length-1;let c,u=0;for(let e=l;e>=0;e--,u++)if(c=i[n-u]-o[l-u]-r,!0==c<0)r=1,i[n-u]=c+10;else r=0,i[n-u]=c;if(r>0)for(let e=n-l+1;e>=0;e--,u++){if(c=i[n-u]-r,!(c<0)){r=0,i[n-u]=c;break}r=1,i[n-u]=c+10}return i.slice()}B=BitString,w.BitString=B,BitString.NAME=y;class LocalIntegerValueBlock extends(HexBlock(ValueBlock)){setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=utilDecodeTC.call(this)))}constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),void 0!==e&&(this.valueDec=e)}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(function(e){const t=e<0?-1*e:e;let r=128;for(let s=1;s<8;s++){if(t<=r){if(e<0){const e=utilToBase(r-t,8,s);return new Uint8Array(e)[0]|=128,e}let a=utilToBase(t,8,s),i=new Uint8Array(a);if(128&i[0]){const e=a.slice(0),t=new Uint8Array(e);a=new ArrayBuffer(a.byteLength+1),i=new Uint8Array(a);for(let r=0;r<e.byteLength;r++)i[r+1]=t[r];i[0]=0}return a}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(e))}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const a=this.fromBER(e,t,r);if(-1===a)return a;const i=this.valueHexView;return 0===i[0]&&128&i[1]?this.valueHexView=i.subarray(1):0!==s&&i.length<s&&(s-i.length>1&&(s=i.length+1),this.valueHexView=i.subarray(s-i.length)),a}toDER(e=!1){const t=this.valueHexView;switch(!0){case!!(128&t[0]):{const e=new Uint8Array(this.valueHexView.length+1);e[0]=0,e.set(t,1),this.valueHexView=e}break;case 0===t[0]&&!(128&t[1]):this.valueHexView=this.valueHexView.subarray(1)}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return-1===s||this.setValueHex(),s}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=8*this.valueHexView.length-1;let t,r=new Uint8Array(8*this.valueHexView.length/3),s=0;const a=this.valueHexView;let i="",n=!1;for(let n=a.byteLength-1;n>=0;n--){t=a[n];for(let a=0;a<8;a++){if(!(1&~t))if(s===e)r=viewSub(power2(s),r),i="-";else r=viewAdd(r,power2(s));s++,t>>=1}}for(let e=0;e<r.length;e++)r[e]&&(n=!0),n&&(i+=u.charAt(r[e]));return!1===n&&(i+=u.charAt(0)),i}}I=LocalIntegerValueBlock,LocalIntegerValueBlock.NAME="IntegerValueBlock",Object.defineProperty(I.prototype,"valueHex",{set:function(e){this.valueHexView=new Uint8Array(e),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});class Integer extends BaseBlock{constructor(e={}){super(e,LocalIntegerValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return assertBigInt(),BigInt(this.valueBlock.toString())}static fromBigInt(e){assertBigInt();const t=BigInt(e),r=new ViewWriter,s=t.toString(16).replace(/^-/,""),a=new Uint8Array(Convert.FromHex(s));if(t<0){const e=new Uint8Array(a.length+(128&a[0]?1:0));e[0]|=128;const s=BigInt(`0x${Convert.ToHex(e)}`)+t,i=BufferSourceConverter.toUint8Array(Convert.FromHex(s.toString(16)));i[0]|=128,r.write(i)}else 128&a[0]&&r.write(new Uint8Array([0])),r.write(a);return new N({valueHex:r.final()})}convertToDER(){const e=new N({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new N({valueHex:0===this.valueBlock.valueHexView[0]?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}N=Integer,w.Integer=N,Integer.NAME="INTEGER";class Enumerated extends Integer{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}P=Enumerated,w.Enumerated=P,Enumerated.NAME="ENUMERATED";class LocalSidValueBlock extends(HexBlock(ValueBlock)){constructor({valueDec:e=-1,isFirstSid:t=!1,...r}={}){super(r),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,r){if(!r)return t;const s=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,s,t,r))return-1;const a=s.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let e=0;e<r&&(this.valueHexView[e]=127&a[e],this.blockLength++,128&a[e]);e++);const i=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)i[e]=this.valueHexView[e];return this.valueHexView=i,128&a[this.blockLength-1]?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=utilFromBase(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){assertBigInt();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const r=new Uint8Array(t.length/7);for(let e=0;e<r.length;e++)r[e]=parseInt(t.slice(7*e,7*e+7),2)+(e+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,r=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)r[e]=128|t[e];return r[this.blockLength-1]=t[this.blockLength-1],r.buffer}const t=utilToBase(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",g;const r=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),s=t.byteLength-1;for(let t=0;t<s;t++)r[t]=128|e[t];r[s]=e[s]}return r}toString(){let e="";if(this.isHexOnly)e=Convert.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}LocalSidValueBlock.NAME="sidBlock";class LocalObjectIdentifierValueBlock extends ValueBlock{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let s=t;for(;r>0;){const t=new LocalSidValueBlock;if(s=t.fromBER(e,s,r),-1===s)return this.blockLength=0,this.error=t.error,s;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e){const t=[];for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(0===s.byteLength)return this.error=this.value[r].error,g;t.push(s)}return concat(t)}fromString(e){this.value=[];let t=0,r=0,s="",a=!1;do{if(r=e.indexOf(".",t),s=-1===r?e.substring(t):e.substring(t,r),t=r+1,a){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return void(this.value=[])}const r=parseInt(s,10);if(isNaN(r))return;e.valueDec=r+t,a=!1}else{const e=new LocalSidValueBlock;if(s>Number.MAX_SAFE_INTEGER){assertBigInt();const t=BigInt(s);e.valueBigInt=t}else if(e.valueDec=parseInt(s,10),isNaN(e.valueDec))return;this.value.length||(e.isFirstSid=!0,a=!0),this.value.push(e)}}while(-1!==r)}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e=`${e}.`),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}LocalObjectIdentifierValueBlock.NAME="ObjectIdentifierValueBlock";class ObjectIdentifier extends BaseBlock{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,LocalObjectIdentifierValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}E=ObjectIdentifier,w.ObjectIdentifier=E,ObjectIdentifier.NAME="OBJECT IDENTIFIER";class LocalRelativeSidValueBlock extends(HexBlock(LocalBaseBlock)){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,r){if(0===r)return t;const s=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,s,t,r))return-1;const a=s.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let e=0;e<r&&(this.valueHexView[e]=127&a[e],this.blockLength++,128&a[e]);e++);const i=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)i[e]=this.valueHexView[e];return this.valueHexView=i,128&a[this.blockLength-1]?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=utilFromBase(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,r=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)r[e]=128|t[e];return r[this.blockLength-1]=t[this.blockLength-1],r.buffer}const t=utilToBase(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",g;const r=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),s=t.byteLength-1;for(let t=0;t<s;t++)r[t]=128|e[t];r[s]=e[s]}return r.buffer}toString(){let e="";return e=this.isHexOnly?Convert.ToHex(this.valueHexView):this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}LocalRelativeSidValueBlock.NAME="relativeSidBlock";class LocalRelativeObjectIdentifierValueBlock extends ValueBlock{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let s=t;for(;r>0;){const t=new LocalRelativeSidValueBlock;if(s=t.fromBER(e,s,r),-1===s)return this.blockLength=0,this.error=t.error,s;this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e,t){const r=[];for(let t=0;t<this.value.length;t++){const s=this.value[t].toBER(e);if(0===s.byteLength)return this.error=this.value[t].error,g;r.push(s)}return concat(r)}fromString(e){this.value=[];let t=0,r=0,s="";do{r=e.indexOf(".",t),s=-1===r?e.substring(t):e.substring(t,r),t=r+1;const a=new LocalRelativeSidValueBlock;if(a.valueDec=parseInt(s,10),isNaN(a.valueDec))return!0;this.value.push(a)}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e=`${e}.`),t?(s=`{${s}}`,e+=s):e+=s}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}LocalRelativeObjectIdentifierValueBlock.NAME="RelativeObjectIdentifierValueBlock";class RelativeObjectIdentifier extends BaseBlock{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,LocalRelativeObjectIdentifierValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}D=RelativeObjectIdentifier,w.RelativeObjectIdentifier=D,RelativeObjectIdentifier.NAME="RelativeObjectIdentifier";class Sequence extends Constructed{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}O=Sequence,w.Sequence=O,Sequence.NAME="SEQUENCE";class Set extends Constructed{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}}x=Set,w.Set=x,Set.NAME="SET";class LocalStringValueBlock extends(HexBlock(ValueBlock)){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=f}toJSON(){return{...super.toJSON(),value:this.value}}}LocalStringValueBlock.NAME="StringValueBlock";class LocalSimpleStringValueBlock extends LocalStringValueBlock{}LocalSimpleStringValueBlock.NAME="SimpleStringValueBlock";class LocalSimpleStringBlock extends BaseStringBlock{constructor({...e}={}){super(e,LocalSimpleStringValueBlock)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,BufferSourceConverter.toUint8Array(e))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}LocalSimpleStringBlock.NAME="SIMPLE STRING";class LocalUtf8StringValueBlock extends LocalSimpleStringBlock{fromBuffer(e){this.valueBlock.valueHexView=BufferSourceConverter.toUint8Array(e);try{this.valueBlock.value=Convert.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=Convert.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(Convert.FromUtf8String(e)),this.valueBlock.value=e}}LocalUtf8StringValueBlock.NAME="Utf8StringValueBlock";class Utf8String extends LocalUtf8StringValueBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}R=Utf8String,w.Utf8String=R,Utf8String.NAME="UTF8String";class LocalBmpStringValueBlock extends LocalSimpleStringBlock{fromBuffer(e){this.valueBlock.value=Convert.ToUtf16String(e),this.valueBlock.valueHexView=BufferSourceConverter.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(Convert.FromUtf16String(e))}}LocalBmpStringValueBlock.NAME="BmpStringValueBlock";class BmpString extends LocalBmpStringValueBlock{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}K=BmpString,w.BmpString=K,BmpString.NAME="BMPString";class LocalUniversalStringValueBlock extends LocalSimpleStringBlock{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(4*t);for(let s=0;s<t;s++){const t=utilToBase(e.charCodeAt(s),8),a=new Uint8Array(t);if(a.length>4)continue;const i=4-a.length;for(let e=a.length-1;e>=0;e--)r[4*s+e+i]=a[e]}this.valueBlock.value=e}}LocalUniversalStringValueBlock.NAME="UniversalStringValueBlock";class UniversalString extends LocalUniversalStringValueBlock{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}U=UniversalString,w.UniversalString=U,UniversalString.NAME="UniversalString";class NumericString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}T=NumericString,w.NumericString=T,NumericString.NAME="NumericString";class PrintableString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}L=PrintableString,w.PrintableString=L,PrintableString.NAME="PrintableString";class TeletexString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}H=TeletexString,w.TeletexString=H,TeletexString.NAME="TeletexString";class VideotexString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}q=VideotexString,w.VideotexString=q,VideotexString.NAME="VideotexString";class IA5String extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}j=IA5String,w.IA5String=j,IA5String.NAME="IA5String";class GraphicString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}M=GraphicString,w.GraphicString=M,GraphicString.NAME="GraphicString";class VisibleString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}J=VisibleString,w.VisibleString=J,VisibleString.NAME="VisibleString";class GeneralString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}_=GeneralString,w.GeneralString=_,GeneralString.NAME="GeneralString";class CharacterString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}F=CharacterString,w.CharacterString=F,CharacterString.NAME="CharacterString";class UTCTime extends VisibleString{constructor({value:e,valueDate:t,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let t=0;t<e.length;t++)this.valueBlock.valueHexView[t]=e.charCodeAt(t)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,BufferSourceConverter.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for conversion");const r=parseInt(t[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(e="iso"){if("iso"===e){const e=new Array(7);return e[0]=padNumber(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=padNumber(this.month,2),e[2]=padNumber(this.day,2),e[3]=padNumber(this.hour,2),e[4]=padNumber(this.minute,2),e[5]=padNumber(this.second,2),e[6]="Z",e.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}$=UTCTime,w.UTCTime=$,UTCTime.NAME="UTCTime";class GeneralizedTime extends UTCTime{constructor(e={}){var t;super(e),null!==(t=this.millisecond)&&void 0!==t||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){const e=Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond);return new Date(e)}fromString(e){let t,r=!1,s="",a="",i=0,n=0,o=0;if("Z"===e[e.length-1])s=e.substring(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for conversion");s=e}if(r){if(-1!==s.indexOf("+"))throw new Error("Wrong input string for conversion");if(-1!==s.indexOf("-"))throw new Error("Wrong input string for conversion")}else{let e=1,t=s.indexOf("+"),r="";if(-1===t&&(t=s.indexOf("-"),e=-1),-1!==t){if(r=s.substring(t+1),s=s.substring(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for conversion");let a=parseInt(r.substring(0,2),10);if(isNaN(a.valueOf()))throw new Error("Wrong input string for conversion");if(n=e*a,4===r.length){if(a=parseInt(r.substring(2,4),10),isNaN(a.valueOf()))throw new Error("Wrong input string for conversion");o=e*a}}}let l=s.indexOf(".");if(-1===l&&(l=s.indexOf(",")),-1!==l){const e=new Number(`0${s.substring(l)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for conversion");i=e.valueOf(),a=s.substring(0,l)}else a=s;switch(!0){case 8===a.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==l)throw new Error("Wrong input string for conversion");break;case 10===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*i;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*i;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){const e=1e3*i;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for conversion")}const c=t.exec(a);if(null===c)throw new Error("Wrong input string for conversion");for(let e=1;e<c.length;e++)switch(e){case 1:this.year=parseInt(c[e],10);break;case 2:this.month=parseInt(c[e],10);break;case 3:this.day=parseInt(c[e],10);break;case 4:this.hour=parseInt(c[e],10)+n;break;case 5:this.minute=parseInt(c[e],10)+o;break;case 6:this.second=parseInt(c[e],10);break;default:throw new Error("Wrong input string for conversion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(e="iso"){if("iso"===e){const e=[];return e.push(padNumber(this.year,4)),e.push(padNumber(this.month,2)),e.push(padNumber(this.day,2)),e.push(padNumber(this.hour,2)),e.push(padNumber(this.minute,2)),e.push(padNumber(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(padNumber(this.millisecond,3))),e.push("Z"),e.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}W=GeneralizedTime,w.GeneralizedTime=W,GeneralizedTime.NAME="GeneralizedTime";let z=class extends Utf8String{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}};var Q,Z,Y,X;G=z,w.DATE=G,z.NAME="DATE";class TimeOfDay extends Utf8String{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}Q=TimeOfDay,w.TimeOfDay=Q,TimeOfDay.NAME="TimeOfDay";class DateTime extends Utf8String{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}Z=DateTime,w.DateTime=Z,DateTime.NAME="DateTime";class Duration extends Utf8String{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}Y=Duration,w.Duration=Y,Duration.NAME="Duration";class TIME extends Utf8String{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}X=TIME,w.TIME=X,TIME.NAME="TIME";class Any{constructor({name:e="",optional:t=!1}={}){this.name=e,this.optional=t}}class Choice extends Any{constructor({value:e=[],...t}={}){super(t),this.value=e}}class Repeated extends Any{constructor({value:e=new Any,local:t=!1,...r}={}){super(r),this.value=e,this.local=t}}class RawData{get data(){return this.dataView.slice().buffer}set data(e){this.dataView=BufferSourceConverter.toUint8Array(e)}constructor({data:e=d}={}){this.dataView=BufferSourceConverter.toUint8Array(e)}fromBER(e,t,r){const s=t+r;return this.dataView=BufferSourceConverter.toUint8Array(e).subarray(t,s),s}toBER(e){return this.dataView.slice().buffer}}function compareSchema(e,t,r){if(r instanceof Choice){for(const s of r.value){if(compareSchema(e,t,s).verified)return{verified:!0,result:e}}{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty(h)&&(e.name=r.name),e}}if(r instanceof Any)return r.hasOwnProperty(h)&&(e[r.name]=t),{verified:!0,result:e};if(e instanceof Object==!1)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=r.idBlock.toBER(!1);if(0===s.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(s,0,s.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if(!("isHexOnly"in r.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(r.idBlock.isHexOnly){if(m in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=r.idBlock.valueHexView,a=t.idBlock.valueHexView;if(s.length!==a.length)return{verified:!1,result:e};for(let t=0;t<s.length;t++)if(s[t]!==a[1])return{verified:!1,result:e}}if(r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,f),r.name&&(e[r.name]=t)),r instanceof w.Constructed){let s=0,a={verified:!1,result:{error:"Unknown error"}},i=r.valueBlock.value.length;if(i>0&&r.valueBlock.value[0]instanceof Repeated&&(i=t.valueBlock.value.length),0===i)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==r.valueBlock.value.length){let t=!0;for(let e=0;e<r.valueBlock.value.length;e++)t=t&&(r.valueBlock.value[e].optional||!1);return t?{verified:!0,result:e}:(r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,f),r.name&&delete e[r.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let n=0;n<i;n++)if(n-s>=t.valueBlock.value.length){if(!1===r.valueBlock.value[n].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,f),r.name&&(delete e[r.name],t.name=r.name)),t}}else if(r.valueBlock.value[0]instanceof Repeated){if(a=compareSchema(e,t.valueBlock.value[n],r.valueBlock.value[0].value),!1===a.verified){if(!r.valueBlock.value[0].optional)return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,f),r.name&&delete e[r.name]),a;s++}if(h in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let s={};s="local"in r.valueBlock.value[0]&&r.valueBlock.value[0].local?t:e,void 0===s[r.valueBlock.value[0].name]&&(s[r.valueBlock.value[0].name]=[]),s[r.valueBlock.value[0].name].push(t.valueBlock.value[n])}}else if(a=compareSchema(e,t.valueBlock.value[n-s],r.valueBlock.value[n]),!1===a.verified){if(!r.valueBlock.value[n].optional)return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,f),r.name&&delete e[r.name]),a;s++}if(!1===a.verified){const t={verified:!1,result:e};return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,f),r.name&&(delete e[r.name],t.name=r.name)),t}return{verified:!0,result:e}}if(r.primitiveSchema&&m in t.valueBlock){const s=localFromBER(t.valueBlock.valueHexView);if(-1===s.offset){const t={verified:!1,result:s.result};return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,f),r.name&&(delete e[r.name],t.name=r.name)),t}return compareSchema(e,s.result,r.primitiveSchema)}return{verified:!0,result:e}}class ByteStream{constructor(e={}){if("view"in e)this.fromUint8Array(e.view);else if("buffer"in e)this.fromArrayBuffer(e.buffer);else if("string"in e)this.fromString(e.string);else if("hexstring"in e)this.fromHexString(e.hexstring);else if("length"in e&&e.length>0){if(this.length=e.length,e.stub)for(let t=0;t<this._view.length;t++)this._view[t]=e.stub}else this.length=0}set buffer(e){this._buffer=e,this._view=new Uint8Array(this._buffer)}get buffer(){return this._buffer}set view(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}get view(){return this._view}get length(){return this.view.byteLength}set length(e){this._buffer=new ArrayBuffer(e),this._view=new Uint8Array(this._buffer)}clear(){this._buffer=new ArrayBuffer(0),this._view=new Uint8Array(this._buffer)}fromArrayBuffer(e){this._buffer=e,this._view=new Uint8Array(this._buffer)}fromUint8Array(e){this.fromArrayBuffer(new Uint8Array(e).buffer)}fromString(e){const t=e.length;this.length=t;for(let r=0;r<t;r++)this.view[r]=e.charCodeAt(r)}toString(e=0,t=this.view.length-e){let r="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let s=e;s<e+t;s++)r+=String.fromCharCode(this.view[s]);return r}fromHexString(e){const t=e.length;this.buffer=new ArrayBuffer(t>>1),this.view=new Uint8Array(this.buffer);const r=new Map;r.set("0",0),r.set("1",1),r.set("2",2),r.set("3",3),r.set("4",4),r.set("5",5),r.set("6",6),r.set("7",7),r.set("8",8),r.set("9",9),r.set("A",10),r.set("a",10),r.set("B",11),r.set("b",11),r.set("C",12),r.set("c",12),r.set("D",13),r.set("d",13),r.set("E",14),r.set("e",14),r.set("F",15),r.set("f",15);let s=0,a=0;for(let i=0;i<t;i++)i%2?(a|=r.get(e.charAt(i)),this.view[s]=a,s++):a=r.get(e.charAt(i))<<4}toHexString(e=0,t=this.view.length-e){let r="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let s=e;s<e+t;s++){const e=this.view[s].toString(16).toUpperCase();r=r+(1==e.length?"0":"")+e}return r}copy(e=0,t=this.length-e){if(!e&&!this.length)return new ByteStream;if(e<0||e>this.length-1)throw new Error(`Wrong start position: ${e}`);return new ByteStream({buffer:this._buffer.slice(e,e+t)})}slice(e=0,t=this.length){if(!e&&!this.length)return new ByteStream;if(e<0||e>this.length-1)throw new Error(`Wrong start position: ${e}`);return new ByteStream({buffer:this._buffer.slice(e,t)})}realloc(e){const t=new ArrayBuffer(e),r=new Uint8Array(t);e>this._view.length?r.set(this._view):r.set(new Uint8Array(this._buffer,0,e)),this._buffer=t,this._view=new Uint8Array(this._buffer)}append(e){const t=this.length,r=e.length,s=e._view.subarray();this.realloc(t+r),this._view.set(s,t)}insert(e,t=0,r=this.length-t){return!(t>this.length-1)&&(r>this.length-t&&(r=this.length-t),r>e.length&&(r=e.length),r==e.length?this._view.set(e._view,t):this._view.set(e._view.subarray(0,r),t),!0)}isEqual(e){if(this.length!=e.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e.view[t])return!1;return!0}isEqualView(e){if(e.length!=this.view.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e[t])return!1;return!0}findPattern(e,t,r,s){const{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s),o=e.length;if(o>i)return-1;const l=[];for(let t=0;t<o;t++)l.push(e.view[t]);for(let e=0;e<=i-o;e++){let t=!0;const r=n?a-o-e:a+e;for(let e=0;e<o;e++)if(this.view[e+r]!=l[e]){t=!1;break}if(t)return n?a-o-e:a+o+e}return-1}findFirstIn(e,t,r,s){const{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s),o={id:-1,position:n?0:a+i,length:0};for(let t=0;t<e.length;t++){const r=this.findPattern(e[t],a,i,n);if(-1!=r){let s=!1;const a=e[t].length;n?r-a>=o.position-o.length&&(s=!0):r-a<=o.position-o.length&&(s=!0),s&&(o.position=r,o.id=t,o.length=a)}}return o}findAllIn(e,t,r){let{start:s,length:a}=this.prepareFindParameters(t,r);const i=[];let n={id:-1,position:s};for(;;){const t=n.position;if(n=this.findFirstIn(e,n.position,a),-1==n.id)break;a-=n.position-t,i.push({id:n.id,position:n.position})}return i}findAllPatternIn(e,t,r){const{start:s,length:a}=this.prepareFindParameters(t,r),i=[],n=e.length;if(n>a)return-1;const o=Array.from(e.view);for(let e=0;e<=a-n;e++){let t=!0;const r=s+e;for(let e=0;e<n;e++)if(this.view[e+r]!=o[e]){t=!1;break}t&&(i.push(s+n+e),e+=n-1)}return i}findFirstNotIn(e,t,r,s){let{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s);const o={left:{id:-1,position:a},right:{id:-1,position:0},value:new ByteStream};let l=i;for(;l>0;){if(o.right=this.findFirstIn(e,n?a-i+l:a+i-l,l,n),-1==o.right.id){i=l,n?a-=i:a=o.left.position,o.value=new ByteStream({buffer:this._buffer.slice(a,a+i)});break}if(o.right.position!=(n?o.left.position-e[o.right.id].length:o.left.position+e[o.right.id].length)){n?(a=o.right.position+e[o.right.id].length,i=o.left.position-o.right.position-e[o.right.id].length):(a=o.left.position,i=o.right.position-o.left.position-e[o.right.id].length),o.value=new ByteStream({buffer:this._buffer.slice(a,a+i)});break}o.left=o.right,l-=e[o.right.id].length}if(n){const e=o.right;o.right=o.left,o.left=e}return o}findAllNotIn(e,t,r){let{start:s,length:a}=this.prepareFindParameters(t,r);const i=[];let n={left:{id:-1,position:s},right:{id:-1,position:s},value:new ByteStream};do{const t=n.right.position;n=this.findFirstNotIn(e,n.right.position,a),a-=n.right.position-t,i.push({left:{id:n.left.id,position:n.left.position},right:{id:n.right.id,position:n.right.position},value:n.value})}while(-1!=n.right.id);return i}findFirstSequence(e,t,r,s){let{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s);const o=this.skipNotPatterns(e,a,i,n);if(-1==o)return{position:-1,value:new ByteStream};const l=this.skipPatterns(e,o,i-(n?a-o:o-a),n);n?(a=l,i=o-l):(a=o,i=l-o);return{position:l,value:new ByteStream({buffer:this._buffer.slice(a,a+i)})}}findAllSequences(e,t,r){let{start:s,length:a}=this.prepareFindParameters(t,r);const i=[];let n={position:s,value:new ByteStream};do{const t=n.position;n=this.findFirstSequence(e,n.position,a),-1!=n.position&&(a-=n.position-t,i.push({position:n.position,value:n.value}))}while(-1!=n.position);return i}findPairedPatterns(e,t,r,s){const a=[];if(e.isEqual(t))return a;const{start:i,length:n}=this.prepareFindParameters(r,s);let o=0;const l=this.findAllPatternIn(e,i,n);if(!Array.isArray(l)||0==l.length)return a;const c=this.findAllPatternIn(t,i,n);if(!Array.isArray(c)||0==c.length)return a;for(;o<l.length&&0!=c.length;)if(l[0]!=c[0]){if(l[o]>c[0])break;for(;l[o]<c[0]&&(o++,!(o>=l.length)););a.push({left:l[o-1],right:c[0]}),l.splice(o-1,1),c.splice(0,1),o=0}else a.push({left:l[0],right:c[0]}),l.splice(0,1),c.splice(0,1);return a.sort((e,t)=>e.left-t.left),a}findPairedArrays(e,t,r,s){const{start:a,length:i}=this.prepareFindParameters(r,s),n=[];let o=0;const l=this.findAllIn(e,a,i);if(0==l.length)return n;const c=this.findAllIn(t,a,i);if(0==c.length)return n;for(;o<l.length&&0!=c.length;)if(l[0].position!=c[0].position){if(l[o].position>c[0].position)break;for(;l[o].position<c[0].position&&(o++,!(o>=l.length)););n.push({left:l[o-1],right:c[0]}),l.splice(o-1,1),c.splice(0,1),o=0}else n.push({left:l[0],right:c[0]}),l.splice(0,1),c.splice(0,1);return n.sort((e,t)=>e.left.position-t.left.position),n}replacePattern(e,t,r,s,a=null){let i,n=[];const o={status:-1,searchPatternPositions:[],replacePatternPositions:[]},{start:l,length:c}=this.prepareFindParameters(r,s);if(null==a){if(n=this.findAllIn([e],l,c),0==n.length)return o}else n=a;o.searchPatternPositions.push(...Array.from(n,e=>e.position));const u=e.length-t.length,h=new ArrayBuffer(this.view.length-n.length*u),m=new Uint8Array(h);for(m.set(new Uint8Array(this.buffer,0,l)),i=0;i<n.length;i++){const r=0==i?l:n[i-1].position;m.set(new Uint8Array(this.buffer,r,n[i].position-e.length-r),r-i*u),m.set(t.view,n[i].position-e.length-i*u),o.replacePatternPositions.push(n[i].position-e.length-i*u)}return i--,m.set(new Uint8Array(this.buffer,n[i].position,this.length-n[i].position),n[i].position-e.length+t.length-i*u),this.buffer=h,this.view=new Uint8Array(this.buffer),o.status=1,o}skipPatterns(e,t,r,s){const{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s);let o=a;for(let t=0;t<e.length;t++){const r=e[t].length,s=n?o-r:o;let l=!0;for(let a=0;a<r;a++)if(this.view[a+s]!=e[t].view[a]){l=!1;break}if(l)if(t=-1,n){if(o-=r,o<=0)return o}else if(o+=r,o>=a+i)return o}return o}skipNotPatterns(e,t,r,s){const{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s);let o=-1;for(let t=0;t<i;t++){for(let r=0;r<e.length;r++){const s=e[r].length,i=n?a-t-s:a+t;let l=!0;for(let t=0;t<s;t++)if(this.view[t+i]!=e[r].view[t]){l=!1;break}if(l){o=n?a-t:a+t;break}}if(-1!=o)break}return o}prepareFindParameters(e=null,t=null,r=!1){return null===e&&(e=r?this.length:0),e>this.length&&(e=this.length),r?(null===t&&(t=e),t>e&&(t=e)):(null===t&&(t=this.length-e),t>this.length-e&&(t=this.length-e)),{start:e,length:t,backward:r}}}class SeqStream{constructor(e={}){this._stream=new ByteStream,this._length=0,this._start=0,this.backward=!1,this.appendBlock=0,this.prevLength=0,this.prevStart=0,this.stream="view"in e?new ByteStream({view:e.view}):"buffer"in e?new ByteStream({buffer:e.buffer}):"string"in e?new ByteStream({string:e.string}):"hexstring"in e?new ByteStream({hexstring:e.hexstring}):"stream"in e?e.stream.slice():new ByteStream,"backward"in e&&e.backward&&(this.backward=e.backward,this._start=this.stream.length),"length"in e&&e.length>0&&(this._length=e.length),"start"in e&&e.start&&e.start>0&&(this._start=e.start),"appendBlock"in e&&e.appendBlock&&e.appendBlock>0&&(this.appendBlock=e.appendBlock)}set stream(e){this._stream=e,this.prevLength=this._length,this._length=e.length,this.prevStart=this._start,this._start=0}get stream(){return this._stream}set length(e){this.prevLength=this._length,this._length=e}get length(){return this.appendBlock?this.start:this._length}set start(e){e>this.stream.length||(this.prevStart=this._start,this.prevLength=this._length,this._length-=this.backward?this._start-e:e-this._start,this._start=e)}get start(){return this._start}get buffer(){return this._stream.buffer.slice(0,this._length)}resetPosition(){this._start=this.prevStart,this._length=this.prevLength}findPattern(e,t=null){(null==t||t>this.length)&&(t=this.length);const r=this.stream.findPattern(e,this.start,this.length,this.backward);if(-1==r)return r;if(this.backward){if(r<this.start-e.length-t)return-1}else if(r>this.start+e.length+t)return-1;return this.start=r,r}findFirstIn(e,t=null){(null==t||t>this.length)&&(t=this.length);const r=this.stream.findFirstIn(e,this.start,this.length,this.backward);if(-1==r.id)return r;if(this.backward){if(r.position<this.start-e[r.id].length-t)return{id:-1,position:this.backward?0:this.start+this.length}}else if(r.position>this.start+e[r.id].length+t)return{id:-1,position:this.backward?0:this.start+this.length};return this.start=r.position,r}findAllIn(e){const t=this.backward?this.start-this.length:this.start;return this.stream.findAllIn(e,t,this.length)}findFirstNotIn(e,t=null){(null==t||t>this._length)&&(t=this._length);const r=this._stream.findFirstNotIn(e,this._start,this._length,this.backward);if(-1==r.left.id&&-1==r.right.id)return r;if(this.backward){if(-1!=r.right.id&&r.right.position<this._start-e[r.right.id].length-t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new ByteStream}}else if(-1!=r.left.id&&r.left.position>this._start+e[r.left.id].length+t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new ByteStream};return this.backward?-1==r.left.id?this.start=0:this.start=r.left.position:-1==r.right.id?this.start=this._start+this._length:this.start=r.right.position,r}findAllNotIn(e){const t=this.backward?this._start-this._length:this._start;return this._stream.findAllNotIn(e,t,this._length)}findFirstSequence(e,t=null,r=null){(null==t||t>this._length)&&(t=this._length),(null==r||r>t)&&(r=t);const s=this._stream.findFirstSequence(e,this._start,t,this.backward);if(0==s.value.length)return s;if(this.backward){if(s.position<this._start-s.value.length-r)return{position:-1,value:new ByteStream}}else if(s.position>this._start+s.value.length+r)return{position:-1,value:new ByteStream};return this.start=s.position,s}findAllSequences(e){const t=this.backward?this.start-this.length:this.start;return this.stream.findAllSequences(e,t,this.length)}findPairedPatterns(e,t,r=null){(null==r||r>this.length)&&(r=this.length);const s=this.backward?this.start-this.length:this.start,a=this.stream.findPairedPatterns(e,t,s,this.length);if(a.length)if(this.backward){if(a[0].right<this.start-t.length-r)return[]}else if(a[0].left>this.start+e.length+r)return[];return a}findPairedArrays(e,t,r=null){(null==r||r>this.length)&&(r=this.length);const s=this.backward?this.start-this.length:this.start,a=this.stream.findPairedArrays(e,t,s,this.length);if(a.length)if(this.backward){if(a[0].right.position<this.start-t[a[0].right.id].length-r)return[]}else if(a[0].left.position>this.start+e[a[0].left.id].length+r)return[];return a}replacePattern(e,t){const r=this.backward?this.start-this.length:this.start;return this.stream.replacePattern(e,t,r,this.length)}skipPatterns(e){const t=this.stream.skipPatterns(e,this.start,this.length,this.backward);return this.start=t,t}skipNotPatterns(e){const t=this.stream.skipNotPatterns(e,this.start,this.length,this.backward);return-1==t?-1:(this.start=t,t)}append(e){this.beforeAppend(e.length),this._stream.view.set(e.view,this._start),this._length+=2*e.length,this.start=this._start+e.length,this.prevLength-=2*e.length}appendView(e){this.beforeAppend(e.length),this._stream.view.set(e,this._start),this._length+=2*e.length,this.start=this._start+e.length,this.prevLength-=2*e.length}appendChar(e){this.beforeAppend(1),this._stream.view[this._start]=e,this._length+=2,this.start=this._start+1,this.prevLength-=2}appendUint16(e){this.beforeAppend(2);const t=new Uint16Array([e]),r=new Uint8Array(t.buffer);this.stream.view[this._start]=r[1],this._stream.view[this._start+1]=r[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendUint24(e){this.beforeAppend(3);const t=new Uint32Array([e]),r=new Uint8Array(t.buffer);this._stream.view[this._start]=r[2],this._stream.view[this._start+1]=r[1],this._stream.view[this._start+2]=r[0],this._length+=6,this.start=this._start+3,this.prevLength-=6}appendUint32(e){this.beforeAppend(4);const t=new Uint32Array([e]),r=new Uint8Array(t.buffer);this._stream.view[this._start]=r[3],this._stream.view[this._start+1]=r[2],this._stream.view[this._start+2]=r[1],this._stream.view[this._start+3]=r[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}appendInt16(e){this.beforeAppend(2);const t=new Int16Array([e]),r=new Uint8Array(t.buffer);this._stream.view[this._start]=r[1],this._stream.view[this._start+1]=r[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendInt32(e){this.beforeAppend(4);const t=new Int32Array([e]),r=new Uint8Array(t.buffer);this._stream.view[this._start]=r[3],this._stream.view[this._start+1]=r[2],this._stream.view[this._start+2]=r[1],this._stream.view[this._start+3]=r[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}getBlock(e,t=!0){if(this._length<=0)return new Uint8Array(0);let r;if(this._length<e&&(e=this._length),this.backward){const t=this._stream.view.subarray(this._length-e,this._length);r=new Uint8Array(e);for(let s=0;s<e;s++)r[e-1-s]=t[s]}else r=this._stream.view.subarray(this._start,this._start+e);return t&&(this.start+=this.backward?-1*e:e),r}getUint16(e=!0){const t=this.getBlock(2,e);return t.length<2?0:t[0]<<8|t[1]}getInt16(e=!0){const t=this.getUint16(e),r=32768;return t&r?-(r-(t^r)):t}getUint24(e=!0){const t=this.getBlock(4,e);return t.length<3?0:t[0]<<16|t[1]<<8|t[2]}getUint32(e=!0){const t=this.getBlock(4,e);return t.length<4?0:16777216*t[0]+(t[1]<<16)+(t[2]<<8)+t[3]}getInt32(e=!0){const t=this.getUint32(e),r=2147483648;return t&r?-(r-(t^r)):t}beforeAppend(e){this._start+e>this._stream.length&&(e>this.appendBlock&&(this.appendBlock=e+SeqStream.APPEND_BLOCK),this._stream.realloc(this._stream.length+this.appendBlock))}}function abytes(e,...t){if(!((r=e)instanceof Uint8Array||ArrayBuffer.isView(r)&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var r;if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function aexists(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function clean(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function createView(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function rotr(e,t){return e<<32-t|e>>>t}function rotl(e,t){return e<<t|e>>>32-t>>>0}function toBytes(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}(e)),abytes(e),e}SeqStream.APPEND_BLOCK=1e3;class Hash{}function createHasher(e){const hashC=t=>e().update(toBytes(t)).digest(),t=e();return hashC.outputLen=t.outputLen,hashC.blockLen=t.blockLen,hashC.create=()=>e(),hashC}function Chi(e,t,r){return e&t^~e&r}function Maj(e,t,r){return e&t^e&r^t&r}class HashMD extends Hash{constructor(e,t,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(e),this.view=createView(this.buffer)}update(e){aexists(this),abytes(e=toBytes(e));const{view:t,buffer:r,blockLen:s}=this,a=e.length;for(let i=0;i<a;){const n=Math.min(s-this.pos,a-i);if(n===s){const t=createView(e);for(;s<=a-i;i+=s)this.process(t,i);continue}r.set(e.subarray(i,i+n),this.pos),this.pos+=n,i+=n,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){aexists(this),function(e,t){abytes(e);const r=t.outputLen;if(e.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:a}=this;let{pos:i}=this;t[i++]=128,clean(this.buffer.subarray(i)),this.padOffset>s-i&&(this.process(r,0),i=0);for(let e=i;e<s;e++)t[e]=0;!function(e,t,r,s){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,s);const a=BigInt(32),i=BigInt(4294967295),n=Number(r>>a&i),o=Number(r&i),l=s?4:0,c=s?0:4;e.setUint32(t+l,n,s),e.setUint32(t+c,o,s)}(r,s-8,BigInt(8*this.length),a),this.process(r,0);const n=createView(e),o=this.outputLen;if(o%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=o/4,c=this.get();if(l>c.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<l;e++)n.setUint32(4*e,c[e],a)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:a,destroyed:i,pos:n}=this;return e.destroyed=i,e.finished=a,e.length=s,e.pos=n,s%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const ee=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),te=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),re=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),se=Uint32Array.from([1732584193,4023233417,2562383102,271733878,3285377520]),ae=new Uint32Array(80);let ie=class extends HashMD{constructor(){super(64,20,8,!1),this.A=0|se[0],this.B=0|se[1],this.C=0|se[2],this.D=0|se[3],this.E=0|se[4]}get(){const{A:e,B:t,C:r,D:s,E:a}=this;return[e,t,r,s,a]}set(e,t,r,s,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|s,this.E=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)ae[r]=e.getUint32(t,!1);for(let e=16;e<80;e++)ae[e]=rotl(ae[e-3]^ae[e-8]^ae[e-14]^ae[e-16],1);let{A:r,B:s,C:a,D:i,E:n}=this;for(let e=0;e<80;e++){let t,o;e<20?(t=Chi(s,a,i),o=1518500249):e<40?(t=s^a^i,o=1859775393):e<60?(t=Maj(s,a,i),o=2400959708):(t=s^a^i,o=3395469782);const l=rotl(r,5)+t+n+o+ae[e]|0;n=i,i=a,a=rotl(s,30),s=r,r=l}r=r+this.A|0,s=s+this.B|0,a=a+this.C|0,i=i+this.D|0,n=n+this.E|0,this.set(r,s,a,i,n)}roundClean(){clean(ae)}destroy(){this.set(0,0,0,0,0),clean(this.buffer)}};const ne=createHasher(()=>new ie),oe=BigInt(2**32-1),le=BigInt(32);function fromBig(e,t=!1){return t?{h:Number(e&oe),l:Number(e>>le&oe)}:{h:0|Number(e>>le&oe),l:0|Number(e&oe)}}const shrSH=(e,t,r)=>e>>>r,shrSL=(e,t,r)=>e<<32-r|t>>>r,rotrSH=(e,t,r)=>e>>>r|t<<32-r,rotrSL=(e,t,r)=>e<<32-r|t>>>r,rotrBH=(e,t,r)=>e<<64-r|t>>>r-32,rotrBL=(e,t,r)=>e>>>r-32|t<<64-r;function add(e,t,r,s){const a=(t>>>0)+(s>>>0);return{h:e+r+(a/2**32|0)|0,l:0|a}}const add3L=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),add3H=(e,t,r,s)=>t+r+s+(e/2**32|0)|0,add4L=(e,t,r,s)=>(e>>>0)+(t>>>0)+(r>>>0)+(s>>>0),add4H=(e,t,r,s,a)=>t+r+s+a+(e/2**32|0)|0,add5L=(e,t,r,s,a)=>(e>>>0)+(t>>>0)+(r>>>0)+(s>>>0)+(a>>>0),add5H=(e,t,r,s,a,i)=>t+r+s+a+i+(e/2**32|0)|0,ce=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ue=new Uint32Array(64);let he=class extends HashMD{constructor(e=32){super(64,e,8,!1),this.A=0|ee[0],this.B=0|ee[1],this.C=0|ee[2],this.D=0|ee[3],this.E=0|ee[4],this.F=0|ee[5],this.G=0|ee[6],this.H=0|ee[7]}get(){const{A:e,B:t,C:r,D:s,E:a,F:i,G:n,H:o}=this;return[e,t,r,s,a,i,n,o]}set(e,t,r,s,a,i,n,o){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|s,this.E=0|a,this.F=0|i,this.G=0|n,this.H=0|o}process(e,t){for(let r=0;r<16;r++,t+=4)ue[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=ue[e-15],r=ue[e-2],s=rotr(t,7)^rotr(t,18)^t>>>3,a=rotr(r,17)^rotr(r,19)^r>>>10;ue[e]=a+ue[e-7]+s+ue[e-16]|0}let{A:r,B:s,C:a,D:i,E:n,F:o,G:l,H:c}=this;for(let e=0;e<64;e++){const t=c+(rotr(n,6)^rotr(n,11)^rotr(n,25))+Chi(n,o,l)+ce[e]+ue[e]|0,u=(rotr(r,2)^rotr(r,13)^rotr(r,22))+Maj(r,s,a)|0;c=l,l=o,o=n,n=i+t|0,i=a,a=s,s=r,r=t+u|0}r=r+this.A|0,s=s+this.B|0,a=a+this.C|0,i=i+this.D|0,n=n+this.E|0,o=o+this.F|0,l=l+this.G|0,c=c+this.H|0,this.set(r,s,a,i,n,o,l,c)}roundClean(){clean(ue)}destroy(){this.set(0,0,0,0,0,0,0,0),clean(this.buffer)}};const me=(()=>function(e,t=!1){const r=e.length;let s=new Uint32Array(r),a=new Uint32Array(r);for(let i=0;i<r;i++){const{h:r,l:n}=fromBig(e[i],t);[s[i],a[i]]=[r,n]}return[s,a]}(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))))(),fe=(()=>me[0])(),ge=(()=>me[1])(),de=new Uint32Array(80),pe=new Uint32Array(80);let Se=class extends HashMD{constructor(e=64){super(128,e,16,!1),this.Ah=0|re[0],this.Al=0|re[1],this.Bh=0|re[2],this.Bl=0|re[3],this.Ch=0|re[4],this.Cl=0|re[5],this.Dh=0|re[6],this.Dl=0|re[7],this.Eh=0|re[8],this.El=0|re[9],this.Fh=0|re[10],this.Fl=0|re[11],this.Gh=0|re[12],this.Gl=0|re[13],this.Hh=0|re[14],this.Hl=0|re[15]}get(){const{Ah:e,Al:t,Bh:r,Bl:s,Ch:a,Cl:i,Dh:n,Dl:o,Eh:l,El:c,Fh:u,Fl:h,Gh:m,Gl:f,Hh:g,Hl:d}=this;return[e,t,r,s,a,i,n,o,l,c,u,h,m,f,g,d]}set(e,t,r,s,a,i,n,o,l,c,u,h,m,f,g,d){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|s,this.Ch=0|a,this.Cl=0|i,this.Dh=0|n,this.Dl=0|o,this.Eh=0|l,this.El=0|c,this.Fh=0|u,this.Fl=0|h,this.Gh=0|m,this.Gl=0|f,this.Hh=0|g,this.Hl=0|d}process(e,t){for(let r=0;r<16;r++,t+=4)de[r]=e.getUint32(t),pe[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|de[e-15],r=0|pe[e-15],s=rotrSH(t,r,1)^rotrSH(t,r,8)^shrSH(t,0,7),a=rotrSL(t,r,1)^rotrSL(t,r,8)^shrSL(t,r,7),i=0|de[e-2],n=0|pe[e-2],o=rotrSH(i,n,19)^rotrBH(i,n,61)^shrSH(i,0,6),l=rotrSL(i,n,19)^rotrBL(i,n,61)^shrSL(i,n,6),c=add4L(a,l,pe[e-7],pe[e-16]),u=add4H(c,s,o,de[e-7],de[e-16]);de[e]=0|u,pe[e]=0|c}let{Ah:r,Al:s,Bh:a,Bl:i,Ch:n,Cl:o,Dh:l,Dl:c,Eh:u,El:h,Fh:m,Fl:f,Gh:g,Gl:d,Hh:p,Hl:S}=this;for(let e=0;e<80;e++){const t=rotrSH(u,h,14)^rotrSH(u,h,18)^rotrBH(u,h,41),y=rotrSL(u,h,14)^rotrSL(u,h,18)^rotrBL(u,h,41),w=u&m^~u&g,v=add5L(S,y,h&f^~h&d,ge[e],pe[e]),b=add5H(v,p,t,w,fe[e],de[e]),A=0|v,k=rotrSH(r,s,28)^rotrBH(r,s,34)^rotrBH(r,s,39),C=rotrSL(r,s,28)^rotrBL(r,s,34)^rotrBL(r,s,39),V=r&a^r&n^a&n,B=s&i^s&o^i&o;p=0|g,S=0|d,g=0|m,d=0|f,m=0|u,f=0|h,({h:u,l:h}=add(0|l,0|c,0|b,0|A)),l=0|n,c=0|o,n=0|a,o=0|i,a=0|r,i=0|s;const I=add3L(A,C,B);r=add3H(I,b,k,V),s=0|I}({h:r,l:s}=add(0|this.Ah,0|this.Al,0|r,0|s)),({h:a,l:i}=add(0|this.Bh,0|this.Bl,0|a,0|i)),({h:n,l:o}=add(0|this.Ch,0|this.Cl,0|n,0|o)),({h:l,l:c}=add(0|this.Dh,0|this.Dl,0|l,0|c)),({h:u,l:h}=add(0|this.Eh,0|this.El,0|u,0|h)),({h:m,l:f}=add(0|this.Fh,0|this.Fl,0|m,0|f)),({h:g,l:d}=add(0|this.Gh,0|this.Gl,0|g,0|d)),({h:p,l:S}=add(0|this.Hh,0|this.Hl,0|p,0|S)),this.set(r,s,a,i,n,o,l,c,u,h,m,f,g,d,p,S)}roundClean(){clean(de,pe)}destroy(){clean(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}},ye=class extends Se{constructor(){super(48),this.Ah=0|te[0],this.Al=0|te[1],this.Bh=0|te[2],this.Bl=0|te[3],this.Ch=0|te[4],this.Cl=0|te[5],this.Dh=0|te[6],this.Dl=0|te[7],this.Eh=0|te[8],this.El=0|te[9],this.Fh=0|te[10],this.Fl=0|te[11],this.Gh=0|te[12],this.Gl=0|te[13],this.Hh=0|te[14],this.Hl=0|te[15]}};const we=createHasher(()=>new he),ve=createHasher(()=>new Se),be=createHasher(()=>new ye),Ae=new ArrayBuffer(0),ke="";class ArgumentError extends TypeError{constructor(){super(...arguments),this.name=ArgumentError.NAME}static isType(e,t){if("string"==typeof t){if("Array"===t&&Array.isArray(e))return!0;if("ArrayBuffer"===t&&e instanceof ArrayBuffer)return!0;if("ArrayBufferView"===t&&ArrayBuffer.isView(e))return!0;if(typeof e===t)return!0}else if(e instanceof t)return!0;return!1}static assert(e,t,...r){for(const t of r)if(this.isType(e,t))return;const s=r.map(e=>e instanceof Function&&"name"in e?e.name:`${e}`);throw new ArgumentError(`Parameter '${t}' is not of type ${s.length>1?`(${s.join(" or ")})`:s[0]}`)}}ArgumentError.NAME="ArgumentError";class ParameterError extends TypeError{static assert(...e){let t,r,s=null;"string"==typeof e[0]?(s=e[0],t=e[1],r=e.slice(2)):(t=e[0],r=e.slice(1)),ArgumentError.assert(t,"parameters","object");for(const e of r){const r=t[e];if(null==r)throw new ParameterError(e,s)}}static assertEmpty(e,t,r){if(null==e)throw new ParameterError(t,r)}constructor(e,t=null,r){super(),this.name=ParameterError.NAME,this.field=e,t&&(this.target=t),this.message=r||`Absent mandatory parameter '${e}' ${t?` in '${t}'`:ke}`}}ParameterError.NAME="ParameterError";class AsnError extends Error{static assertSchema(e,t){if(!e.verified)throw new Error(`Object's schema was not verified against input data for ${t}`)}static assert(e,t){if(-1===e.offset)throw new AsnError(`Error during parsing of ASN.1 data. Data is not correct for '${t}'.`)}constructor(e){super(e),this.name="AsnError"}}class PkiObject{static blockName(){return this.CLASS_NAME}static fromBER(e){const t=fromBER(e);AsnError.assert(t,this.name);try{return new this({schema:t.result})}catch(e){throw new AsnError(`Cannot create '${this.CLASS_NAME}' from ASN.1 object`)}}static defaultValues(e){throw new Error(`Invalid member name for ${this.CLASS_NAME} class: ${e}`)}static schema(e={}){throw new Error(`Method '${this.CLASS_NAME}.schema' should be overridden`)}get className(){return this.constructor.CLASS_NAME}toString(e="hex"){let t;try{t=this.toSchema()}catch{t=this.toSchema(!0)}return Convert.ToString(t.toBER(),e)}}function stringPrep(e){let t=!1,r=ke;const s=e.trim();for(let e=0;e<s.length;e++)32===s.charCodeAt(e)?!1===t&&(t=!0):(t&&(r+=" ",t=!1),r+=s[e]);return r.toLowerCase()}PkiObject.CLASS_NAME="PkiObject";const Ce="type",Ve="value";class AttributeTypeAndValue extends PkiObject{constructor(e={}){super(),this.type=getParametersValue(e,Ce,AttributeTypeAndValue.defaultValues(Ce)),this.value=getParametersValue(e,Ve,AttributeTypeAndValue.defaultValues(Ve)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ce:return ke;case Ve:return{};default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.type||ke}),new Any({name:t.value||ke})]})}fromSchema(e){clearProps(e,[Ce,"typeValue"]);const t=compareSchema(e,e,AttributeTypeAndValue.schema({names:{type:Ce,value:"typeValue"}}));AsnError.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.type}),this.value]})}toJSON(){const e={type:this.type};return 0!==Object.keys(this.value).length?e.value=this.value.toJSON():e.value=this.value,e}isEqual(e){const t=[Utf8String.blockName(),BmpString.blockName(),UniversalString.blockName(),NumericString.blockName(),PrintableString.blockName(),TeletexString.blockName(),VideotexString.blockName(),IA5String.blockName(),GraphicString.blockName(),VisibleString.blockName(),GeneralString.blockName(),CharacterString.blockName()];if(e instanceof ArrayBuffer)return BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView,e);if(e.constructor.blockName()===AttributeTypeAndValue.blockName()){if(this.type!==e.type)return!1;const r=[!1,!1],s=this.value.constructor.blockName();for(const a of t)s===a&&(r[0]=!0),e.value.constructor.blockName()===a&&(r[1]=!0);if(r[0]!==r[1])return!1;if(r[0]&&r[1]){const t=stringPrep(this.value.valueBlock.value),r=stringPrep(e.value.valueBlock.value);if(0!==t.localeCompare(r))return!1}else if(!BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView,e.value.valueBeforeDecodeView))return!1;return!0}return!1}}AttributeTypeAndValue.CLASS_NAME="AttributeTypeAndValue";const Be="typesAndValues",Ie="valueBeforeDecode";class RelativeDistinguishedNames extends PkiObject{constructor(e={}){super(),this.typesAndValues=getParametersValue(e,Be,RelativeDistinguishedNames.defaultValues(Be)),this.valueBeforeDecode=getParametersValue(e,Ie,RelativeDistinguishedNames.defaultValues(Ie)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Be:return[];case Ie:return Ae;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Be:return 0===t.length;case Ie:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.repeatedSequence||ke,value:new Set({value:[new Repeated({name:t.repeatedSet||ke,value:AttributeTypeAndValue.schema(t.typeAndValue||{})})]})})]})}fromSchema(e){clearProps(e,["RDN",Be]);const t=compareSchema(e,e,RelativeDistinguishedNames.schema({names:{blockName:"RDN",repeatedSet:Be}}));AsnError.assertSchema(t,this.className),Be in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,e=>new AttributeTypeAndValue({schema:e}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecodeView.slice().buffer}toSchema(){if(0===this.valueBeforeDecode.byteLength)return new Sequence({value:[new Set({value:Array.from(this.typesAndValues,e=>e.toSchema())})]});const e=fromBER(this.valueBeforeDecode);if(AsnError.assert(e,"RelativeDistinguishedNames"),!(e.result instanceof Sequence))throw new Error("ASN.1 result should be SEQUENCE");return e.result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof RelativeDistinguishedNames){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(const[t,r]of this.typesAndValues.entries())if(!1===r.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&isEqualBuffer(this.valueBeforeDecode,e)}}RelativeDistinguishedNames.CLASS_NAME="RelativeDistinguishedNames";const Ne="type",Pe="value";function builtInStandardAttributes(e={},t=!1){const r=getParametersValue(e,"names",{});return new Sequence({optional:t,value:[new Constructed({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:r.country_name||ke,value:[new Choice({value:[new NumericString,new PrintableString]})]}),new Constructed({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:r.administration_domain_name||ke,value:[new Choice({value:[new NumericString,new PrintableString]})]}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:r.network_address||ke,isHexOnly:!0}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:r.terminal_identifier||ke,isHexOnly:!0}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:r.private_domain_name||ke,value:[new Choice({value:[new NumericString,new PrintableString]})]}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:r.organization_name||ke,isHexOnly:!0}),new Primitive({optional:!0,name:r.numeric_user_identifier||ke,idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new Constructed({optional:!0,name:r.personal_name||ke,idBlock:{tagClass:3,tagNumber:5},value:[new Primitive({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new Constructed({optional:!0,name:r.organizational_unit_names||ke,idBlock:{tagClass:3,tagNumber:6},value:[new Repeated({value:new PrintableString})]})]})}function builtInDomainDefinedAttributes(e=!1){return new Sequence({optional:e,value:[new PrintableString,new PrintableString]})}function extensionAttributes(e=!1){return new Set({optional:e,value:[new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Any]})]})}class GeneralName extends PkiObject{constructor(e={}){super(),this.type=getParametersValue(e,Ne,GeneralName.defaultValues(Ne)),this.value=getParametersValue(e,Pe,GeneralName.defaultValues(Pe)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ne:return 9;case Pe:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ne:return t===GeneralName.defaultValues(e);case Pe:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Choice({value:[new Constructed({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||ke,value:[new ObjectIdentifier,new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any]})]}),new Primitive({name:t.blockName||ke,idBlock:{tagClass:3,tagNumber:1}}),new Primitive({name:t.blockName||ke,idBlock:{tagClass:3,tagNumber:2}}),new Constructed({idBlock:{tagClass:3,tagNumber:3},name:t.blockName||ke,value:[builtInStandardAttributes(t.builtInStandardAttributes||{},!1),builtInDomainDefinedAttributes(!0),extensionAttributes(!0)]}),new Constructed({idBlock:{tagClass:3,tagNumber:4},name:t.blockName||ke,value:[RelativeDistinguishedNames.schema(t.directoryName||{})]}),new Constructed({idBlock:{tagClass:3,tagNumber:5},name:t.blockName||ke,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Choice({value:[new TeletexString,new PrintableString,new UniversalString,new Utf8String,new BmpString]})]}),new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new Choice({value:[new TeletexString,new PrintableString,new UniversalString,new Utf8String,new BmpString]})]})]}),new Primitive({name:t.blockName||ke,idBlock:{tagClass:3,tagNumber:6}}),new Primitive({name:t.blockName||ke,idBlock:{tagClass:3,tagNumber:7}}),new Primitive({name:t.blockName||ke,idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){clearProps(e,["blockName","otherName","rfc822Name","dNSName","x400Address","directoryName","ediPartyName","uniformResourceIdentifier","iPAddress","registeredID"]);const t=compareSchema(e,e,GeneralName.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));switch(AsnError.assertSchema(t,this.className),this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:case 3:this.value=t.result.blockName;break;case 1:case 2:case 6:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;const r=fromBER(e.toBER(!1));AsnError.assert(r,"GeneralName value"),this.value=r.result.valueBlock.value}break;case 4:this.value=new RelativeDistinguishedNames({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new OctetString({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;const r=fromBER(e.toBER(!1));AsnError.assert(r,"GeneralName registeredID"),this.value=r.result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new Constructed({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{const e=new IA5String({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new Constructed({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{const e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{const e=new ObjectIdentifier({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return GeneralName.schema()}}toJSON(){const e={type:this.type,value:ke};if("string"==typeof this.value)e.value=this.value;else try{e.value=this.value.toJSON()}catch(e){}return e}}GeneralName.CLASS_NAME="GeneralName";const Ee="accessMethod",De="accessLocation",Oe=[Ee,De];class AccessDescription extends PkiObject{constructor(e={}){super(),this.accessMethod=getParametersValue(e,Ee,AccessDescription.defaultValues(Ee)),this.accessLocation=getParametersValue(e,De,AccessDescription.defaultValues(De)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ee:return ke;case De:return new GeneralName;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.accessMethod||ke}),GeneralName.schema(t.accessLocation||{})]})}fromSchema(e){clearProps(e,Oe);const t=compareSchema(e,e,AccessDescription.schema({names:{accessMethod:Ee,accessLocation:{names:{blockName:De}}}}));AsnError.assertSchema(t,this.className),this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new GeneralName({schema:t.result.accessLocation})}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}AccessDescription.CLASS_NAME="AccessDescription";const xe="seconds",Re="millis",Ke="micros";class Accuracy extends PkiObject{constructor(e={}){super(),xe in e&&(this.seconds=getParametersValue(e,xe,Accuracy.defaultValues(xe))),Re in e&&(this.millis=getParametersValue(e,Re,Accuracy.defaultValues(Re))),Ke in e&&(this.micros=getParametersValue(e,Ke,Accuracy.defaultValues(Ke))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case xe:case Re:case Ke:return 0;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case xe:case Re:case Ke:return t===Accuracy.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,optional:!0,value:[new Integer({optional:!0,name:t.seconds||ke}),new Primitive({name:t.millis||ke,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new Primitive({name:t.micros||ke,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){clearProps(e,[xe,Re,Ke]);const t=compareSchema(e,e,Accuracy.schema({names:{seconds:xe,millis:Re,micros:Ke}}));if(AsnError.assertSchema(t,this.className),"seconds"in t.result&&(this.seconds=t.result.seconds.valueBlock.valueDec),"millis"in t.result){const e=new Integer({valueHex:t.result.millis.valueBlock.valueHex});this.millis=e.valueBlock.valueDec}if("micros"in t.result){const e=new Integer({valueHex:t.result.micros.valueBlock.valueHex});this.micros=e.valueBlock.valueDec}}toSchema(){const e=[];if(void 0!==this.seconds&&e.push(new Integer({value:this.seconds})),void 0!==this.millis){const t=new Integer({value:this.millis});e.push(new Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:t.valueBlock.valueHexView}))}if(void 0!==this.micros){const t=new Integer({value:this.micros});e.push(new Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:t.valueBlock.valueHexView}))}return new Sequence({value:e})}toJSON(){const e={};return void 0!==this.seconds&&(e.seconds=this.seconds),void 0!==this.millis&&(e.millis=this.millis),void 0!==this.micros&&(e.micros=this.micros),e}}Accuracy.CLASS_NAME="Accuracy";const Ue="algorithmId",Te="algorithmParams",Le="algorithm",He="params",qe=[Le,He];class AlgorithmIdentifier extends PkiObject{constructor(e={}){super(),this.algorithmId=getParametersValue(e,Ue,AlgorithmIdentifier.defaultValues(Ue)),Te in e&&(this.algorithmParams=getParametersValue(e,Te,AlgorithmIdentifier.defaultValues(Te))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ue:return ke;case Te:return new Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ue:return t===ke;case Te:return t instanceof Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,optional:t.optional||!1,value:[new ObjectIdentifier({name:t.algorithmIdentifier||ke}),new Any({name:t.algorithmParams||ke,optional:!0})]})}fromSchema(e){clearProps(e,qe);const t=compareSchema(e,e,AlgorithmIdentifier.schema({names:{algorithmIdentifier:Le,algorithmParams:He}}));AsnError.assertSchema(t,this.className),this.algorithmId=t.result.algorithm.valueBlock.toString(),He in t.result&&(this.algorithmParams=t.result.params)}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.algorithmId})),!this.algorithmParams||this.algorithmParams instanceof Any||e.push(this.algorithmParams),new Sequence({value:e})}toJSON(){const e={algorithmId:this.algorithmId};return!this.algorithmParams||this.algorithmParams instanceof Any||(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof AlgorithmIdentifier&&(this.algorithmId===e.algorithmId&&(this.algorithmParams?!!e.algorithmParams&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!e.algorithmParams))}}AlgorithmIdentifier.CLASS_NAME="AlgorithmIdentifier";const je="altNames",Me=[je];class AltName extends PkiObject{constructor(e={}){super(),this.altNames=getParametersValue(e,je,AltName.defaultValues(je)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===je?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.altNames||ke,value:GeneralName.schema()})]})}fromSchema(e){clearProps(e,Me);const t=compareSchema(e,e,AltName.schema({names:{altNames:je}}));AsnError.assertSchema(t,this.className),je in t.result&&(this.altNames=Array.from(t.result.altNames,e=>new GeneralName({schema:e})))}toSchema(){return new Sequence({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}}AltName.CLASS_NAME="AltName";const Je="type",_e="values",Fe=[Je,_e];class Attribute extends PkiObject{constructor(e={}){super(),this.type=getParametersValue(e,Je,Attribute.defaultValues(Je)),this.values=getParametersValue(e,_e,Attribute.defaultValues(_e)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Je:return ke;case _e:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Je:return t===ke;case _e:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.type||ke}),new Set({name:t.setName||ke,value:[new Repeated({name:t.values||ke,value:new Any})]})]})}fromSchema(e){clearProps(e,Fe);const t=compareSchema(e,e,Attribute.schema({names:{type:Je,values:_e}}));AsnError.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.type}),new Set({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}}Attribute.CLASS_NAME="Attribute";const $e="notBeforeTime",We="notAfterTime",Ge=[$e,We];class AttCertValidityPeriod extends PkiObject{constructor(e={}){super(),this.notBeforeTime=getParametersValue(e,$e,AttCertValidityPeriod.defaultValues($e)),this.notAfterTime=getParametersValue(e,We,AttCertValidityPeriod.defaultValues(We)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case $e:case We:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new GeneralizedTime({name:t.notBeforeTime||ke}),new GeneralizedTime({name:t.notAfterTime||ke})]})}fromSchema(e){clearProps(e,Ge);const t=compareSchema(e,e,AttCertValidityPeriod.schema({names:{notBeforeTime:$e,notAfterTime:We}}));AsnError.assertSchema(t,this.className),this.notBeforeTime=t.result.notBeforeTime.toDate(),this.notAfterTime=t.result.notAfterTime.toDate()}toSchema(){return new Sequence({value:[new GeneralizedTime({valueDate:this.notBeforeTime}),new GeneralizedTime({valueDate:this.notAfterTime})]})}toJSON(){return{notBeforeTime:this.notBeforeTime,notAfterTime:this.notAfterTime}}}AttCertValidityPeriod.CLASS_NAME="AttCertValidityPeriod";const ze="names",Qe="generalNames";class GeneralNames extends PkiObject{constructor(e={}){super(),this.names=getParametersValue(e,ze,GeneralNames.defaultValues(ze)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return"names"===e?[]:super.defaultValues(e)}static schema(e={},t=!1){const r=getParametersValue(e,ze,{});return new Sequence({optional:t,name:r.blockName||ke,value:[new Repeated({name:r.generalNames||ke,value:GeneralName.schema()})]})}fromSchema(e){clearProps(e,[ze,Qe]);const t=compareSchema(e,e,GeneralNames.schema({names:{blockName:ze,generalNames:Qe}}));AsnError.assertSchema(t,this.className),this.names=Array.from(t.result.generalNames,e=>new GeneralName({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}}GeneralNames.CLASS_NAME="GeneralNames";const Ze="2.5.29.17",Ye="2.5.29.18",Xe="2.5.29.19",et="2.5.29.28",tt="2.5.29.29",rt="2.5.29.30",st="2.5.29.31",at="2.5.29.46",it="2.5.29.32",nt="2.5.29.32.0",ot="2.5.29.33",lt="2.5.29.35",ct="2.5.29.36",ut="1.3.6.1.5.5.7.1.1",ht="1.2.840.113549.1.7.1",mt="1.2.840.113549.1.7.2",ft="1.2.840.113549.1.7.3",gt="1.2.840.113549.1.7.6",dt="1.2.840.113549.1.9.22.1",pt="1.2.840.113549.1.9.22.3",St="1.2.840.113549.1.9.23.1",yt="1.3.6.1.5.5.7.48.1.1",wt="keyIdentifier",vt="authorityCertIssuer",bt="authorityCertSerialNumber",At=[wt,vt,bt];class AuthorityKeyIdentifier extends PkiObject{constructor(e={}){super(),wt in e&&(this.keyIdentifier=getParametersValue(e,wt,AuthorityKeyIdentifier.defaultValues(wt))),vt in e&&(this.authorityCertIssuer=getParametersValue(e,vt,AuthorityKeyIdentifier.defaultValues(vt))),bt in e&&(this.authorityCertSerialNumber=getParametersValue(e,bt,AuthorityKeyIdentifier.defaultValues(bt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case wt:return new OctetString;case vt:return[];case bt:return new Integer;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Primitive({name:t.keyIdentifier||ke,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Repeated({name:t.authorityCertIssuer||ke,value:GeneralName.schema()})]}),new Primitive({name:t.authorityCertSerialNumber||ke,optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){clearProps(e,At);const t=compareSchema(e,e,AuthorityKeyIdentifier.schema({names:{keyIdentifier:wt,authorityCertIssuer:vt,authorityCertSerialNumber:bt}}));AsnError.assertSchema(t,this.className),wt in t.result&&(this.keyIdentifier=new OctetString({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),vt in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,e=>new GeneralName({schema:e}))),bt in t.result&&(this.authorityCertSerialNumber=new Integer({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){const e=[];return this.keyIdentifier&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.keyIdentifier.valueBlock.valueHexView})),this.authorityCertIssuer&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,e=>e.toSchema())})),this.authorityCertSerialNumber&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:2},valueHex:this.authorityCertSerialNumber.valueBlock.valueHexView})),new Sequence({value:e})}toJSON(){const e={};return this.keyIdentifier&&(e.keyIdentifier=this.keyIdentifier.toJSON()),this.authorityCertIssuer&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,e=>e.toJSON())),this.authorityCertSerialNumber&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}AuthorityKeyIdentifier.CLASS_NAME="AuthorityKeyIdentifier";const kt="pathLenConstraint",Ct="cA";class BasicConstraints extends PkiObject{constructor(e={}){super(),this.cA=getParametersValue(e,Ct,!1),kt in e&&(this.pathLenConstraint=getParametersValue(e,kt,0)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e!==Ct&&super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Boolean({optional:!0,name:t.cA||ke}),new Integer({optional:!0,name:t.pathLenConstraint||ke})]})}fromSchema(e){clearProps(e,[Ct,kt]);const t=compareSchema(e,e,BasicConstraints.schema({names:{cA:Ct,pathLenConstraint:kt}}));AsnError.assertSchema(t,this.className),Ct in t.result&&(this.cA=t.result.cA.valueBlock.value),kt in t.result&&(t.result.pathLenConstraint.valueBlock.isHexOnly?this.pathLenConstraint=t.result.pathLenConstraint:this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){const e=[];return this.cA!==BasicConstraints.defaultValues(Ct)&&e.push(new Boolean({value:this.cA})),kt in this&&(this.pathLenConstraint instanceof Integer?e.push(this.pathLenConstraint):e.push(new Integer({value:this.pathLenConstraint}))),new Sequence({value:e})}toJSON(){const e={};return this.cA!==BasicConstraints.defaultValues(Ct)&&(e.cA=this.cA),kt in this&&(this.pathLenConstraint instanceof Integer?e.pathLenConstraint=this.pathLenConstraint.toJSON():e.pathLenConstraint=this.pathLenConstraint),e}}BasicConstraints.CLASS_NAME="BasicConstraints";const Vt="certificateIndex",Bt="keyIndex";class CAVersion extends PkiObject{constructor(e={}){super(),this.certificateIndex=getParametersValue(e,Vt,CAVersion.defaultValues(Vt)),this.keyIndex=getParametersValue(e,Bt,CAVersion.defaultValues(Bt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Vt:case Bt:return 0;default:return super.defaultValues(e)}}static schema(){return new Integer}fromSchema(e){if(e.constructor.blockName()!==Integer.blockName())throw new Error("Object's schema was not verified against input data for CAVersion");let t=e.valueBlock.valueHex.slice(0);const r=new Uint8Array(t);switch(!0){case t.byteLength<4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(r,4-t.byteLength),t=e.slice(0)}break;case t.byteLength>4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(r.slice(0,4)),t=e.slice(0)}}const s=t.slice(0,2),a=new Uint8Array(s);let i=a[0];a[0]=a[1],a[1]=i;const n=new Uint16Array(s);this.keyIndex=n[0];const o=t.slice(2),l=new Uint8Array(o);i=l[0],l[0]=l[1],l[1]=i;const c=new Uint16Array(o);this.certificateIndex=c[0]}toSchema(){const e=new ArrayBuffer(2);new Uint16Array(e)[0]=this.certificateIndex;const t=new Uint8Array(e);let r=t[0];t[0]=t[1],t[1]=r;const s=new ArrayBuffer(2);new Uint16Array(s)[0]=this.keyIndex;const a=new Uint8Array(s);return r=a[0],a[0]=a[1],a[1]=r,new Integer({valueHex:utilConcatBuf(s,e)})}toJSON(){return{certificateIndex:this.certificateIndex,keyIndex:this.keyIndex}}}CAVersion.CLASS_NAME="CAVersion";const It="policyQualifierId",Nt="qualifier",Pt=[It,Nt];class PolicyQualifierInfo extends PkiObject{constructor(e={}){super(),this.policyQualifierId=getParametersValue(e,It,PolicyQualifierInfo.defaultValues(It)),this.qualifier=getParametersValue(e,Nt,PolicyQualifierInfo.defaultValues(Nt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case It:return ke;case Nt:return new Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.policyQualifierId||ke}),new Any({name:t.qualifier||ke})]})}fromSchema(e){clearProps(e,Pt);const t=compareSchema(e,e,PolicyQualifierInfo.schema({names:{policyQualifierId:It,qualifier:Nt}}));AsnError.assertSchema(t,this.className),this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}PolicyQualifierInfo.CLASS_NAME="PolicyQualifierInfo";const Et="policyIdentifier",Dt="policyQualifiers",Ot=[Et,Dt];class PolicyInformation extends PkiObject{constructor(e={}){super(),this.policyIdentifier=getParametersValue(e,Et,PolicyInformation.defaultValues(Et)),Dt in e&&(this.policyQualifiers=getParametersValue(e,Dt,PolicyInformation.defaultValues(Dt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Et:return ke;case Dt:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.policyIdentifier||ke}),new Sequence({optional:!0,value:[new Repeated({name:t.policyQualifiers||ke,value:PolicyQualifierInfo.schema()})]})]})}fromSchema(e){clearProps(e,Ot);const t=compareSchema(e,e,PolicyInformation.schema({names:{policyIdentifier:Et,policyQualifiers:Dt}}));AsnError.assertSchema(t,this.className),this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),Dt in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,e=>new PolicyQualifierInfo({schema:e})))}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.policyIdentifier})),this.policyQualifiers&&e.push(new Sequence({value:Array.from(this.policyQualifiers,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={policyIdentifier:this.policyIdentifier};return this.policyQualifiers&&(e.policyQualifiers=Array.from(this.policyQualifiers,e=>e.toJSON())),e}}PolicyInformation.CLASS_NAME="PolicyInformation";const xt="certificatePolicies",Rt=[xt];class CertificatePolicies extends PkiObject{constructor(e={}){super(),this.certificatePolicies=getParametersValue(e,xt,CertificatePolicies.defaultValues(xt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===xt?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.certificatePolicies||ke,value:PolicyInformation.schema()})]})}fromSchema(e){clearProps(e,Rt);const t=compareSchema(e,e,CertificatePolicies.schema({names:{certificatePolicies:xt}}));AsnError.assertSchema(t,this.className),this.certificatePolicies=Array.from(t.result.certificatePolicies,e=>new PolicyInformation({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}}CertificatePolicies.CLASS_NAME="CertificatePolicies";const Kt="templateID",Ut="templateMajorVersion",Tt="templateMinorVersion",Lt=[Kt,Ut,Tt];class CertificateTemplate extends PkiObject{constructor(e={}){super(),this.templateID=getParametersValue(e,Kt,CertificateTemplate.defaultValues(Kt)),Ut in e&&(this.templateMajorVersion=getParametersValue(e,Ut,CertificateTemplate.defaultValues(Ut))),Tt in e&&(this.templateMinorVersion=getParametersValue(e,Tt,CertificateTemplate.defaultValues(Tt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Kt:return ke;case Ut:case Tt:return 0;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.templateID||ke}),new Integer({name:t.templateMajorVersion||ke,optional:!0}),new Integer({name:t.templateMinorVersion||ke,optional:!0})]})}fromSchema(e){clearProps(e,Lt);const t=compareSchema(e,e,CertificateTemplate.schema({names:{templateID:Kt,templateMajorVersion:Ut,templateMinorVersion:Tt}}));AsnError.assertSchema(t,this.className),this.templateID=t.result.templateID.valueBlock.toString(),Ut in t.result&&(this.templateMajorVersion=t.result.templateMajorVersion.valueBlock.valueDec),Tt in t.result&&(this.templateMinorVersion=t.result.templateMinorVersion.valueBlock.valueDec)}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.templateID})),Ut in this&&e.push(new Integer({value:this.templateMajorVersion})),Tt in this&&e.push(new Integer({value:this.templateMinorVersion})),new Sequence({value:e})}toJSON(){const e={templateID:this.templateID};return Ut in this&&(e.templateMajorVersion=this.templateMajorVersion),Tt in this&&(e.templateMinorVersion=this.templateMinorVersion),e}}const Ht="distributionPoint",qt="distributionPointNames",jt="reasons",Mt="cRLIssuer",Jt="cRLIssuerNames",_t=[Ht,qt,jt,Mt,Jt];class DistributionPoint extends PkiObject{constructor(e={}){super(),Ht in e&&(this.distributionPoint=getParametersValue(e,Ht,DistributionPoint.defaultValues(Ht))),jt in e&&(this.reasons=getParametersValue(e,jt,DistributionPoint.defaultValues(jt))),Mt in e&&(this.cRLIssuer=getParametersValue(e,Mt,DistributionPoint.defaultValues(Mt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ht:return[];case jt:return new BitString;case Mt:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Choice({value:[new Constructed({name:t.distributionPoint||ke,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({name:t.distributionPointNames||ke,value:GeneralName.schema()})]}),new Constructed({name:t.distributionPoint||ke,optional:!0,idBlock:{tagClass:3,tagNumber:1},value:RelativeDistinguishedNames.schema().valueBlock.value})]})]}),new Primitive({name:t.reasons||ke,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new Constructed({name:t.cRLIssuer||ke,optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new Repeated({name:t.cRLIssuerNames||ke,value:GeneralName.schema()})]})]})}fromSchema(e){clearProps(e,_t);const t=compareSchema(e,e,DistributionPoint.schema({names:{distributionPoint:Ht,distributionPointNames:qt,reasons:jt,cRLIssuer:Mt,cRLIssuerNames:Jt}}));AsnError.assertSchema(t,this.className),Ht in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new GeneralName({schema:e}))),1===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=new RelativeDistinguishedNames({schema:new Sequence({value:t.result.distributionPoint.valueBlock.value})}))),jt in t.result&&(this.reasons=new BitString({valueHex:t.result.reasons.valueBlock.valueHex})),Mt in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,e=>new GeneralName({schema:e})))}toSchema(){const e=[];if(this.distributionPoint){let t;t=this.distributionPoint instanceof Array?new Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return this.reasons&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHexView})),this.cRLIssuer&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.reasons&&(e.reasons=this.reasons.toJSON()),this.cRLIssuer&&(e.cRLIssuer=Array.from(this.cRLIssuer,e=>e.toJSON())),e}}DistributionPoint.CLASS_NAME="DistributionPoint";const Ft="distributionPoints",$t=[Ft];class CRLDistributionPoints extends PkiObject{constructor(e={}){super(),this.distributionPoints=getParametersValue(e,Ft,CRLDistributionPoints.defaultValues(Ft)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Ft?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.distributionPoints||ke,value:DistributionPoint.schema()})]})}fromSchema(e){clearProps(e,$t);const t=compareSchema(e,e,CRLDistributionPoints.schema({names:{distributionPoints:Ft}}));AsnError.assertSchema(t,this.className),this.distributionPoints=Array.from(t.result.distributionPoints,e=>new DistributionPoint({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}}CRLDistributionPoints.CLASS_NAME="CRLDistributionPoints";const Wt="keyPurposes",Gt=[Wt];class ExtKeyUsage extends PkiObject{constructor(e={}){super(),this.keyPurposes=getParametersValue(e,Wt,ExtKeyUsage.defaultValues(Wt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Wt?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.keyPurposes||ke,value:new ObjectIdentifier})]})}fromSchema(e){clearProps(e,Gt);const t=compareSchema(e,e,ExtKeyUsage.schema({names:{keyPurposes:Wt}}));AsnError.assertSchema(t,this.className),this.keyPurposes=Array.from(t.result.keyPurposes,e=>e.valueBlock.toString())}toSchema(){return new Sequence({value:Array.from(this.keyPurposes,e=>new ObjectIdentifier({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}ExtKeyUsage.CLASS_NAME="ExtKeyUsage";const zt="accessDescriptions";class InfoAccess extends PkiObject{constructor(e={}){super(),this.accessDescriptions=getParametersValue(e,zt,InfoAccess.defaultValues(zt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===zt?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.accessDescriptions||ke,value:AccessDescription.schema()})]})}fromSchema(e){clearProps(e,[zt]);const t=compareSchema(e,e,InfoAccess.schema({names:{accessDescriptions:zt}}));AsnError.assertSchema(t,this.className),this.accessDescriptions=Array.from(t.result.accessDescriptions,e=>new AccessDescription({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}}InfoAccess.CLASS_NAME="InfoAccess";const Qt="distributionPoint",Zt="distributionPointNames",Yt="onlyContainsUserCerts",Xt="onlyContainsCACerts",er="onlySomeReasons",tr="indirectCRL",rr="onlyContainsAttributeCerts",sr=[Qt,Zt,Yt,Xt,er,tr,rr];class IssuingDistributionPoint extends PkiObject{constructor(e={}){super(),Qt in e&&(this.distributionPoint=getParametersValue(e,Qt,IssuingDistributionPoint.defaultValues(Qt))),this.onlyContainsUserCerts=getParametersValue(e,Yt,IssuingDistributionPoint.defaultValues(Yt)),this.onlyContainsCACerts=getParametersValue(e,Xt,IssuingDistributionPoint.defaultValues(Xt)),er in e&&(this.onlySomeReasons=getParametersValue(e,er,IssuingDistributionPoint.defaultValues(er))),this.indirectCRL=getParametersValue(e,tr,IssuingDistributionPoint.defaultValues(tr)),this.onlyContainsAttributeCerts=getParametersValue(e,rr,IssuingDistributionPoint.defaultValues(rr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Qt:return[];case Yt:case Xt:return!1;case er:return 0;case tr:case rr:return!1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Choice({value:[new Constructed({name:t.distributionPoint||ke,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({name:t.distributionPointNames||ke,value:GeneralName.schema()})]}),new Constructed({name:t.distributionPoint||ke,idBlock:{tagClass:3,tagNumber:1},value:RelativeDistinguishedNames.schema().valueBlock.value})]})]}),new Primitive({name:t.onlyContainsUserCerts||ke,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new Primitive({name:t.onlyContainsCACerts||ke,optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new Primitive({name:t.onlySomeReasons||ke,optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new Primitive({name:t.indirectCRL||ke,optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new Primitive({name:t.onlyContainsAttributeCerts||ke,optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){clearProps(e,sr);const t=compareSchema(e,e,IssuingDistributionPoint.schema({names:{distributionPoint:Qt,distributionPointNames:Zt,onlyContainsUserCerts:Yt,onlyContainsCACerts:Xt,onlySomeReasons:er,indirectCRL:tr,onlyContainsAttributeCerts:rr}}));if(AsnError.assertSchema(t,this.className),Qt in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new GeneralName({schema:e}));break;case 1===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=new RelativeDistinguishedNames({schema:new Sequence({value:t.result.distributionPoint.valueBlock.value})});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if(Yt in t.result){const e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if(Xt in t.result){const e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if(er in t.result){const e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if(tr in t.result){const e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if(rr in t.result){const e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){const e=[];if(this.distributionPoint){let t;this.distributionPoint instanceof Array?t=new Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):(t=this.distributionPoint.toSchema(),t.idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(this.onlyContainsUserCerts!==IssuingDistributionPoint.defaultValues(Yt)&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==IssuingDistributionPoint.defaultValues(Xt)&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),void 0!==this.onlySomeReasons){const t=new ArrayBuffer(1);new Uint8Array(t)[0]=this.onlySomeReasons,e.push(new Primitive({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==IssuingDistributionPoint.defaultValues(tr)&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==IssuingDistributionPoint.defaultValues(rr)&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new Sequence({value:e})}toJSON(){const e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==IssuingDistributionPoint.defaultValues(Yt)&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==IssuingDistributionPoint.defaultValues(Xt)&&(e.onlyContainsCACerts=this.onlyContainsCACerts),er in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==IssuingDistributionPoint.defaultValues(tr)&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==IssuingDistributionPoint.defaultValues(rr)&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}IssuingDistributionPoint.CLASS_NAME="IssuingDistributionPoint";const ar="base",ir="minimum",nr="maximum",or=[ar,ir,nr];class GeneralSubtree extends PkiObject{constructor(e={}){super(),this.base=getParametersValue(e,ar,GeneralSubtree.defaultValues(ar)),this.minimum=getParametersValue(e,ir,GeneralSubtree.defaultValues(ir)),nr in e&&(this.maximum=getParametersValue(e,nr,GeneralSubtree.defaultValues(nr))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ar:return new GeneralName;case ir:case nr:return 0;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[GeneralName.schema(t.base||{}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Integer({name:t.minimum||ke})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Integer({name:t.maximum||ke})]})]})}fromSchema(e){clearProps(e,or);const t=compareSchema(e,e,GeneralSubtree.schema({names:{base:{names:{blockName:ar}},minimum:ir,maximum:nr}}));AsnError.assertSchema(t,this.className),this.base=new GeneralName({schema:t.result.base}),ir in t.result&&(t.result.minimum.valueBlock.isHexOnly?this.minimum=t.result.minimum:this.minimum=t.result.minimum.valueBlock.valueDec),nr in t.result&&(t.result.maximum.valueBlock.isHexOnly?this.maximum=t.result.maximum:this.maximum=t.result.maximum.valueBlock.valueDec)}toSchema(){const e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof Integer?this.minimum:new Integer({value:this.minimum}),e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(nr in this){let t=0;t=this.maximum instanceof Integer?this.maximum:new Integer({value:this.maximum}),e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new Sequence({value:e})}toJSON(){const e={base:this.base.toJSON()};return 0!==this.minimum&&("number"==typeof this.minimum?e.minimum=this.minimum:e.minimum=this.minimum.toJSON()),void 0!==this.maximum&&("number"==typeof this.maximum?e.maximum=this.maximum:e.maximum=this.maximum.toJSON()),e}}GeneralSubtree.CLASS_NAME="GeneralSubtree";const lr="permittedSubtrees",cr="excludedSubtrees",ur=[lr,cr];class NameConstraints extends PkiObject{constructor(e={}){super(),lr in e&&(this.permittedSubtrees=getParametersValue(e,lr,NameConstraints.defaultValues(lr))),cr in e&&(this.excludedSubtrees=getParametersValue(e,cr,NameConstraints.defaultValues(cr))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case lr:case cr:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({name:t.permittedSubtrees||ke,value:GeneralSubtree.schema()})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Repeated({name:t.excludedSubtrees||ke,value:GeneralSubtree.schema()})]})]})}fromSchema(e){clearProps(e,ur);const t=compareSchema(e,e,NameConstraints.schema({names:{permittedSubtrees:lr,excludedSubtrees:cr}}));AsnError.assertSchema(t,this.className),lr in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,e=>new GeneralSubtree({schema:e}))),cr in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,e=>new GeneralSubtree({schema:e})))}toSchema(){const e=[];return this.permittedSubtrees&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.permittedSubtrees,e=>e.toSchema())})),this.excludedSubtrees&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.excludedSubtrees,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={};return this.permittedSubtrees&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,e=>e.toJSON())),this.excludedSubtrees&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,e=>e.toJSON())),e}}NameConstraints.CLASS_NAME="NameConstraints";const hr="requireExplicitPolicy",mr="inhibitPolicyMapping",fr=[hr,mr];class PolicyConstraints extends PkiObject{constructor(e={}){super(),hr in e&&(this.requireExplicitPolicy=getParametersValue(e,hr,PolicyConstraints.defaultValues(hr))),mr in e&&(this.inhibitPolicyMapping=getParametersValue(e,mr,PolicyConstraints.defaultValues(mr))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case hr:case mr:return 0;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Primitive({name:t.requireExplicitPolicy||ke,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new Primitive({name:t.inhibitPolicyMapping||ke,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){clearProps(e,fr);const t=compareSchema(e,e,PolicyConstraints.schema({names:{requireExplicitPolicy:hr,inhibitPolicyMapping:mr}}));if(AsnError.assertSchema(t,this.className),hr in t.result){const e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=fromBER(e.toBER(!1));AsnError.assert(r,"Integer"),this.requireExplicitPolicy=r.result.valueBlock.valueDec}if(mr in t.result){const e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=fromBER(e.toBER(!1));AsnError.assert(r,"Integer"),this.inhibitPolicyMapping=r.result.valueBlock.valueDec}}toSchema(){const e=[];if(hr in this){const t=new Integer({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if(mr in this){const t=new Integer({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new Sequence({value:e})}toJSON(){const e={};return hr in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),mr in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}PolicyConstraints.CLASS_NAME="PolicyConstraints";const gr="issuerDomainPolicy",dr="subjectDomainPolicy",pr=[gr,dr];class PolicyMapping extends PkiObject{constructor(e={}){super(),this.issuerDomainPolicy=getParametersValue(e,gr,PolicyMapping.defaultValues(gr)),this.subjectDomainPolicy=getParametersValue(e,dr,PolicyMapping.defaultValues(dr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case gr:case dr:return ke;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.issuerDomainPolicy||ke}),new ObjectIdentifier({name:t.subjectDomainPolicy||ke})]})}fromSchema(e){clearProps(e,pr);const t=compareSchema(e,e,PolicyMapping.schema({names:{issuerDomainPolicy:gr,subjectDomainPolicy:dr}}));AsnError.assertSchema(t,this.className),this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.issuerDomainPolicy}),new ObjectIdentifier({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}PolicyMapping.CLASS_NAME="PolicyMapping";const Sr="mappings",yr=[Sr];class PolicyMappings extends PkiObject{constructor(e={}){super(),this.mappings=getParametersValue(e,Sr,PolicyMappings.defaultValues(Sr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Sr?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.mappings||ke,value:PolicyMapping.schema()})]})}fromSchema(e){clearProps(e,yr);const t=compareSchema(e,e,PolicyMappings.schema({names:{mappings:Sr}}));AsnError.assertSchema(t,this.className),this.mappings=Array.from(t.result.mappings,e=>new PolicyMapping({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}}PolicyMappings.CLASS_NAME="PolicyMappings";const wr="notBefore",vr="notAfter",br=[wr,vr];class PrivateKeyUsagePeriod extends PkiObject{constructor(e={}){super(),wr in e&&(this.notBefore=getParametersValue(e,wr,PrivateKeyUsagePeriod.defaultValues(wr))),vr in e&&(this.notAfter=getParametersValue(e,vr,PrivateKeyUsagePeriod.defaultValues(vr))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case wr:case vr:return new Date;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Primitive({name:t.notBefore||ke,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new Primitive({name:t.notAfter||ke,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){clearProps(e,br);const t=compareSchema(e,e,PrivateKeyUsagePeriod.schema({names:{notBefore:wr,notAfter:vr}}));if(AsnError.assertSchema(t,this.className),wr in t.result){const e=new GeneralizedTime;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if(vr in t.result){const e=new GeneralizedTime({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){const e=[];return wr in this&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:new GeneralizedTime({valueDate:this.notBefore}).valueBlock.valueHexView})),vr in this&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:new GeneralizedTime({valueDate:this.notAfter}).valueBlock.valueHexView})),new Sequence({value:e})}toJSON(){const e={};return this.notBefore&&(e.notBefore=this.notBefore),this.notAfter&&(e.notAfter=this.notAfter),e}}PrivateKeyUsagePeriod.CLASS_NAME="PrivateKeyUsagePeriod";const Ar="id",kr="type",Cr="values",Vr=[Ar,kr],Br=[Cr];class QCStatement extends PkiObject{constructor(e={}){super(),this.id=getParametersValue(e,Ar,QCStatement.defaultValues(Ar)),kr in e&&(this.type=getParametersValue(e,kr,QCStatement.defaultValues(kr))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ar:return ke;case kr:return new Null;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ar:return t===ke;case kr:return t instanceof Null;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.id||ke}),new Any({name:t.type||ke,optional:!0})]})}fromSchema(e){clearProps(e,Vr);const t=compareSchema(e,e,QCStatement.schema({names:{id:Ar,type:kr}}));AsnError.assertSchema(t,this.className),this.id=t.result.id.valueBlock.toString(),kr in t.result&&(this.type=t.result.type)}toSchema(){const e=[new ObjectIdentifier({value:this.id})];return kr in this&&e.push(this.type),new Sequence({value:e})}toJSON(){const e={id:this.id};return this.type&&(e.type=this.type.toJSON()),e}}QCStatement.CLASS_NAME="QCStatement";class QCStatements extends PkiObject{constructor(e={}){super(),this.values=getParametersValue(e,Cr,QCStatements.defaultValues(Cr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Cr?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===Cr?0===t.length:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.values||ke,value:QCStatement.schema(t.value||{})})]})}fromSchema(e){clearProps(e,Br);const t=compareSchema(e,e,QCStatements.schema({names:{values:Cr}}));AsnError.assertSchema(t,this.className),this.values=Array.from(t.result.values,e=>new QCStatement({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.values,e=>e.toSchema())})}toJSON(){return{values:Array.from(this.values,e=>e.toJSON())}}}var Ir;QCStatements.CLASS_NAME="QCStatements";class ECNamedCurves{static register(e,t,r){this.namedCurves[e.toLowerCase()]=this.namedCurves[t]={name:e,id:t,size:r}}static find(e){return this.namedCurves[e.toLowerCase()]||null}}Ir=ECNamedCurves,ECNamedCurves.namedCurves={},Ir.register("P-256","1.2.840.10045.3.1.7",32),Ir.register("P-384","1.3.132.0.34",48),Ir.register("P-521","1.3.132.0.35",66),Ir.register("brainpoolP256r1","1.3.36.3.3.2.8.1.1.7",32),Ir.register("brainpoolP384r1","1.3.36.3.3.2.8.1.1.11",48),Ir.register("brainpoolP512r1","1.3.36.3.3.2.8.1.1.13",64);const Nr="x",Pr="y",Er="namedCurve";class ECPublicKey extends PkiObject{constructor(e={}){super(),this.x=getParametersValue(e,Nr,ECPublicKey.defaultValues(Nr)),this.y=getParametersValue(e,Pr,ECPublicKey.defaultValues(Pr)),this.namedCurve=getParametersValue(e,Er,ECPublicKey.defaultValues(Er)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Nr:case Pr:return Ae;case Er:return ke;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Nr:case Pr:return t instanceof ArrayBuffer&&isEqualBuffer(t,ECPublicKey.defaultValues(e));case Er:return"string"==typeof t&&t===ECPublicKey.defaultValues(e);default:return super.defaultValues(e)}}static schema(){return new RawData}fromSchema(e){const t=BufferSourceConverter.toUint8Array(e);if(4!==t[0])throw new Error("Object's schema was not verified against input data for ECPublicKey");const r=ECNamedCurves.find(this.namedCurve);if(!r)throw new Error(`Incorrect curve OID: ${this.namedCurve}`);const s=r.size;if(t.byteLength!==2*s+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.namedCurve=r.name,this.x=t.slice(1,s+1).buffer,this.y=t.slice(1+s,2*s+1).buffer}toSchema(){return new RawData({data:utilConcatBuf(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){const e=ECNamedCurves.find(this.namedCurve);return{crv:e?e.name:this.namedCurve,x:toBase64(arrayBufferToString(this.x),!0,!0,!1),y:toBase64(arrayBufferToString(this.y),!0,!0,!1)}}fromJSON(e){ParameterError.assert("json",e,"crv","x","y");let t=0;const r=ECNamedCurves.find(e.crv);r&&(this.namedCurve=r.id,t=r.size);const s=stringToArrayBuffer(fromBase64(e.x,!0));if(s.byteLength<t){this.x=new ArrayBuffer(t);const e=new Uint8Array(this.x),r=new Uint8Array(s);e.set(r,1)}else this.x=s.slice(0,t);const a=stringToArrayBuffer(fromBase64(e.y,!0));if(a.byteLength<t){this.y=new ArrayBuffer(t);const e=new Uint8Array(this.y),r=new Uint8Array(a);e.set(r,1)}else this.y=a.slice(0,t)}}ECPublicKey.CLASS_NAME="ECPublicKey";const Dr="modulus",Or="publicExponent",xr=[Dr,Or];class RSAPublicKey extends PkiObject{constructor(e={}){super(),this.modulus=getParametersValue(e,Dr,RSAPublicKey.defaultValues(Dr)),this.publicExponent=getParametersValue(e,Or,RSAPublicKey.defaultValues(Or)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Dr:case Or:return new Integer;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.modulus||ke}),new Integer({name:t.publicExponent||ke})]})}fromSchema(e){clearProps(e,xr);const t=compareSchema(e,e,RSAPublicKey.schema({names:{modulus:Dr,publicExponent:Or}}));AsnError.assertSchema(t,this.className),this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new Sequence({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),e:Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView)}}fromJSON(e){ParameterError.assert("json",e,"n","e");const t=stringToArrayBuffer(fromBase64(e.n,!0));this.modulus=new Integer({valueHex:t.slice(0,Math.pow(2,nearestPowerOf2(t.byteLength)))}),this.publicExponent=new Integer({valueHex:stringToArrayBuffer(fromBase64(e.e,!0)).slice(0,3)})}}RSAPublicKey.CLASS_NAME="RSAPublicKey";const Rr="algorithm",Kr="subjectPublicKey",Ur=[Rr,Kr];class PublicKeyInfo extends PkiObject{get parsedKey(){if(void 0===this._parsedKey){switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams.constructor.blockName()===ObjectIdentifier.blockName())try{this._parsedKey=new ECPublicKey({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHexView})}catch(e){}break;case"1.2.840.113549.1.1.1":{const e=fromBER(this.subjectPublicKey.valueBlock.valueHexView);if(-1!==e.offset)try{this._parsedKey=new RSAPublicKey({schema:e.result})}catch(e){}}}this._parsedKey||(this._parsedKey=null)}return this._parsedKey||void 0}set parsedKey(e){this._parsedKey=e}constructor(e={}){super(),this.algorithm=getParametersValue(e,Rr,PublicKeyInfo.defaultValues(Rr)),this.subjectPublicKey=getParametersValue(e,Kr,PublicKeyInfo.defaultValues(Kr));const t=getParametersValue(e,"parsedKey",null);t&&(this.parsedKey=t),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Rr:return new AlgorithmIdentifier;case Kr:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[AlgorithmIdentifier.schema(t.algorithm||{}),new BitString({name:t.subjectPublicKey||ke})]})}fromSchema(e){clearProps(e,Ur);const t=compareSchema(e,e,PublicKeyInfo.schema({names:{algorithm:{names:{blockName:Rr}},subjectPublicKey:Kr}}));AsnError.assertSchema(t,this.className),this.algorithm=new AlgorithmIdentifier({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey}toSchema(){return new Sequence({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if(!this.parsedKey)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};const e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new ECPublicKey({json:e}),this.algorithm=new AlgorithmIdentifier({algorithmId:"1.2.840.10045.2.1",algorithmParams:new ObjectIdentifier({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new RSAPublicKey({json:e}),this.algorithm=new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new Null});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.subjectPublicKey=new BitString({valueHex:this.parsedKey.toSchema().toBER(!1)})}}async importKey(e,t=getCrypto(!0)){try{if(!e)throw new Error("Need to provide publicKey input parameter");const r=fromBER(await t.exportKey("spki",e));try{this.fromSchema(r.result)}catch(e){throw new Error("Error during initializing object from schema")}}catch(e){const t=e instanceof Error?e.message:`${e}`;throw new Error(`Error during exporting public key: ${t}`)}}}PublicKeyInfo.CLASS_NAME="PublicKeyInfo";const Tr="version",Lr="privateKey",Hr="namedCurve",qr="publicKey",jr=[Tr,Lr,Hr,qr];class ECPrivateKey extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Tr,ECPrivateKey.defaultValues(Tr)),this.privateKey=getParametersValue(e,Lr,ECPrivateKey.defaultValues(Lr)),Hr in e&&(this.namedCurve=getParametersValue(e,Hr,ECPrivateKey.defaultValues(Hr))),qr in e&&(this.publicKey=getParametersValue(e,qr,ECPrivateKey.defaultValues(qr))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Tr:return 1;case Lr:return new OctetString;case Hr:return ke;case qr:return new ECPublicKey;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Tr:return t===ECPrivateKey.defaultValues(e);case Lr:return t.isEqual(ECPrivateKey.defaultValues(e));case Hr:return t===ke;case qr:return ECPublicKey.compareWithDefault(Hr,t.namedCurve)&&ECPublicKey.compareWithDefault("x",t.x)&&ECPublicKey.compareWithDefault("y",t.y);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||ke}),new OctetString({name:t.privateKey||ke}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ObjectIdentifier({name:t.namedCurve||ke})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new BitString({name:t.publicKey||ke})]})]})}fromSchema(e){clearProps(e,jr);const t=compareSchema(e,e,ECPrivateKey.schema({names:{version:Tr,privateKey:Lr,namedCurve:Hr,publicKey:qr}}));if(AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,Hr in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),qr in t.result){const e={schema:t.result.publicKey.valueBlock.valueHex};Hr in this&&(e.namedCurve=this.namedCurve),this.publicKey=new ECPublicKey(e)}}toSchema(){const e=[new Integer({value:this.version}),this.privateKey];return this.namedCurve&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new ObjectIdentifier({value:this.namedCurve})]})),this.publicKey&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new BitString({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new Sequence({value:e})}toJSON(){if(!this.namedCurve||ECPrivateKey.compareWithDefault(Hr,this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');const e=ECNamedCurves.find(this.namedCurve),t={crv:e?e.name:this.namedCurve,d:Convert.ToBase64Url(this.privateKey.valueBlock.valueHexView)};if(this.publicKey){const e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){ParameterError.assert("json",e,"crv","d");let t=0;const r=ECNamedCurves.find(e.crv);r&&(this.namedCurve=r.id,t=r.size);const s=Convert.FromBase64Url(e.d);if(s.byteLength<t){const e=new ArrayBuffer(t),r=new Uint8Array(e),a=new Uint8Array(s);r.set(a,1),this.privateKey=new OctetString({valueHex:e})}else this.privateKey=new OctetString({valueHex:s.slice(0,t)});e.x&&e.y&&(this.publicKey=new ECPublicKey({json:e}))}}ECPrivateKey.CLASS_NAME="ECPrivateKey";const Mr="prime",Jr="exponent",_r="coefficient",Fr=[Mr,Jr,_r];class OtherPrimeInfo extends PkiObject{constructor(e={}){super(),this.prime=getParametersValue(e,Mr,OtherPrimeInfo.defaultValues(Mr)),this.exponent=getParametersValue(e,Jr,OtherPrimeInfo.defaultValues(Jr)),this.coefficient=getParametersValue(e,_r,OtherPrimeInfo.defaultValues(_r)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Mr:case Jr:case _r:return new Integer;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.prime||ke}),new Integer({name:t.exponent||ke}),new Integer({name:t.coefficient||ke})]})}fromSchema(e){clearProps(e,Fr);const t=compareSchema(e,e,OtherPrimeInfo.schema({names:{prime:Mr,exponent:Jr,coefficient:_r}}));AsnError.assertSchema(t,this.className),this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new Sequence({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:Convert.ToBase64Url(this.prime.valueBlock.valueHexView),d:Convert.ToBase64Url(this.exponent.valueBlock.valueHexView),t:Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)}}fromJSON(e){ParameterError.assert("json",e,"r","d","r"),this.prime=new Integer({valueHex:Convert.FromBase64Url(e.r)}),this.exponent=new Integer({valueHex:Convert.FromBase64Url(e.d)}),this.coefficient=new Integer({valueHex:Convert.FromBase64Url(e.t)})}}OtherPrimeInfo.CLASS_NAME="OtherPrimeInfo";const $r="version",Wr="modulus",Gr="publicExponent",zr="privateExponent",Qr="prime1",Zr="prime2",Yr="exponent1",Xr="exponent2",es="coefficient",ts="otherPrimeInfos",rs=[$r,Wr,Gr,zr,Qr,Zr,Yr,Xr,es,ts];class RSAPrivateKey extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,$r,RSAPrivateKey.defaultValues($r)),this.modulus=getParametersValue(e,Wr,RSAPrivateKey.defaultValues(Wr)),this.publicExponent=getParametersValue(e,Gr,RSAPrivateKey.defaultValues(Gr)),this.privateExponent=getParametersValue(e,zr,RSAPrivateKey.defaultValues(zr)),this.prime1=getParametersValue(e,Qr,RSAPrivateKey.defaultValues(Qr)),this.prime2=getParametersValue(e,Zr,RSAPrivateKey.defaultValues(Zr)),this.exponent1=getParametersValue(e,Yr,RSAPrivateKey.defaultValues(Yr)),this.exponent2=getParametersValue(e,Xr,RSAPrivateKey.defaultValues(Xr)),this.coefficient=getParametersValue(e,es,RSAPrivateKey.defaultValues(es)),ts in e&&(this.otherPrimeInfos=getParametersValue(e,ts,RSAPrivateKey.defaultValues(ts))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case $r:return 0;case Wr:case Gr:case zr:case Qr:case Zr:case Yr:case Xr:case es:return new Integer;case ts:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||ke}),new Integer({name:t.modulus||ke}),new Integer({name:t.publicExponent||ke}),new Integer({name:t.privateExponent||ke}),new Integer({name:t.prime1||ke}),new Integer({name:t.prime2||ke}),new Integer({name:t.exponent1||ke}),new Integer({name:t.exponent2||ke}),new Integer({name:t.coefficient||ke}),new Sequence({optional:!0,value:[new Repeated({name:t.otherPrimeInfosName||ke,value:OtherPrimeInfo.schema(t.otherPrimeInfo||{})})]})]})}fromSchema(e){clearProps(e,rs);const t=compareSchema(e,e,RSAPrivateKey.schema({names:{version:$r,modulus:Wr,publicExponent:Gr,privateExponent:zr,prime1:Qr,prime2:Zr,exponent1:Yr,exponent2:Xr,coefficient:es,otherPrimeInfo:{names:{blockName:ts}}}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),ts in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,e=>new OtherPrimeInfo({schema:e})))}toSchema(){const e=[];return e.push(new Integer({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),this.otherPrimeInfos&&e.push(new Sequence({value:Array.from(this.otherPrimeInfos,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={n:Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),e:Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView),d:Convert.ToBase64Url(this.privateExponent.valueBlock.valueHexView),p:Convert.ToBase64Url(this.prime1.valueBlock.valueHexView),q:Convert.ToBase64Url(this.prime2.valueBlock.valueHexView),dp:Convert.ToBase64Url(this.exponent1.valueBlock.valueHexView),dq:Convert.ToBase64Url(this.exponent2.valueBlock.valueHexView),qi:Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)};return this.otherPrimeInfos&&(e.oth=Array.from(this.otherPrimeInfos,e=>e.toJSON())),e}fromJSON(e){ParameterError.assert("json",e,"n","e","d","p","q","dp","dq","qi"),this.modulus=new Integer({valueHex:Convert.FromBase64Url(e.n)}),this.publicExponent=new Integer({valueHex:Convert.FromBase64Url(e.e)}),this.privateExponent=new Integer({valueHex:Convert.FromBase64Url(e.d)}),this.prime1=new Integer({valueHex:Convert.FromBase64Url(e.p)}),this.prime2=new Integer({valueHex:Convert.FromBase64Url(e.q)}),this.exponent1=new Integer({valueHex:Convert.FromBase64Url(e.dp)}),this.exponent2=new Integer({valueHex:Convert.FromBase64Url(e.dq)}),this.coefficient=new Integer({valueHex:Convert.FromBase64Url(e.qi)}),e.oth&&(this.otherPrimeInfos=Array.from(e.oth,e=>new OtherPrimeInfo({json:e})))}}RSAPrivateKey.CLASS_NAME="RSAPrivateKey";const ss="version",as="privateKeyAlgorithm",is="privateKey",ns="attributes",os="parsedKey",ls=[ss,as,is,ns];class PrivateKeyInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,ss,PrivateKeyInfo.defaultValues(ss)),this.privateKeyAlgorithm=getParametersValue(e,as,PrivateKeyInfo.defaultValues(as)),this.privateKey=getParametersValue(e,is,PrivateKeyInfo.defaultValues(is)),ns in e&&(this.attributes=getParametersValue(e,ns,PrivateKeyInfo.defaultValues(ns))),os in e&&(this.parsedKey=getParametersValue(e,os,PrivateKeyInfo.defaultValues(os))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ss:return 0;case as:return new AlgorithmIdentifier;case is:return new OctetString;case ns:return[];case os:return{};default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||ke}),AlgorithmIdentifier.schema(t.privateKeyAlgorithm||{}),new OctetString({name:t.privateKey||ke}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({name:t.attributes||ke,value:Attribute.schema()})]})]})}fromSchema(e){clearProps(e,ls);const t=compareSchema(e,e,PrivateKeyInfo.schema({names:{version:ss,privateKeyAlgorithm:{names:{blockName:as}},privateKey:is,attributes:ns}}));switch(AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new AlgorithmIdentifier({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,ns in t.result&&(this.attributes=Array.from(t.result.attributes,e=>new Attribute({schema:e}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{const e=fromBER(this.privateKey.valueBlock.valueHexView);-1!==e.offset&&(this.parsedKey=new RSAPrivateKey({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof ObjectIdentifier){const e=fromBER(this.privateKey.valueBlock.valueHexView);-1!==e.offset&&(this.parsedKey=new ECPrivateKey({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){const e=[new Integer({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return this.attributes&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){if(!this.parsedKey){const e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return this.attributes&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}const e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new ECPrivateKey({json:e}),this.privateKeyAlgorithm=new AlgorithmIdentifier({algorithmId:"1.2.840.10045.2.1",algorithmParams:new ObjectIdentifier({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new RSAPrivateKey({json:e}),this.privateKeyAlgorithm=new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new Null});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.privateKey=new OctetString({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}PrivateKeyInfo.CLASS_NAME="PrivateKeyInfo";const cs="contentType",us="contentEncryptionAlgorithm",hs="encryptedContent",ms=[cs,us,hs];class EncryptedContentInfo extends PkiObject{constructor(e={}){if(super(),this.contentType=getParametersValue(e,cs,EncryptedContentInfo.defaultValues(cs)),this.contentEncryptionAlgorithm=getParametersValue(e,us,EncryptedContentInfo.defaultValues(us)),hs in e&&e.encryptedContent&&(this.encryptedContent=e.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed&&!e.disableSplit)){const e=new OctetString({idBlock:{isConstructed:!0},isConstructed:!0});let t=0;const r=this.encryptedContent.valueBlock.valueHexView.slice().buffer;let s=r.byteLength;for(;s>0;){const a=new Uint8Array(r,t,t+1024>r.byteLength?r.byteLength-t:1024),i=new ArrayBuffer(a.length),n=new Uint8Array(i);for(let e=0;e<n.length;e++)n[e]=a[e];e.valueBlock.value.push(new OctetString({valueHex:i})),s-=a.length,t+=a.length}this.encryptedContent=e}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case cs:return ke;case us:return new AlgorithmIdentifier;case hs:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case cs:return t===ke;case us:return t.algorithmId===ke&&"algorithmParams"in t==!1;case hs:return t.isEqual(EncryptedContentInfo.defaultValues(hs));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.contentType||ke}),AlgorithmIdentifier.schema(t.contentEncryptionAlgorithm||{}),new Choice({value:[new Constructed({name:t.encryptedContent||ke,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({value:new OctetString})]}),new Primitive({name:t.encryptedContent||ke,idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){clearProps(e,ms);const t=compareSchema(e,e,EncryptedContentInfo.schema({names:{contentType:cs,contentEncryptionAlgorithm:{names:{blockName:us}},encryptedContent:hs}}));AsnError.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.contentEncryptionAlgorithm}),hs in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){const e={isIndefiniteForm:!1},t=[];if(t.push(new ObjectIdentifier({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),this.encryptedContent){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;const r=this.encryptedContent;r.idBlock.tagClass=3,r.idBlock.tagNumber=0,r.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(r)}return new Sequence({lenBlock:e,value:t})}toJSON(){const e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return this.encryptedContent&&(e.encryptedContent=this.encryptedContent.toJSON()),e}getEncryptedContent(){if(!this.encryptedContent)throw new Error("Parameter 'encryptedContent' is undefined");return OctetString.prototype.getValue.call(this.encryptedContent)}}EncryptedContentInfo.CLASS_NAME="EncryptedContentInfo";const fs="hashAlgorithm",gs="maskGenAlgorithm",ds="saltLength",ps="trailerField",Ss=[fs,gs,ds,ps];class RSASSAPSSParams extends PkiObject{constructor(e={}){super(),this.hashAlgorithm=getParametersValue(e,fs,RSASSAPSSParams.defaultValues(fs)),this.maskGenAlgorithm=getParametersValue(e,gs,RSASSAPSSParams.defaultValues(gs)),this.saltLength=getParametersValue(e,ds,RSASSAPSSParams.defaultValues(ds)),this.trailerField=getParametersValue(e,ps,RSASSAPSSParams.defaultValues(ps)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case fs:return new AlgorithmIdentifier({algorithmId:"1.3.14.3.2.26",algorithmParams:new Null});case gs:return new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new AlgorithmIdentifier({algorithmId:"1.3.14.3.2.26",algorithmParams:new Null}).toSchema()});case ds:return 20;case ps:return 1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Constructed({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[AlgorithmIdentifier.schema(t.hashAlgorithm||{})]}),new Constructed({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[AlgorithmIdentifier.schema(t.maskGenAlgorithm||{})]}),new Constructed({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new Integer({name:t.saltLength||ke})]}),new Constructed({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new Integer({name:t.trailerField||ke})]})]})}fromSchema(e){clearProps(e,Ss);const t=compareSchema(e,e,RSASSAPSSParams.schema({names:{hashAlgorithm:{names:{blockName:fs}},maskGenAlgorithm:{names:{blockName:gs}},saltLength:ds,trailerField:ps}}));AsnError.assertSchema(t,this.className),fs in t.result&&(this.hashAlgorithm=new AlgorithmIdentifier({schema:t.result.hashAlgorithm})),gs in t.result&&(this.maskGenAlgorithm=new AlgorithmIdentifier({schema:t.result.maskGenAlgorithm})),ds in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),ps in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){const e=[];return this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(fs))||e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(gs))||e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==RSASSAPSSParams.defaultValues(ds)&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:[new Integer({value:this.saltLength})]})),this.trailerField!==RSASSAPSSParams.defaultValues(ps)&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:3},value:[new Integer({value:this.trailerField})]})),new Sequence({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(fs))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(gs))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==RSASSAPSSParams.defaultValues(ds)&&(e.saltLength=this.saltLength),this.trailerField!==RSASSAPSSParams.defaultValues(ps)&&(e.trailerField=this.trailerField),e}}RSASSAPSSParams.CLASS_NAME="RSASSAPSSParams";const ys="salt",ws="iterationCount",vs="keyLength",bs="prf",As=[ys,ws,vs,bs];class PBKDF2Params extends PkiObject{constructor(e={}){super(),this.salt=getParametersValue(e,ys,PBKDF2Params.defaultValues(ys)),this.iterationCount=getParametersValue(e,ws,PBKDF2Params.defaultValues(ws)),vs in e&&(this.keyLength=getParametersValue(e,vs,PBKDF2Params.defaultValues(vs))),bs in e&&(this.prf=getParametersValue(e,bs,PBKDF2Params.defaultValues(bs))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ys:return{};case ws:return-1;case vs:return 0;case bs:return new AlgorithmIdentifier({algorithmId:"1.3.14.3.2.26",algorithmParams:new Null});default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Choice({value:[new OctetString({name:t.saltPrimitive||ke}),AlgorithmIdentifier.schema(t.saltConstructed||{})]}),new Integer({name:t.iterationCount||ke}),new Integer({name:t.keyLength||ke,optional:!0}),AlgorithmIdentifier.schema(t.prf||{names:{optional:!0}})]})}fromSchema(e){clearProps(e,As);const t=compareSchema(e,e,PBKDF2Params.schema({names:{saltPrimitive:ys,saltConstructed:{names:{blockName:ys}},iterationCount:ws,keyLength:vs,prf:{names:{blockName:bs,optional:!0}}}}));AsnError.assertSchema(t,this.className),this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,vs in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),bs in t.result&&(this.prf=new AlgorithmIdentifier({schema:t.result.prf}))}toSchema(){const e=[];return e.push(this.salt),e.push(new Integer({value:this.iterationCount})),vs in this&&PBKDF2Params.defaultValues(vs)!==this.keyLength&&e.push(new Integer({value:this.keyLength})),this.prf&&!1===PBKDF2Params.defaultValues(bs).isEqual(this.prf)&&e.push(this.prf.toSchema()),new Sequence({value:e})}toJSON(){const e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return vs in this&&PBKDF2Params.defaultValues(vs)!==this.keyLength&&(e.keyLength=this.keyLength),this.prf&&!1===PBKDF2Params.defaultValues(bs).isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}PBKDF2Params.CLASS_NAME="PBKDF2Params";const ks="keyDerivationFunc",Cs="encryptionScheme",Vs=[ks,Cs];class PBES2Params extends PkiObject{constructor(e={}){super(),this.keyDerivationFunc=getParametersValue(e,ks,PBES2Params.defaultValues(ks)),this.encryptionScheme=getParametersValue(e,Cs,PBES2Params.defaultValues(Cs)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ks:case Cs:return new AlgorithmIdentifier;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[AlgorithmIdentifier.schema(t.keyDerivationFunc||{}),AlgorithmIdentifier.schema(t.encryptionScheme||{})]})}fromSchema(e){clearProps(e,Vs);const t=compareSchema(e,e,PBES2Params.schema({names:{keyDerivationFunc:{names:{blockName:ks}},encryptionScheme:{names:{blockName:Cs}}}}));AsnError.assertSchema(t,this.className),this.keyDerivationFunc=new AlgorithmIdentifier({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new AlgorithmIdentifier({schema:t.result.encryptionScheme})}toSchema(){return new Sequence({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}PBES2Params.CLASS_NAME="PBES2Params";class AbstractCryptoEngine{constructor(e){this.crypto=e.crypto,this.subtle="webkitSubtle"in e.crypto?e.crypto.webkitSubtle:e.crypto.subtle,this.name=getParametersValue(e,"name",ke)}async encrypt(...e){return this.subtle.encrypt(...e)}async decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}async verify(...e){return this.subtle.verify(...e)}async digest(...e){return this.subtle.digest(...e)}async generateKey(...e){return this.subtle.generateKey(...e)}async deriveKey(...e){return this.subtle.deriveKey(...e)}async deriveBits(...e){return this.subtle.deriveBits(...e)}async wrapKey(...e){return this.subtle.wrapKey(...e)}async unwrapKey(...e){return this.subtle.unwrapKey(...e)}exportKey(...e){return this.subtle.exportKey(...e)}importKey(...e){return this.subtle.importKey(...e)}getRandomValues(e){return this.crypto.getRandomValues(e)}}async function makePKCS12B2Key(e,t,r,s,a){let i,n,o;switch(e.toUpperCase()){case"SHA-1":i=20,n=64,o=ne;break;case"SHA-256":i=32,n=64,o=we;break;case"SHA-384":i=48,n=128,o=be;break;case"SHA-512":i=64,n=128,o=ve;break;default:throw new Error("Unsupported hashing algorithm")}const l=new Uint8Array(r);let c=(new TextDecoder).decode(r);(new TextEncoder).encode(c).some((e,t)=>e!==l[t])&&(c=String.fromCharCode(...l));const u=new Uint8Array(2*c.length+2),h=new DataView(u.buffer);for(let e=0;e<c.length;e++)h.setUint16(2*e,c.charCodeAt(e),!1);h.setUint16(2*c.length,0,!1);const m=new Uint8Array(n).fill(3),f=new Uint8Array(s),g=new Uint8Array(n*Math.ceil(f.length/n)).map((e,t)=>f[t%f.length]),d=new Uint8Array(n*Math.ceil(u.length/n)).map((e,t)=>u[t%u.length]);let p=new Uint8Array(g.length+d.length);p.set(g),p.set(d,g.length);const S=Math.ceil((t>>3)/i),y=[];for(let e=0;e<S;e++){let e=new Uint8Array(m.length+p.length);e.set(m),e.set(p,m.length);for(let t=0;t<a;t++)e=o(e);const t=new Uint8Array(n).map((t,r)=>e[r%e.length]),r=Math.ceil(f.length/n)+Math.ceil(u.length/n),s=[];for(let e=0;e<r;e++){const r=Array.from(p.slice(e*n,(e+1)*n));let a=511;for(let e=t.length-1;e>=0;e--)a>>=8,a+=t[e]+(r[e]||0),r[e]=255&a;s.push(...r)}p=new Uint8Array(s),y.push(...e)}return new Uint8Array(y.slice(0,t>>3)).buffer}function prepareAlgorithm(e){const t="string"==typeof e?{name:e}:e;return"hash"in t?{...t,hash:prepareAlgorithm(t.hash)}:t}class CryptoEngine extends AbstractCryptoEngine{async importKey(e,t,r,s,a){var i,n,o,l,c,u;let h={};const m=prepareAlgorithm(r);switch(e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,r,s,a);case"spki":{const e=fromBER(BufferSourceConverter.toArrayBuffer(t));AsnError.assert(e,"keyData");const r=new PublicKeyInfo;try{r.fromSchema(e.result)}catch{throw new ArgumentError("Incorrect keyData")}switch(m.name.toUpperCase()){case"RSA-PSS":if(!m.hash)throw new ParameterError("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(m.hash.name.toUpperCase()){case"SHA-1":h.alg="PS1";break;case"SHA-256":h.alg="PS256";break;case"SHA-384":h.alg="PS384";break;case"SHA-512":h.alg="PS512";break;default:throw new Error(`Incorrect hash algorithm: ${m.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(a=["verify"],h.kty="RSA",h.ext=s,h.key_ops=a,"1.2.840.113549.1.1.1"!==r.algorithm.algorithmId)throw new Error(`Incorrect public key algorithm: ${r.algorithm.algorithmId}`);if(!h.alg){if(!m.hash)throw new ParameterError("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(m.hash.name.toUpperCase()){case"SHA-1":h.alg="RS1";break;case"SHA-256":h.alg="RS256";break;case"SHA-384":h.alg="RS384";break;case"SHA-512":h.alg="RS512";break;default:throw new Error(`Incorrect hash algorithm: ${m.hash.name.toUpperCase()}`)}}const e=r.toJSON();Object.assign(h,e)}break;case"ECDSA":a=["verify"];case"ECDH":{if(h={kty:"EC",ext:s,key_ops:a},"1.2.840.10045.2.1"!==r.algorithm.algorithmId)throw new Error(`Incorrect public key algorithm: ${r.algorithm.algorithmId}`);const e=r.toJSON();Object.assign(h,e)}break;case"RSA-OAEP":{if(h.kty="RSA",h.ext=s,h.key_ops=a,"safari"===this.name.toLowerCase())h.alg="RSA-OAEP";else{if(!m.hash)throw new ParameterError("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(m.hash.name.toUpperCase()){case"SHA-1":h.alg="RSA-OAEP";break;case"SHA-256":h.alg="RSA-OAEP-256";break;case"SHA-384":h.alg="RSA-OAEP-384";break;case"SHA-512":h.alg="RSA-OAEP-512";break;default:throw new Error(`Incorrect hash algorithm: ${m.hash.name.toUpperCase()}`)}}const e=r.toJSON();Object.assign(h,e)}break;case"RSAES-PKCS1-V1_5":{h.kty="RSA",h.ext=s,h.key_ops=a,h.alg="PS1";const e=r.toJSON();Object.assign(h,e)}break;default:throw new Error(`Incorrect algorithm name: ${m.name.toUpperCase()}`)}}break;case"pkcs8":{const e=new PrivateKeyInfo,r=fromBER(BufferSourceConverter.toArrayBuffer(t));AsnError.assert(r,"keyData");try{e.fromSchema(r.result)}catch(e){throw new Error("Incorrect keyData")}if(!e.parsedKey)throw new Error("Incorrect keyData");switch(m.name.toUpperCase()){case"RSA-PSS":switch(null===(i=m.hash)||void 0===i?void 0:i.name.toUpperCase()){case"SHA-1":h.alg="PS1";break;case"SHA-256":h.alg="PS256";break;case"SHA-384":h.alg="PS384";break;case"SHA-512":h.alg="PS512";break;default:throw new Error(`Incorrect hash algorithm: ${null===(n=m.hash)||void 0===n?void 0:n.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(a=["sign"],h.kty="RSA",h.ext=s,h.key_ops=a,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)throw new Error(`Incorrect private key algorithm: ${e.privateKeyAlgorithm.algorithmId}`);if("alg"in h==!1)switch(null===(o=m.hash)||void 0===o?void 0:o.name.toUpperCase()){case"SHA-1":h.alg="RS1";break;case"SHA-256":h.alg="RS256";break;case"SHA-384":h.alg="RS384";break;case"SHA-512":h.alg="RS512";break;default:throw new Error(`Incorrect hash algorithm: ${null===(l=m.hash)||void 0===l?void 0:l.name.toUpperCase()}`)}const t=e.toJSON();Object.assign(h,t)}break;case"ECDSA":a=["sign"];case"ECDH":{if(h={kty:"EC",ext:s,key_ops:a},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)throw new Error(`Incorrect algorithm: ${e.privateKeyAlgorithm.algorithmId}`);const t=e.toJSON();Object.assign(h,t)}break;case"RSA-OAEP":{if(h.kty="RSA",h.ext=s,h.key_ops=a,"safari"===this.name.toLowerCase())h.alg="RSA-OAEP";else switch(null===(c=m.hash)||void 0===c?void 0:c.name.toUpperCase()){case"SHA-1":h.alg="RSA-OAEP";break;case"SHA-256":h.alg="RSA-OAEP-256";break;case"SHA-384":h.alg="RSA-OAEP-384";break;case"SHA-512":h.alg="RSA-OAEP-512";break;default:throw new Error(`Incorrect hash algorithm: ${null===(u=m.hash)||void 0===u?void 0:u.name.toUpperCase()}`)}const t=e.toJSON();Object.assign(h,t)}break;case"RSAES-PKCS1-V1_5":{a=["decrypt"],h.kty="RSA",h.ext=s,h.key_ops=a,h.alg="PS1";const t=e.toJSON();Object.assign(h,t)}break;default:throw new Error(`Incorrect algorithm name: ${m.name.toUpperCase()}`)}}break;case"jwk":h=t;break;default:throw new Error(`Incorrect format: ${e}`)}if("safari"===this.name.toLowerCase())try{return this.subtle.importKey("jwk",stringToArrayBuffer(JSON.stringify(h)),r,s,a)}catch{return this.subtle.importKey("jwk",h,r,s,a)}return this.subtle.importKey("jwk",h,r,s,a)}async exportKey(e,t){let r=await this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&r instanceof ArrayBuffer&&(r=JSON.parse(arrayBufferToString(r))),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":{const e=new PublicKeyInfo;try{e.fromJSON(r)}catch(e){throw new Error("Incorrect key data")}return e.toSchema().toBER(!1)}case"pkcs8":{const e=new PrivateKeyInfo;try{e.fromJSON(r)}catch(e){throw new Error("Incorrect key data")}return e.toSchema().toBER(!1)}case"jwk":return r;default:throw new Error(`Incorrect format: ${e}`)}}async convert(e,t,r,s,a,i){if(e.toLowerCase()===t.toLowerCase())return r;const n=await this.importKey(e,r,s,a,i);return this.exportKey(t,n)}getAlgorithmByOID(e,t=!1,r){switch(e){case"1.2.840.113549.1.1.1":return{name:"RSAES-PKCS1-v1_5"};case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}if(t)throw new Error(`Unsupported algorithm identifier ${r?`for ${r} `:ke}: ${e}`);return{}}getOIDByAlgorithm(e,t=!1,r){let s=ke;switch(e.name.toUpperCase()){case"RSAES-PKCS1-V1_5":s="1.2.840.113549.1.1.1";break;case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.113549.1.1.5";break;case"SHA-256":s="1.2.840.113549.1.1.11";break;case"SHA-384":s="1.2.840.113549.1.1.12";break;case"SHA-512":s="1.2.840.113549.1.1.13"}break;case"RSA-PSS":s="1.2.840.113549.1.1.10";break;case"RSA-OAEP":s="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.10045.4.1";break;case"SHA-256":s="1.2.840.10045.4.3.2";break;case"SHA-384":s="1.2.840.10045.4.3.3";break;case"SHA-512":s="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":s="1.3.133.16.840.63.0.2";break;case"SHA-256":s="1.3.132.1.11.1";break;case"SHA-384":s="1.3.132.1.11.2";break;case"SHA-512":s="1.3.132.1.11.3"}break;case"AES-CTR":case"AES-CMAC":case"CONCAT":case"HKDF":break;case"AES-CBC":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.2";break;case 192:s="2.16.840.1.101.3.4.1.22";break;case 256:s="2.16.840.1.101.3.4.1.42"}break;case"AES-GCM":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.6";break;case 192:s="2.16.840.1.101.3.4.1.26";break;case 256:s="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.4";break;case 192:s="2.16.840.1.101.3.4.1.24";break;case 256:s="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.5";break;case 192:s="2.16.840.1.101.3.4.1.25";break;case 256:s="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.113549.2.7";break;case"SHA-256":s="1.2.840.113549.2.9";break;case"SHA-384":s="1.2.840.113549.2.10";break;case"SHA-512":s="1.2.840.113549.2.11"}break;case"DH":s="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":s="1.3.14.3.2.26";break;case"SHA-256":s="2.16.840.1.101.3.4.2.1";break;case"SHA-384":s="2.16.840.1.101.3.4.2.2";break;case"SHA-512":s="2.16.840.1.101.3.4.2.3";break;case"PBKDF2":s="1.2.840.113549.1.5.12";break;case"P-256":s="1.2.840.10045.3.1.7";break;case"P-384":s="1.3.132.0.34";break;case"P-521":s="1.3.132.0.35"}if(!s&&t)throw new Error(`Unsupported algorithm ${r?`for ${r} `:ke}: ${e.name}`);return s}getAlgorithmParameters(e,t){let r={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSAES-PKCS1-V1_5":case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":r={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":r={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":r={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":r={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":r={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":r={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":r={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":r={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":if("derivekey"!==t.toLowerCase())return{algorithm:{name:"HKDF"},usages:[]};r={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;case"PBKDF2":if("derivekey"!==t.toLowerCase())return{algorithm:{name:"PBKDF2"},usages:[]};r={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]}}return r}getHashAlgorithm(e){let t=ke;switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{const r=new RSASSAPSSParams({schema:e.algorithmParams});if(r.hashAlgorithm){const e=this.getAlgorithmByOID(r.hashAlgorithm.algorithmId);if(!("name"in e))return ke;t=e.name}else t="SHA-1"}catch{}}return t}async encryptEncryptedContentInfo(e){ParameterError.assert(e,"password","contentEncryptionAlgorithm","hmacHashAlgorithm","iterationCount","contentToEncrypt","contentToEncrypt","contentType");const t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm,!0,"contentEncryptionAlgorithm"),r=this.getOIDByAlgorithm({name:"PBKDF2"},!0,"PBKDF2"),s=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),a=new ArrayBuffer(16),i=new Uint8Array(a);this.getRandomValues(i);const n=new ArrayBuffer(64),o=new Uint8Array(n);this.getRandomValues(o);const l=new Uint8Array(e.contentToEncrypt),c=new PBKDF2Params({salt:new OctetString({valueHex:n}),iterationCount:e.iterationCount,prf:new AlgorithmIdentifier({algorithmId:s,algorithmParams:new Null})}),u=new Uint8Array(e.password),h=await this.importKey("raw",u,"PBKDF2",!1,["deriveKey"]),m=await this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:o,iterations:e.iterationCount},h,e.contentEncryptionAlgorithm,!1,["encrypt"]),f=await this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:i},m,l),g=new PBES2Params({keyDerivationFunc:new AlgorithmIdentifier({algorithmId:r,algorithmParams:c.toSchema()}),encryptionScheme:new AlgorithmIdentifier({algorithmId:t,algorithmParams:new OctetString({valueHex:a})})});return new EncryptedContentInfo({contentType:e.contentType,contentEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:g.toSchema()}),encryptedContent:new OctetString({valueHex:f})})}async decryptEncryptedContentInfo(e){if(ParameterError.assert(e,"password","encryptedContentInfo"),"1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)throw new Error(`Unknown "contentEncryptionAlgorithm": ${e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);let t,r;try{t=new PBES2Params({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "pbes2Parameters"')}try{r=new PBKDF2Params({schema:t.keyDerivationFunc.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "pbkdf2Params"')}const s=this.getAlgorithmByOID(t.encryptionScheme.algorithmId,!0),a=t.encryptionScheme.algorithmParams.valueBlock.valueHex,i=new Uint8Array(a),n=r.salt.valueBlock.valueHex,o=new Uint8Array(n),l=r.iterationCount;let c="SHA-1";if(r.prf){c=this.getAlgorithmByOID(r.prf.algorithmId,!0).hash.name}const u=await this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),h=await this.deriveKey({name:"PBKDF2",hash:{name:c},salt:o,iterations:l},u,s,!1,["decrypt"]),m=e.encryptedContentInfo.getEncryptedContent();return this.decrypt({name:s.name,iv:i},h,m)}async stampDataWithPassword(e){if(e instanceof Object==!1)throw new Error('Parameters must have type "Object"');let t;switch(ParameterError.assert(e,"password","hashAlgorithm","iterationCount","salt","contentToStamp"),e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}const r={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},s=await makePKCS12B2Key(e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),a=await this.importKey("raw",new Uint8Array(s),r,!1,["sign"]);return this.sign(r,a,new Uint8Array(e.contentToStamp))}async verifyDataStampedWithPassword(e){ParameterError.assert(e,"password","hashAlgorithm","salt","iterationCount","contentToVerify","signatureToVerify");let t=0;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}const r={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},s=await makePKCS12B2Key(e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),a=await this.importKey("raw",new Uint8Array(s),r,!1,["verify"]);return this.verify(r,a,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify))}async getSignatureParameters(e,t="SHA-1"){this.getOIDByAlgorithm({name:t},!0,"hashAlgorithm");const r=new AlgorithmIdentifier,s=this.getAlgorithmParameters(e.algorithm.name,"sign");if(!Object.keys(s.algorithm).length)throw new Error("Parameter 'algorithm' is empty");const a=s.algorithm;switch("hash"in e.algorithm&&e.algorithm.hash&&e.algorithm.hash.name?a.hash.name=e.algorithm.hash.name:a.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":r.algorithmId=this.getOIDByAlgorithm(a,!0);break;case"RSA-PSS":{switch(a.hash.name.toUpperCase()){case"SHA-256":a.saltLength=32;break;case"SHA-384":a.saltLength=48;break;case"SHA-512":a.saltLength=64}const e={};if("SHA-1"!==a.hash.name.toUpperCase()){const t=this.getOIDByAlgorithm({name:a.hash.name},!0,"hashAlgorithm");e.hashAlgorithm=new AlgorithmIdentifier({algorithmId:t,algorithmParams:new Null}),e.maskGenAlgorithm=new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==a.saltLength&&(e.saltLength=a.saltLength);const t=new RSASSAPSSParams(e);r.algorithmId="1.2.840.113549.1.1.10",r.algorithmParams=t.toSchema()}break;default:throw new Error(`Unsupported signature algorithm: ${e.algorithm.name}`)}return{signatureAlgorithm:r,parameters:s}}async signWithPrivateKey(e,t,r){const s=await this.sign(r.algorithm,t,e);return"ECDSA"===r.algorithm.name?function(e){if(e.byteLength%2!=0)return Ae;const t=e.byteLength/2,r=new ArrayBuffer(t);new Uint8Array(r).set(new Uint8Array(e,0,t));const s=new Integer({valueHex:r}),a=new ArrayBuffer(t);new Uint8Array(a).set(new Uint8Array(e,t,t));const i=new Integer({valueHex:a});return new Sequence({value:[s.convertToDER(),i.convertToDER()]}).toBER(!1)}(s):s}fillPublicKeyParameters(e,t){const r={},s=this.getHashAlgorithm(t);if(s===ke)throw new Error(`Unsupported signature algorithm: ${t.algorithmId}`);let a;a="1.2.840.113549.1.1.10"===t.algorithmId?t.algorithmId:e.algorithm.algorithmId;const i=this.getAlgorithmByOID(a,!0);if(r.algorithm=this.getAlgorithmParameters(i.name,"importKey"),"hash"in r.algorithm.algorithm&&(r.algorithm.algorithm.hash.name=s),"ECDSA"===i.name){const t=e.algorithm;if(!t.algorithmParams)throw new Error("Algorithm parameters for ECDSA public key are missed");const s=t.algorithmParams;if("idBlock"in t.algorithmParams&&(1!==s.idBlock.tagClass||6!==s.idBlock.tagNumber))throw new Error("Incorrect type for ECDSA public key parameters");const a=this.getAlgorithmByOID(s.valueBlock.toString(),!0);r.algorithm.algorithm.namedCurve=a.name}return r}async getPublicKey(e,t,r){r||(r=this.fillPublicKeyParameters(e,t));const s=e.toSchema().toBER(!1);return this.importKey("spki",s,r.algorithm.algorithm,!0,r.algorithm.usages)}async verifyWithPublicKey(e,t,r,s,a){let i;if(a){const e={};let t;t="1.2.840.113549.1.1.10"===s.algorithmId?s.algorithmId:r.algorithm.algorithmId;const n=this.getAlgorithmByOID(t,!0);if(e.algorithm=this.getAlgorithmParameters(n.name,"importKey"),"hash"in e.algorithm.algorithm&&(e.algorithm.algorithm.hash.name=a),"ECDSA"===n.name){let t=!1;if("algorithmParams"in r.algorithm==!0&&"idBlock"in r.algorithm.algorithmParams&&1===r.algorithm.algorithmParams.idBlock.tagClass&&6===r.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)throw new Error("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(r.algorithm.algorithmParams.valueBlock.toString(),!0);e.algorithm.algorithm.namedCurve=s.name}i=await this.getPublicKey(r,null,e)}else{if(!(a=this.getHashAlgorithm(s)))throw new Error(`Unsupported signature algorithm: ${s.algorithmId}`);i=await this.getPublicKey(r,s)}const n=this.getAlgorithmParameters(i.algorithm.name,"verify");"hash"in n.algorithm&&(n.algorithm.hash.name=a);let o=t.valueBlock.valueHexView;if("ECDSA"===i.algorithm.name){const e=ECNamedCurves.find(i.algorithm.namedCurve);if(!e)throw new Error("Unsupported named curve in use");const t=fromBER(o);AsnError.assert(t,"Signature value"),o=function(e,t){if(!(e instanceof Sequence&&2===e.valueBlock.value.length&&e.valueBlock.value[0]instanceof Integer&&e.valueBlock.value[1]instanceof Integer))return Ae;const r=e.valueBlock.value[0].convertFromDER().valueBlock.valueHexView,s=e.valueBlock.value[1].convertFromDER().valueBlock.valueHexView,a=new Uint8Array(2*t);return a.set(r,t-r.byteLength),a.set(s,2*t-s.byteLength),a.buffer}(t.result,e.size)}if("RSA-PSS"===i.algorithm.name){const e=new RSASSAPSSParams({schema:s.algorithmParams});n.algorithm.saltLength="saltLength"in e?e.saltLength:20;let t="SHA-1";if("hashAlgorithm"in e){t=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId,!0).name}n.algorithm.hash.name=t}return this.verify(n.algorithm,i,o,e)}}let Bs={name:"none",crypto:null};function isCryptoEngine(e){return!(!e||"object"!=typeof e||!("crypto"in e))}function setEngine(e,...t){let r=null;if(t.length<2)r=t.length?t[0]:"undefined"!=typeof self&&self.crypto?new CryptoEngine({name:"browser",crypto:self.crypto}):null;else{const e=t[0],s=t[1];isCryptoEngine(s)?r=s:isCryptoEngine(e)?r=e:"subtle"in e&&"getRandomValues"in e&&(r=new CryptoEngine({crypto:e}))}if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){if(void 0===global[process.pid])global[process.pid]={};else if("object"!=typeof global[process.pid])throw new Error(`Name global.${process.pid} already exists and it is not an object`);if(void 0===global[process.pid].pkijs)global[process.pid].pkijs={};else if("object"!=typeof global[process.pid].pkijs)throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);global[process.pid].pkijs.engine={name:e,crypto:r}}else Bs={name:e,crypto:r}}function getCrypto(e=!1){const t=function(){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){let e;try{e=global[process.pid].pkijs.engine}catch(e){throw new Error("Please call 'setEngine' before call to 'getEngine'")}return e}return Bs}();if(!t.crypto&&e)throw new Error("Unable to create WebCrypto object");return t.crypto}async function kdfWithCounter(e,t,r,s,a){switch(e.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":break;default:throw new ArgumentError(`Unknown hash function: ${e}`)}if(ArgumentError.assert(t,"zBuffer","ArrayBuffer"),0===t.byteLength)throw new ArgumentError("'zBuffer' has zero length, error");if(ArgumentError.assert(s,"SharedInfo","ArrayBuffer"),r>255)throw new ArgumentError("Please set 'Counter' argument to value less or equal to 255");const i=new ArrayBuffer(4),n=new Uint8Array(i);n[0]=0,n[1]=0,n[2]=0,n[3]=r;let o=Ae;o=utilConcatBuf(o,t),o=utilConcatBuf(o,i),o=utilConcatBuf(o,s);return{counter:r,result:await a.digest({name:e},o)}}async function kdf(e,t,r,s,a=getCrypto(!0)){let i=0,n=1;switch(e.toUpperCase()){case"SHA-1":i=160;break;case"SHA-256":i=256;break;case"SHA-384":i=384;break;case"SHA-512":i=512;break;default:throw new ArgumentError(`Unknown hash function: ${e}`)}if(ArgumentError.assert(t,"Zbuffer","ArrayBuffer"),0===t.byteLength)throw new ArgumentError("'Zbuffer' has zero length, error");ArgumentError.assert(s,"SharedInfo","ArrayBuffer");const o=r/i;Math.floor(o)>0&&(n=Math.floor(o),o-n>0&&n++);const l=[];for(let r=1;r<=n;r++)l.push(await kdfWithCounter(e,t,r,s,a));let c=Ae,u=1,h=!0;for(;h;){h=!1;for(const e of l)if(e.counter===u){c=utilConcatBuf(c,e.result),h=!0;break}u++}if(r>>=3,c.byteLength>r){const e=new ArrayBuffer(r),t=new Uint8Array(e),s=new Uint8Array(c);for(let e=0;e<r;e++)t[e]=s[e];return e}return c}const Is="version",Ns="logID",Ps="extensions",Es="timestamp",Ds="hashAlgorithm",Os="signatureAlgorithm",xs="signature",Rs="none",Ks="sha1",Us="sha224",Ts="sha256",Ls="sha384",Hs="sha512",qs="anonymous",js="ecdsa";class SignedCertificateTimestamp extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Is,SignedCertificateTimestamp.defaultValues(Is)),this.logID=getParametersValue(e,Ns,SignedCertificateTimestamp.defaultValues(Ns)),this.timestamp=getParametersValue(e,Es,SignedCertificateTimestamp.defaultValues(Es)),this.extensions=getParametersValue(e,Ps,SignedCertificateTimestamp.defaultValues(Ps)),this.hashAlgorithm=getParametersValue(e,Ds,SignedCertificateTimestamp.defaultValues(Ds)),this.signatureAlgorithm=getParametersValue(e,Os,SignedCertificateTimestamp.defaultValues(Os)),this.signature=getParametersValue(e,xs,SignedCertificateTimestamp.defaultValues(xs)),"stream"in e&&e.stream&&this.fromStream(e.stream),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Is:return 0;case Ns:case Ps:return Ae;case Es:return new Date(0);case Ds:case Os:return ke;case xs:return new Any;default:return super.defaultValues(e)}}fromSchema(e){if(e instanceof RawData==!1)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");const t=new SeqStream({stream:new ByteStream({buffer:e.data})});this.fromStream(t)}fromStream(e){const t=e.getUint16();if(this.version=e.getBlock(1)[0],0===this.version){this.logID=new Uint8Array(e.getBlock(32)).buffer.slice(0),this.timestamp=new Date(utilFromBase(new Uint8Array(e.getBlock(8)),8));const r=e.getUint16();switch(this.extensions=new Uint8Array(e.getBlock(r)).buffer.slice(0),e.getBlock(1)[0]){case 0:this.hashAlgorithm=Rs;break;case 1:this.hashAlgorithm="md5";break;case 2:this.hashAlgorithm=Ks;break;case 3:this.hashAlgorithm=Us;break;case 4:this.hashAlgorithm=Ts;break;case 5:this.hashAlgorithm=Ls;break;case 6:this.hashAlgorithm=Hs;break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}switch(e.getBlock(1)[0]){case 0:this.signatureAlgorithm=qs;break;case 1:this.signatureAlgorithm="rsa";break;case 2:this.signatureAlgorithm="dsa";break;case 3:this.signatureAlgorithm=js;break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}const s=e.getUint16(),a=fromBER(new Uint8Array(e.getBlock(s)).buffer.slice(0));if(AsnError.assert(a,"SignedCertificateTimestamp"),this.signature=a.result,t!==47+r+s)throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}}toSchema(){const e=this.toStream();return new RawData({data:e.stream.buffer})}toStream(){const e=new SeqStream;e.appendUint16(47+this.extensions.byteLength+this.signature.valueBeforeDecodeView.byteLength),e.appendChar(this.version),e.appendView(new Uint8Array(this.logID));const t=new ArrayBuffer(8),r=new Uint8Array(t),s=utilToBase(this.timestamp.valueOf(),8);let a,i;switch(r.set(new Uint8Array(s),8-s.byteLength),e.appendView(r),e.appendUint16(this.extensions.byteLength),this.extensions.byteLength&&e.appendView(new Uint8Array(this.extensions)),this.hashAlgorithm.toLowerCase()){case Rs:a=0;break;case"md5":a=1;break;case Ks:a=2;break;case Us:a=3;break;case Ts:a=4;break;case Ls:a=5;break;case Hs:a=6;break;default:throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`)}switch(e.appendChar(a),this.signatureAlgorithm.toLowerCase()){case qs:i=0;break;case"rsa":i=1;break;case"dsa":i=2;break;case js:i=3;break;default:throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`)}e.appendChar(i);const n=this.signature.toBER(!1);return e.appendUint16(n.byteLength),e.appendView(new Uint8Array(n)),e}toJSON(){return{version:this.version,logID:bufferToHexCodes(this.logID),timestamp:this.timestamp,extensions:bufferToHexCodes(this.extensions),hashAlgorithm:this.hashAlgorithm,signatureAlgorithm:this.signatureAlgorithm,signature:this.signature.toJSON()}}async verify(e,t,r=0,s=getCrypto(!0)){const a=toBase64(arrayBufferToString(this.logID));let i=null;const n=new SeqStream;for(const t of e)if(t.log_id===a){i=t.key;break}if(!i)throw new Error(`Public key not found for CT with logId: ${a}`);const o=stringToArrayBuffer(fromBase64(i)),l=PublicKeyInfo.fromBER(o);n.appendChar(0),n.appendChar(0);const c=new ArrayBuffer(8),u=new Uint8Array(c),h=utilToBase(this.timestamp.valueOf(),8);return u.set(new Uint8Array(h),8-h.byteLength),n.appendView(u),n.appendUint16(r),0===r&&n.appendUint24(t.byteLength),n.appendView(new Uint8Array(t)),n.appendUint16(this.extensions.byteLength),0!==this.extensions.byteLength&&n.appendView(new Uint8Array(this.extensions)),s.verifyWithPublicKey(n.buffer.slice(0,n.length),new OctetString({valueHex:this.signature.toBER(!1)}),l,{algorithmId:ke},"SHA-256")}}SignedCertificateTimestamp.CLASS_NAME="SignedCertificateTimestamp";const Ms="timestamps";class SignedCertificateTimestampList extends PkiObject{constructor(e={}){super(),this.timestamps=getParametersValue(e,Ms,SignedCertificateTimestampList.defaultValues(Ms)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Ms?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===Ms?0===t.length:super.defaultValues(e)}static schema(e={}){var t;const r=getParametersValue(e,"names",{});return null!==(t=r.optional)&&void 0!==t||(r.optional=!1),new OctetString({name:r.blockName||"SignedCertificateTimestampList",optional:r.optional})}fromSchema(e){if(e instanceof OctetString==!1)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");const t=new SeqStream({stream:new ByteStream({buffer:e.valueBlock.valueHex})});if(t.getUint16()!==t.length)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");for(;t.length;)this.timestamps.push(new SignedCertificateTimestamp({stream:t}))}toSchema(){const e=new SeqStream;let t=0;const r=[];for(const e of this.timestamps){const s=e.toStream();r.push(s),t+=s.stream.buffer.byteLength}e.appendUint16(t);for(const t of r)e.appendView(t.stream.view);return new OctetString({valueHex:e.stream.buffer.slice(0)})}toJSON(){return{timestamps:Array.from(this.timestamps,e=>e.toJSON())}}}SignedCertificateTimestampList.CLASS_NAME="SignedCertificateTimestampList";const Js="attributes",_s=[Js];class SubjectDirectoryAttributes extends PkiObject{constructor(e={}){super(),this.attributes=getParametersValue(e,Js,SubjectDirectoryAttributes.defaultValues(Js)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Js?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.attributes||ke,value:Attribute.schema()})]})}fromSchema(e){clearProps(e,_s);const t=compareSchema(e,e,SubjectDirectoryAttributes.schema({names:{attributes:Js}}));AsnError.assertSchema(t,this.className),this.attributes=Array.from(t.result.attributes,e=>new Attribute({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}}SubjectDirectoryAttributes.CLASS_NAME="SubjectDirectoryAttributes";class ExtensionValueFactory{static getItems(){return this.types||(this.types={},ExtensionValueFactory.register(Ze,"SubjectAltName",AltName),ExtensionValueFactory.register(Ye,"IssuerAltName",AltName),ExtensionValueFactory.register(lt,"AuthorityKeyIdentifier",AuthorityKeyIdentifier),ExtensionValueFactory.register(Xe,"BasicConstraints",BasicConstraints),ExtensionValueFactory.register("1.3.6.1.4.1.311.21.1","MicrosoftCaVersion",CAVersion),ExtensionValueFactory.register(it,"CertificatePolicies",CertificatePolicies),ExtensionValueFactory.register("1.3.6.1.4.1.311.21.10","CertificatePoliciesMicrosoft",CertificatePolicies),ExtensionValueFactory.register("1.3.6.1.4.1.311.21.7","MicrosoftCertTemplateV2",CertificateTemplate),ExtensionValueFactory.register(st,"CRLDistributionPoints",CRLDistributionPoints),ExtensionValueFactory.register(at,"FreshestCRL",CRLDistributionPoints),ExtensionValueFactory.register("2.5.29.37","ExtKeyUsage",ExtKeyUsage),ExtensionValueFactory.register(tt,"CertificateIssuer",GeneralNames),ExtensionValueFactory.register(ut,"AuthorityInfoAccess",InfoAccess),ExtensionValueFactory.register("1.3.6.1.5.5.7.1.11","SubjectInfoAccess",InfoAccess),ExtensionValueFactory.register(et,"IssuingDistributionPoint",IssuingDistributionPoint),ExtensionValueFactory.register(rt,"NameConstraints",NameConstraints),ExtensionValueFactory.register(ct,"PolicyConstraints",PolicyConstraints),ExtensionValueFactory.register(ot,"PolicyMappings",PolicyMappings),ExtensionValueFactory.register("2.5.29.16","PrivateKeyUsagePeriod",PrivateKeyUsagePeriod),ExtensionValueFactory.register("1.3.6.1.5.5.7.1.3","QCStatements",QCStatements),ExtensionValueFactory.register("1.3.6.1.4.1.11129.2.4.2","SignedCertificateTimestampList",SignedCertificateTimestampList),ExtensionValueFactory.register("2.5.29.9","SubjectDirectoryAttributes",SubjectDirectoryAttributes)),this.types}static fromBER(e,t){const r=fromBER(t);if(-1===r.offset)return null;const s=this.find(e);if(s)try{return new s.type({schema:r.result})}catch(t){const r=new s.type;return r.parsingError=`Incorrectly formatted value of extension ${s.name} (${e})`,r}return r.result}static find(e){return this.getItems()[e]||null}static register(e,t,r){this.getItems()[e]={name:t,type:r}}}const Fs="extnID",$s="critical",Ws="extnValue",Gs="parsedValue",zs=[Fs,$s,Ws];class Extension extends PkiObject{get parsedValue(){if(void 0===this._parsedValue){const e=ExtensionValueFactory.fromBER(this.extnID,this.extnValue.valueBlock.valueHexView);this._parsedValue=e}return this._parsedValue||void 0}set parsedValue(e){this._parsedValue=e}constructor(e={}){super(),this.extnID=getParametersValue(e,Fs,Extension.defaultValues(Fs)),this.critical=getParametersValue(e,$s,Extension.defaultValues($s)),this.extnValue=Ws in e?new OctetString({valueHex:e.extnValue}):Extension.defaultValues(Ws),Gs in e&&(this.parsedValue=getParametersValue(e,Gs,Extension.defaultValues(Gs))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Fs:return ke;case $s:return!1;case Ws:return new OctetString;case Gs:return{};default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.extnID||ke}),new Boolean({name:t.critical||ke,optional:!0}),new OctetString({name:t.extnValue||ke})]})}fromSchema(e){clearProps(e,zs);const t=compareSchema(e,e,Extension.schema({names:{extnID:Fs,critical:$s,extnValue:Ws}}));AsnError.assertSchema(t,this.className),this.extnID=t.result.extnID.valueBlock.toString(),$s in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.extnID})),this.critical!==Extension.defaultValues($s)&&e.push(new Boolean({value:this.critical})),e.push(this.extnValue),new Sequence({value:e})}toJSON(){const e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==Extension.defaultValues($s)&&(e.critical=this.critical),this.parsedValue&&this.parsedValue.toJSON&&(e.parsedValue=this.parsedValue.toJSON()),e}}Extension.CLASS_NAME="Extension";const Qs="extensions",Zs=[Qs];class Extensions extends PkiObject{constructor(e={}){super(),this.extensions=getParametersValue(e,Qs,Extensions.defaultValues(Qs)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Qs?[]:super.defaultValues(e)}static schema(e={},t=!1){const r=getParametersValue(e,"names",{});return new Sequence({optional:t,name:r.blockName||ke,value:[new Repeated({name:r.extensions||ke,value:Extension.schema(r.extension||{})})]})}fromSchema(e){clearProps(e,Zs);const t=compareSchema(e,e,Extensions.schema({names:{extensions:Qs}}));AsnError.assertSchema(t,this.className),this.extensions=Array.from(t.result.extensions,e=>new Extension({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:this.extensions.map(e=>e.toJSON())}}}Extensions.CLASS_NAME="Extensions";const Ys="issuer",Xs="serialNumber",ea="issuerUID",ta=[Ys,Xs,ea];class IssuerSerial extends PkiObject{constructor(e={}){super(),this.issuer=getParametersValue(e,Ys,IssuerSerial.defaultValues(Ys)),this.serialNumber=getParametersValue(e,Xs,IssuerSerial.defaultValues(Xs)),ea in e&&(this.issuerUID=getParametersValue(e,ea,IssuerSerial.defaultValues(ea))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ys:return new GeneralNames;case Xs:return new Integer;case ea:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[GeneralNames.schema(t.issuer||{}),new Integer({name:t.serialNumber||ke}),new BitString({optional:!0,name:t.issuerUID||ke})]})}fromSchema(e){clearProps(e,ta);const t=compareSchema(e,e,IssuerSerial.schema({names:{issuer:{names:{blockName:Ys}},serialNumber:Xs,issuerUID:ea}}));AsnError.assertSchema(t,this.className),this.issuer=new GeneralNames({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber,ea in t.result&&(this.issuerUID=t.result.issuerUID)}toSchema(){const e=new Sequence({value:[this.issuer.toSchema(),this.serialNumber]});return this.issuerUID&&e.valueBlock.value.push(this.issuerUID),e}toJSON(){const e={issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()};return this.issuerUID&&(e.issuerUID=this.issuerUID.toJSON()),e}}IssuerSerial.CLASS_NAME="IssuerSerial";const ra="version",sa="baseCertificateID",aa="subjectName",ia="issuer",na="signature",oa="serialNumber",la="attrCertValidityPeriod",ca="attributes",ua="issuerUniqueID",ha="extensions",ma=[ra,sa,aa,ia,na,oa,la,ca,ua,ha];class AttributeCertificateInfoV1 extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,ra,AttributeCertificateInfoV1.defaultValues(ra)),sa in e&&(this.baseCertificateID=getParametersValue(e,sa,AttributeCertificateInfoV1.defaultValues(sa))),aa in e&&(this.subjectName=getParametersValue(e,aa,AttributeCertificateInfoV1.defaultValues(aa))),this.issuer=getParametersValue(e,ia,AttributeCertificateInfoV1.defaultValues(ia)),this.signature=getParametersValue(e,na,AttributeCertificateInfoV1.defaultValues(na)),this.serialNumber=getParametersValue(e,oa,AttributeCertificateInfoV1.defaultValues(oa)),this.attrCertValidityPeriod=getParametersValue(e,la,AttributeCertificateInfoV1.defaultValues(la)),this.attributes=getParametersValue(e,ca,AttributeCertificateInfoV1.defaultValues(ca)),ua in e&&(this.issuerUniqueID=getParametersValue(e,ua,AttributeCertificateInfoV1.defaultValues(ua))),ha in e&&(this.extensions=getParametersValue(e,ha,AttributeCertificateInfoV1.defaultValues(ha))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ra:return 0;case sa:return new IssuerSerial;case aa:case ia:return new GeneralNames;case na:return new AlgorithmIdentifier;case oa:return new Integer;case la:return new AttCertValidityPeriod;case ca:return[];case ua:return new BitString;case ha:return new Extensions;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||ke}),new Choice({value:[new Constructed({name:t.baseCertificateID||ke,idBlock:{tagClass:3,tagNumber:0},value:IssuerSerial.schema().valueBlock.value}),new Constructed({name:t.subjectName||ke,idBlock:{tagClass:3,tagNumber:1},value:GeneralNames.schema().valueBlock.value})]}),GeneralNames.schema({names:{blockName:t.issuer||ke}}),AlgorithmIdentifier.schema(t.signature||{}),new Integer({name:t.serialNumber||ke}),AttCertValidityPeriod.schema(t.attrCertValidityPeriod||{}),new Sequence({name:t.attributes||ke,value:[new Repeated({value:Attribute.schema()})]}),new BitString({optional:!0,name:t.issuerUniqueID||ke}),Extensions.schema(t.extensions||{},!0)]})}fromSchema(e){clearProps(e,ma);const t=compareSchema(e,e,AttributeCertificateInfoV1.schema({names:{version:ra,baseCertificateID:sa,subjectName:aa,issuer:ia,signature:{names:{blockName:na}},serialNumber:oa,attrCertValidityPeriod:{names:{blockName:la}},attributes:ca,issuerUniqueID:ua,extensions:{names:{blockName:ha}}}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,sa in t.result&&(this.baseCertificateID=new IssuerSerial({schema:new Sequence({value:t.result.baseCertificateID.valueBlock.value})})),aa in t.result&&(this.subjectName=new GeneralNames({schema:new Sequence({value:t.result.subjectName.valueBlock.value})})),this.issuer=t.result.issuer,this.signature=new AlgorithmIdentifier({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new AttCertValidityPeriod({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,e=>new Attribute({schema:e})),ua in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),ha in t.result&&(this.extensions=new Extensions({schema:t.result.extensions}))}toSchema(){const e=new Sequence({value:[new Integer({value:this.version})]});return this.baseCertificateID&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.subjectName&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.subjectName.toSchema().valueBlock.value})),e.valueBlock.value.push(this.issuer.toSchema()),e.valueBlock.value.push(this.signature.toSchema()),e.valueBlock.value.push(this.serialNumber),e.valueBlock.value.push(this.attrCertValidityPeriod.toSchema()),e.valueBlock.value.push(new Sequence({value:Array.from(this.attributes,e=>e.toSchema())})),this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){const e={version:this.version};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.subjectName&&(e.subjectName=this.subjectName.toJSON()),e.issuer=this.issuer.toJSON(),e.signature=this.signature.toJSON(),e.serialNumber=this.serialNumber.toJSON(),e.attrCertValidityPeriod=this.attrCertValidityPeriod.toJSON(),e.attributes=Array.from(this.attributes,e=>e.toJSON()),this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}}AttributeCertificateInfoV1.CLASS_NAME="AttributeCertificateInfoV1";const fa="acinfo",ga="signatureAlgorithm",da="signatureValue",pa=[fa,da,ga];class AttributeCertificateV1 extends PkiObject{constructor(e={}){super(),this.acinfo=getParametersValue(e,fa,AttributeCertificateV1.defaultValues(fa)),this.signatureAlgorithm=getParametersValue(e,ga,AttributeCertificateV1.defaultValues(ga)),this.signatureValue=getParametersValue(e,da,AttributeCertificateV1.defaultValues(da)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case fa:return new AttributeCertificateInfoV1;case ga:return new AlgorithmIdentifier;case da:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[AttributeCertificateInfoV1.schema(t.acinfo||{}),AlgorithmIdentifier.schema(t.signatureAlgorithm||{}),new BitString({name:t.signatureValue||ke})]})}fromSchema(e){clearProps(e,pa);const t=compareSchema(e,e,AttributeCertificateV1.schema({names:{acinfo:{names:{blockName:fa}},signatureAlgorithm:{names:{blockName:ga}},signatureValue:da}}));AsnError.assertSchema(t,this.className),this.acinfo=new AttributeCertificateInfoV1({schema:t.result.acinfo}),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new Sequence({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}AttributeCertificateV1.CLASS_NAME="AttributeCertificateV1";const Sa="digestedObjectType",ya="otherObjectTypeID",wa="digestAlgorithm",va="objectDigest",ba=[Sa,ya,wa,va];class ObjectDigestInfo extends PkiObject{constructor(e={}){super(),this.digestedObjectType=getParametersValue(e,Sa,ObjectDigestInfo.defaultValues(Sa)),ya in e&&(this.otherObjectTypeID=getParametersValue(e,ya,ObjectDigestInfo.defaultValues(ya))),this.digestAlgorithm=getParametersValue(e,wa,ObjectDigestInfo.defaultValues(wa)),this.objectDigest=getParametersValue(e,va,ObjectDigestInfo.defaultValues(va)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Sa:return new Enumerated;case ya:return new ObjectIdentifier;case wa:return new AlgorithmIdentifier;case va:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Enumerated({name:t.digestedObjectType||ke}),new ObjectIdentifier({optional:!0,name:t.otherObjectTypeID||ke}),AlgorithmIdentifier.schema(t.digestAlgorithm||{}),new BitString({name:t.objectDigest||ke})]})}fromSchema(e){clearProps(e,ba);const t=compareSchema(e,e,ObjectDigestInfo.schema({names:{digestedObjectType:Sa,otherObjectTypeID:ya,digestAlgorithm:{names:{blockName:wa}},objectDigest:va}}));AsnError.assertSchema(t,this.className),this.digestedObjectType=t.result.digestedObjectType,ya in t.result&&(this.otherObjectTypeID=t.result.otherObjectTypeID),this.digestAlgorithm=new AlgorithmIdentifier({schema:t.result.digestAlgorithm}),this.objectDigest=t.result.objectDigest}toSchema(){const e=new Sequence({value:[this.digestedObjectType]});return this.otherObjectTypeID&&e.valueBlock.value.push(this.otherObjectTypeID),e.valueBlock.value.push(this.digestAlgorithm.toSchema()),e.valueBlock.value.push(this.objectDigest),e}toJSON(){const e={digestedObjectType:this.digestedObjectType.toJSON(),digestAlgorithm:this.digestAlgorithm.toJSON(),objectDigest:this.objectDigest.toJSON()};return this.otherObjectTypeID&&(e.otherObjectTypeID=this.otherObjectTypeID.toJSON()),e}}ObjectDigestInfo.CLASS_NAME="ObjectDigestInfo";const Aa="issuerName",ka="baseCertificateID",Ca="objectDigestInfo",Va=[Aa,ka,Ca];class V2Form extends PkiObject{constructor(e={}){super(),Aa in e&&(this.issuerName=getParametersValue(e,Aa,V2Form.defaultValues(Aa))),ka in e&&(this.baseCertificateID=getParametersValue(e,ka,V2Form.defaultValues(ka))),Ca in e&&(this.objectDigestInfo=getParametersValue(e,Ca,V2Form.defaultValues(Ca))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Aa:return new GeneralNames;case ka:return new IssuerSerial;case Ca:return new ObjectDigestInfo;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[GeneralNames.schema({names:{blockName:t.issuerName}},!0),new Constructed({optional:!0,name:t.baseCertificateID||ke,idBlock:{tagClass:3,tagNumber:0},value:IssuerSerial.schema().valueBlock.value}),new Constructed({optional:!0,name:t.objectDigestInfo||ke,idBlock:{tagClass:3,tagNumber:1},value:ObjectDigestInfo.schema().valueBlock.value})]})}fromSchema(e){clearProps(e,Va);const t=compareSchema(e,e,V2Form.schema({names:{issuerName:Aa,baseCertificateID:ka,objectDigestInfo:Ca}}));AsnError.assertSchema(t,this.className),Aa in t.result&&(this.issuerName=new GeneralNames({schema:t.result.issuerName})),ka in t.result&&(this.baseCertificateID=new IssuerSerial({schema:new Sequence({value:t.result.baseCertificateID.valueBlock.value})})),Ca in t.result&&(this.objectDigestInfo=new ObjectDigestInfo({schema:new Sequence({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){const e=new Sequence;return this.issuerName&&e.valueBlock.value.push(this.issuerName.toSchema()),this.baseCertificateID&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){const e={};return this.issuerName&&(e.issuerName=this.issuerName.toJSON()),this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}V2Form.CLASS_NAME="V2Form";const Ba="baseCertificateID",Ia="entityName",Na="objectDigestInfo",Pa=[Ba,Ia,Na];class Holder extends PkiObject{constructor(e={}){super(),Ba in e&&(this.baseCertificateID=getParametersValue(e,Ba,Holder.defaultValues(Ba))),Ia in e&&(this.entityName=getParametersValue(e,Ia,Holder.defaultValues(Ia))),Na in e&&(this.objectDigestInfo=getParametersValue(e,Na,Holder.defaultValues(Na))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ba:return new IssuerSerial;case Ia:return new GeneralNames;case Na:return new ObjectDigestInfo;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Constructed({optional:!0,name:t.baseCertificateID||ke,idBlock:{tagClass:3,tagNumber:0},value:IssuerSerial.schema().valueBlock.value}),new Constructed({optional:!0,name:t.entityName||ke,idBlock:{tagClass:3,tagNumber:1},value:GeneralNames.schema().valueBlock.value}),new Constructed({optional:!0,name:t.objectDigestInfo||ke,idBlock:{tagClass:3,tagNumber:2},value:ObjectDigestInfo.schema().valueBlock.value})]})}fromSchema(e){clearProps(e,Pa);const t=compareSchema(e,e,Holder.schema({names:{baseCertificateID:Ba,entityName:Ia,objectDigestInfo:Na}}));AsnError.assertSchema(t,this.className),Ba in t.result&&(this.baseCertificateID=new IssuerSerial({schema:new Sequence({value:t.result.baseCertificateID.valueBlock.value})})),Ia in t.result&&(this.entityName=new GeneralNames({schema:new Sequence({value:t.result.entityName.valueBlock.value})})),Na in t.result&&(this.objectDigestInfo=new ObjectDigestInfo({schema:new Sequence({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){const e=new Sequence;return this.baseCertificateID&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.entityName&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.entityName.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){const e={};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.entityName&&(e.entityName=this.entityName.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}Holder.CLASS_NAME="Holder";const Ea="version",Da="holder",Oa="issuer",xa="signature",Ra="serialNumber",Ka="attrCertValidityPeriod",Ua="attributes",Ta="issuerUniqueID",La="extensions",Ha=[Ea,Da,Oa,xa,Ra,Ka,Ua,Ta,La];class AttributeCertificateInfoV2 extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Ea,AttributeCertificateInfoV2.defaultValues(Ea)),this.holder=getParametersValue(e,Da,AttributeCertificateInfoV2.defaultValues(Da)),this.issuer=getParametersValue(e,Oa,AttributeCertificateInfoV2.defaultValues(Oa)),this.signature=getParametersValue(e,xa,AttributeCertificateInfoV2.defaultValues(xa)),this.serialNumber=getParametersValue(e,Ra,AttributeCertificateInfoV2.defaultValues(Ra)),this.attrCertValidityPeriod=getParametersValue(e,Ka,AttributeCertificateInfoV2.defaultValues(Ka)),this.attributes=getParametersValue(e,Ua,AttributeCertificateInfoV2.defaultValues(Ua)),Ta in e&&(this.issuerUniqueID=getParametersValue(e,Ta,AttributeCertificateInfoV2.defaultValues(Ta))),La in e&&(this.extensions=getParametersValue(e,La,AttributeCertificateInfoV2.defaultValues(La))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ea:return 1;case Da:return new Holder;case Oa:return{};case xa:return new AlgorithmIdentifier;case Ra:return new Integer;case Ka:return new AttCertValidityPeriod;case Ua:return[];case Ta:return new BitString;case La:return new Extensions;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||ke}),Holder.schema(t.holder||{}),new Choice({value:[GeneralNames.schema({names:{blockName:t.issuer||ke}}),new Constructed({name:t.issuer||ke,idBlock:{tagClass:3,tagNumber:0},value:V2Form.schema().valueBlock.value})]}),AlgorithmIdentifier.schema(t.signature||{}),new Integer({name:t.serialNumber||ke}),AttCertValidityPeriod.schema(t.attrCertValidityPeriod||{}),new Sequence({name:t.attributes||ke,value:[new Repeated({value:Attribute.schema()})]}),new BitString({optional:!0,name:t.issuerUniqueID||ke}),Extensions.schema(t.extensions||{},!0)]})}fromSchema(e){clearProps(e,Ha);const t=compareSchema(e,e,AttributeCertificateInfoV2.schema({names:{version:Ea,holder:{names:{blockName:Da}},issuer:Oa,signature:{names:{blockName:xa}},serialNumber:Ra,attrCertValidityPeriod:{names:{blockName:Ka}},attributes:Ua,issuerUniqueID:Ta,extensions:{names:{blockName:La}}}}));if(AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.holder=new Holder({schema:t.result.holder}),3!==t.result.issuer.idBlock.tagClass)throw new Error("Incorrect value for 'issuer' in AttributeCertificateInfoV2");this.issuer=new V2Form({schema:new Sequence({value:t.result.issuer.valueBlock.value})}),this.signature=new AlgorithmIdentifier({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new AttCertValidityPeriod({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,e=>new Attribute({schema:e})),Ta in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),La in t.result&&(this.extensions=new Extensions({schema:t.result.extensions}))}toSchema(){const e=new Sequence({value:[new Integer({value:this.version}),this.holder.toSchema(),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.issuer.toSchema().valueBlock.value}),this.signature.toSchema(),this.serialNumber,this.attrCertValidityPeriod.toSchema(),new Sequence({value:Array.from(this.attributes,e=>e.toSchema())})]});return this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){const e={version:this.version,holder:this.holder.toJSON(),issuer:this.issuer.toJSON(),signature:this.signature.toJSON(),serialNumber:this.serialNumber.toJSON(),attrCertValidityPeriod:this.attrCertValidityPeriod.toJSON(),attributes:Array.from(this.attributes,e=>e.toJSON())};return this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}}AttributeCertificateInfoV2.CLASS_NAME="AttributeCertificateInfoV2";const qa="acinfo",ja="signatureAlgorithm",Ma="signatureValue",Ja=[qa,ja,Ma];class AttributeCertificateV2 extends PkiObject{constructor(e={}){super(),this.acinfo=getParametersValue(e,qa,AttributeCertificateV2.defaultValues(qa)),this.signatureAlgorithm=getParametersValue(e,ja,AttributeCertificateV2.defaultValues(ja)),this.signatureValue=getParametersValue(e,Ma,AttributeCertificateV2.defaultValues(Ma)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case qa:return new AttributeCertificateInfoV2;case ja:return new AlgorithmIdentifier;case Ma:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[AttributeCertificateInfoV2.schema(t.acinfo||{}),AlgorithmIdentifier.schema(t.signatureAlgorithm||{}),new BitString({name:t.signatureValue||ke})]})}fromSchema(e){clearProps(e,Ja);const t=compareSchema(e,e,AttributeCertificateV2.schema({names:{acinfo:{names:{blockName:qa}},signatureAlgorithm:{names:{blockName:ja}},signatureValue:Ma}}));AsnError.assertSchema(t,this.className),this.acinfo=new AttributeCertificateInfoV2({schema:t.result.acinfo}),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new Sequence({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}AttributeCertificateV2.CLASS_NAME="AttributeCertificateV2";const _a="contentType",Fa="content",$a=[_a,Fa];class ContentInfo extends PkiObject{constructor(e={}){super(),this.contentType=getParametersValue(e,_a,ContentInfo.defaultValues(_a)),this.content=getParametersValue(e,Fa,ContentInfo.defaultValues(Fa)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case _a:return ke;case Fa:return new Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case _a:return"string"==typeof t&&t===this.defaultValues(_a);case Fa:return t instanceof Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return"optional"in t==!1&&(t.optional=!1),new Sequence({name:t.blockName||"ContentInfo",optional:t.optional,value:[new ObjectIdentifier({name:t.contentType||_a}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.content||Fa})]})]})}fromSchema(e){clearProps(e,$a);const t=compareSchema(e,e,ContentInfo.schema());AsnError.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.content=t.result.content}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.contentType}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.content]})]})}toJSON(){const e={contentType:this.contentType};return this.content instanceof Any||(e.content=this.content.toJSON()),e}}ContentInfo.CLASS_NAME="ContentInfo",ContentInfo.DATA=ht,ContentInfo.SIGNED_DATA=mt,ContentInfo.ENVELOPED_DATA=ft,ContentInfo.ENCRYPTED_DATA=gt;const Wa="type",Ga="value",za="utcTimeName",Qa="generalTimeName",Za=[za,Qa];var Ya;!function(e){e[e.UTCTime=0]="UTCTime",e[e.GeneralizedTime=1]="GeneralizedTime",e[e.empty=2]="empty"}(Ya||(Ya={}));class Time extends PkiObject{constructor(e={}){super(),this.type=getParametersValue(e,Wa,Time.defaultValues(Wa)),this.value=getParametersValue(e,Ga,Time.defaultValues(Ga)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Wa:return 0;case Ga:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={},t=!1){const r=getParametersValue(e,"names",{});return new Choice({optional:t,value:[new UTCTime({name:r.utcTimeName||ke}),new GeneralizedTime({name:r.generalTimeName||ke})]})}fromSchema(e){clearProps(e,Za);const t=compareSchema(e,e,Time.schema({names:{utcTimeName:za,generalTimeName:Qa}}));AsnError.assertSchema(t,this.className),za in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),Qa in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){return 0===this.type?new UTCTime({valueDate:this.value}):1===this.type?new GeneralizedTime({valueDate:this.value}):{}}toJSON(){return{type:this.type,value:this.value}}}Time.CLASS_NAME="Time";const Xa="tbs",ei="version",ti="serialNumber",ri="signature",si="issuer",ai="notBefore",ii="notAfter",ni="subject",oi="subjectPublicKeyInfo",li="issuerUniqueID",ci="subjectUniqueID",ui="extensions",hi="signatureAlgorithm",mi="signatureValue",fi="tbsCertificate",gi=`${fi}.${ei}`,di=`${fi}.${ti}`,pi=`${fi}.${ri}`,Si=`${fi}.${si}`,yi=`${fi}.${ai}`,wi=`${fi}.${ii}`,vi=`${fi}.${ni}`,bi=`${fi}.${oi}`,Ai=`${fi}.${li}`,ki=`${fi}.${ci}`,Ci=`${fi}.${ui}`,Vi=[fi,gi,di,pi,Si,yi,wi,vi,bi,Ai,ki,Ci,hi,mi];function tbsCertificate(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||fi,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Integer({name:t.tbsCertificateVersion||gi})]}),new Integer({name:t.tbsCertificateSerialNumber||di}),AlgorithmIdentifier.schema(t.signature||{names:{blockName:pi}}),RelativeDistinguishedNames.schema(t.issuer||{names:{blockName:Si}}),new Sequence({name:t.tbsCertificateValidity||"tbsCertificate.validity",value:[Time.schema(t.notBefore||{names:{utcTimeName:yi,generalTimeName:yi}}),Time.schema(t.notAfter||{names:{utcTimeName:wi,generalTimeName:wi}})]}),RelativeDistinguishedNames.schema(t.subject||{names:{blockName:vi}}),PublicKeyInfo.schema(t.subjectPublicKeyInfo||{names:{blockName:bi}}),new Primitive({name:t.tbsCertificateIssuerUniqueID||Ai,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new Primitive({name:t.tbsCertificateSubjectUniqueID||ki,optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[Extensions.schema(t.extensions||{names:{blockName:Ci}})]})]})}class Certificate extends PkiObject{get tbs(){return BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(getParametersValue(e,Xa,Certificate.defaultValues(Xa))),this.version=getParametersValue(e,ei,Certificate.defaultValues(ei)),this.serialNumber=getParametersValue(e,ti,Certificate.defaultValues(ti)),this.signature=getParametersValue(e,ri,Certificate.defaultValues(ri)),this.issuer=getParametersValue(e,si,Certificate.defaultValues(si)),this.notBefore=getParametersValue(e,ai,Certificate.defaultValues(ai)),this.notAfter=getParametersValue(e,ii,Certificate.defaultValues(ii)),this.subject=getParametersValue(e,ni,Certificate.defaultValues(ni)),this.subjectPublicKeyInfo=getParametersValue(e,oi,Certificate.defaultValues(oi)),li in e&&(this.issuerUniqueID=getParametersValue(e,li,Certificate.defaultValues(li))),ci in e&&(this.subjectUniqueID=getParametersValue(e,ci,Certificate.defaultValues(ci))),ui in e&&(this.extensions=getParametersValue(e,ui,Certificate.defaultValues(ui))),this.signatureAlgorithm=getParametersValue(e,hi,Certificate.defaultValues(hi)),this.signatureValue=getParametersValue(e,mi,Certificate.defaultValues(mi)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Xa:return Ae;case ei:return 0;case ti:return new Integer;case ri:return new AlgorithmIdentifier;case si:return new RelativeDistinguishedNames;case ai:case ii:return new Time;case ni:return new RelativeDistinguishedNames;case oi:return new PublicKeyInfo;case li:case ci:return Ae;case ui:return[];case hi:return new AlgorithmIdentifier;case mi:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[tbsCertificate(t.tbsCertificate),AlgorithmIdentifier.schema(t.signatureAlgorithm||{names:{blockName:hi}}),new BitString({name:t.signatureValue||mi})]})}fromSchema(e){clearProps(e,Vi);const t=compareSchema(e,e,Certificate.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:Ci}}}}}}));AsnError.assertSchema(t,this.className),this.tbsView=t.result.tbsCertificate.valueBeforeDecodeView,gi in t.result&&(this.version=t.result[gi].valueBlock.valueDec),this.serialNumber=t.result[di],this.signature=new AlgorithmIdentifier({schema:t.result[pi]}),this.issuer=new RelativeDistinguishedNames({schema:t.result[Si]}),this.notBefore=new Time({schema:t.result[yi]}),this.notAfter=new Time({schema:t.result[wi]}),this.subject=new RelativeDistinguishedNames({schema:t.result[vi]}),this.subjectPublicKeyInfo=new PublicKeyInfo({schema:t.result[bi]}),Ai in t.result&&(this.issuerUniqueID=t.result[Ai].valueBlock.valueHex),ki in t.result&&(this.subjectUniqueID=t.result[ki].valueBlock.valueHex),Ci in t.result&&(this.extensions=Array.from(t.result[Ci],e=>new Extension({schema:e}))),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return ei in this&&this.version!==Certificate.defaultValues(ei)&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Integer({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new Sequence({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),this.issuerUniqueID&&e.push(new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),this.subjectUniqueID&&e.push(new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),this.extensions&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new Sequence({value:Array.from(this.extensions,e=>e.toSchema())})]})),new Sequence({value:e})}toSchema(e=!1){let t;if(!1===e){if(!this.tbsView.byteLength)return Certificate.schema().value[0];const e=fromBER(this.tbsView);AsnError.assert(e,"TBS Certificate"),t=e.result}else t=this.encodeTBS();return new Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:Convert.ToHex(this.tbsView),version:this.version,serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return ei in this&&this.version!==Certificate.defaultValues(ei)&&(e.version=this.version),this.issuerUniqueID&&(e.issuerUniqueID=Convert.ToHex(this.issuerUniqueID)),this.subjectUniqueID&&(e.subjectUniqueID=Convert.ToHex(this.subjectUniqueID)),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}async getPublicKey(e,t=getCrypto(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}async getKeyHash(e="SHA-1",t=getCrypto(!0)){return t.digest({name:e},this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView)}async sign(e,t="SHA-1",r=getCrypto(!0)){if(!e)throw new Error("Need to provide a private key for signing");const s=await r.getSignatureParameters(e,t),a=s.parameters;this.signature=s.signatureAlgorithm,this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());const i=await r.signWithPrivateKey(this.tbsView,e,a);this.signatureValue=new BitString({valueHex:i})}async verify(e,t=getCrypto(!0)){let r;if(e?r=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(r=this.subjectPublicKeyInfo),!(r instanceof PublicKeyInfo))throw new Error("Please provide issuer certificate as a parameter");return t.verifyWithPublicKey(this.tbsView,this.signatureValue,r,this.signatureAlgorithm)}}function checkCA(e,t=null){if(t&&e.issuer.isEqual(t.issuer)&&e.serialNumber.isEqual(t.serialNumber))return null;let r=!1;if(e.extensions)for(const t of e.extensions)if(t.extnID===Xe&&t.parsedValue instanceof BasicConstraints&&t.parsedValue.cA){r=!0;break}return r?e:null}Certificate.CLASS_NAME="Certificate";const Bi="certId",Ii="certValue",Ni="parsedValue",Pi=[Bi,Ii];class CertBag extends PkiObject{constructor(e={}){super(),this.certId=getParametersValue(e,Bi,CertBag.defaultValues(Bi)),this.certValue=getParametersValue(e,Ii,CertBag.defaultValues(Ii)),Ni in e&&(this.parsedValue=getParametersValue(e,Ni,CertBag.defaultValues(Ni))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Bi:return ke;case Ii:return new Any;case Ni:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Bi:return t===ke;case Ii:return t instanceof Any;case Ni:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.id||"id"}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.value||"value"})]})]})}fromSchema(e){clearProps(e,Pi);const t=compareSchema(e,e,CertBag.schema({names:{id:Bi,value:Ii}}));AsnError.assertSchema(t,this.className),this.certId=t.result.certId.valueBlock.toString(),this.certValue=t.result.certValue;const r=this.certValue.valueBlock.valueHexView;switch(this.certId){case dt:try{this.parsedValue=Certificate.fromBER(r)}catch(e){AttributeCertificateV2.fromBER(r)}break;case pt:this.parsedValue=AttributeCertificateV2.fromBER(r);break;default:throw new Error(`Incorrect CERT_ID value in CertBag: ${this.certId}`)}}toSchema(){return Ni in this&&("acinfo"in this.parsedValue?this.certId=pt:this.certId=dt,this.certValue=new OctetString({valueHex:this.parsedValue.toSchema().toBER(!1)})),new Sequence({value:[new ObjectIdentifier({value:this.certId}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:["toSchema"in this.certValue?this.certValue.toSchema():this.certValue]})]})}toJSON(){return{certId:this.certId,certValue:this.certValue.toJSON()}}}CertBag.CLASS_NAME="CertBag";const Ei="userCertificate",Di="revocationDate",Oi="crlEntryExtensions",xi=[Ei,Di,Oi];class RevokedCertificate extends PkiObject{constructor(e={}){super(),this.userCertificate=getParametersValue(e,Ei,RevokedCertificate.defaultValues(Ei)),this.revocationDate=getParametersValue(e,Di,RevokedCertificate.defaultValues(Di)),Oi in e&&(this.crlEntryExtensions=getParametersValue(e,Oi,RevokedCertificate.defaultValues(Oi))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ei:return new Integer;case Di:return new Time;case Oi:return new Extensions;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.userCertificate||Ei}),Time.schema({names:{utcTimeName:t.revocationDate||Di,generalTimeName:t.revocationDate||Di}}),Extensions.schema({names:{blockName:t.crlEntryExtensions||Oi}},!0)]})}fromSchema(e){clearProps(e,xi);const t=compareSchema(e,e,RevokedCertificate.schema());AsnError.assertSchema(t,this.className),this.userCertificate=t.result.userCertificate,this.revocationDate=new Time({schema:t.result.revocationDate}),Oi in t.result&&(this.crlEntryExtensions=new Extensions({schema:t.result.crlEntryExtensions}))}toSchema(){const e=[this.userCertificate,this.revocationDate.toSchema()];return this.crlEntryExtensions&&e.push(this.crlEntryExtensions.toSchema()),new Sequence({value:e})}toJSON(){const e={userCertificate:this.userCertificate.toJSON(),revocationDate:this.revocationDate.toJSON()};return this.crlEntryExtensions&&(e.crlEntryExtensions=this.crlEntryExtensions.toJSON()),e}}RevokedCertificate.CLASS_NAME="RevokedCertificate";const Ri="tbs",Ki="version",Ui="signature",Ti="issuer",Li="thisUpdate",Hi="nextUpdate",qi="revokedCertificates",ji="crlExtensions",Mi="signatureAlgorithm",Ji="signatureValue",_i="tbsCertList",Fi=`${_i}.version`,$i=`${_i}.signature`,Wi=`${_i}.issuer`,Gi=`${_i}.thisUpdate`,zi=`${_i}.nextUpdate`,Qi=`${_i}.revokedCertificates`,Zi=`${_i}.extensions`,Yi=[_i,Fi,$i,Wi,Gi,zi,Qi,Zi,Mi,Ji];function tbsCertList(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||_i,value:[new Integer({optional:!0,name:t.tbsCertListVersion||Fi,value:2}),AlgorithmIdentifier.schema(t.signature||{names:{blockName:$i}}),RelativeDistinguishedNames.schema(t.issuer||{names:{blockName:Wi}}),Time.schema(t.tbsCertListThisUpdate||{names:{utcTimeName:Gi,generalTimeName:Gi}}),Time.schema(t.tbsCertListNextUpdate||{names:{utcTimeName:zi,generalTimeName:zi}},!0),new Sequence({optional:!0,value:[new Repeated({name:t.tbsCertListRevokedCertificates||Qi,value:new Sequence({value:[new Integer,Time.schema(),Extensions.schema({},!0)]})})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Extensions.schema(t.crlExtensions||{names:{blockName:Zi}})]})]})}const Xi=[lt,Ye,"2.5.29.20","2.5.29.27",et,at,ut,"2.5.29.21","2.5.29.24",tt];class CertificateRevocationList extends PkiObject{get tbs(){return BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(getParametersValue(e,Ri,CertificateRevocationList.defaultValues(Ri))),this.version=getParametersValue(e,Ki,CertificateRevocationList.defaultValues(Ki)),this.signature=getParametersValue(e,Ui,CertificateRevocationList.defaultValues(Ui)),this.issuer=getParametersValue(e,Ti,CertificateRevocationList.defaultValues(Ti)),this.thisUpdate=getParametersValue(e,Li,CertificateRevocationList.defaultValues(Li)),Hi in e&&(this.nextUpdate=getParametersValue(e,Hi,CertificateRevocationList.defaultValues(Hi))),qi in e&&(this.revokedCertificates=getParametersValue(e,qi,CertificateRevocationList.defaultValues(qi))),ji in e&&(this.crlExtensions=getParametersValue(e,ji,CertificateRevocationList.defaultValues(ji))),this.signatureAlgorithm=getParametersValue(e,Mi,CertificateRevocationList.defaultValues(Mi)),this.signatureValue=getParametersValue(e,Ji,CertificateRevocationList.defaultValues(Ji)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ri:return Ae;case Ki:return 0;case Ui:return new AlgorithmIdentifier;case Ti:return new RelativeDistinguishedNames;case Li:case Hi:return new Time;case qi:return[];case ji:return new Extensions;case Mi:return new AlgorithmIdentifier;case Ji:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||"CertificateList",value:[tbsCertList(e),AlgorithmIdentifier.schema(t.signatureAlgorithm||{names:{blockName:Mi}}),new BitString({name:t.signatureValue||Ji})]})}fromSchema(e){clearProps(e,Yi);const t=compareSchema(e,e,CertificateRevocationList.schema());AsnError.assertSchema(t,this.className),this.tbsView=t.result.tbsCertList.valueBeforeDecodeView,Fi in t.result&&(this.version=t.result[Fi].valueBlock.valueDec),this.signature=new AlgorithmIdentifier({schema:t.result[$i]}),this.issuer=new RelativeDistinguishedNames({schema:t.result[Wi]}),this.thisUpdate=new Time({schema:t.result[Gi]}),zi in t.result&&(this.nextUpdate=new Time({schema:t.result[zi]})),Qi in t.result&&(this.revokedCertificates=Array.from(t.result[Qi],e=>new RevokedCertificate({schema:e}))),Zi in t.result&&(this.crlExtensions=new Extensions({schema:t.result[Zi]})),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return this.version!==CertificateRevocationList.defaultValues(Ki)&&e.push(new Integer({value:this.version})),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(this.thisUpdate.toSchema()),this.nextUpdate&&e.push(this.nextUpdate.toSchema()),this.revokedCertificates&&e.push(new Sequence({value:Array.from(this.revokedCertificates,e=>e.toSchema())})),this.crlExtensions&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.crlExtensions.toSchema()]})),new Sequence({value:e})}toSchema(e=!1){let t;if(e)t=this.encodeTBS();else{if(!this.tbsView.byteLength)return CertificateRevocationList.schema();const e=fromBER(this.tbsView);AsnError.assert(e,"TBS Certificate Revocation List"),t=e.result}return new Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:Convert.ToHex(this.tbsView),version:this.version,signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),thisUpdate:this.thisUpdate.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return this.version!==CertificateRevocationList.defaultValues(Ki)&&(e.version=this.version),this.nextUpdate&&(e.nextUpdate=this.nextUpdate.toJSON()),this.revokedCertificates&&(e.revokedCertificates=Array.from(this.revokedCertificates,e=>e.toJSON())),this.crlExtensions&&(e.crlExtensions=this.crlExtensions.toJSON()),e}isCertificateRevoked(e){if(!this.issuer.isEqual(e.issuer))return!1;if(!this.revokedCertificates)return!1;for(const t of this.revokedCertificates)if(t.userCertificate.isEqual(e.serialNumber))return!0;return!1}async sign(e,t="SHA-1",r=getCrypto(!0)){if(!e)throw new Error("Need to provide a private key for signing");const s=await r.getSignatureParameters(e,t),{parameters:a}=s;this.signature=s.signatureAlgorithm,this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());const i=await r.signWithPrivateKey(this.tbsView,e,a);this.signatureValue=new BitString({valueHex:i})}async verify(e={},t=getCrypto(!0)){let r;if(e.issuerCertificate&&(r=e.issuerCertificate.subjectPublicKeyInfo,!this.issuer.isEqual(e.issuerCertificate.subject)))return!1;if(e.publicKeyInfo&&(r=e.publicKeyInfo),!r)throw new Error("Issuer's certificate must be provided as an input parameter");if(this.crlExtensions)for(const e of this.crlExtensions.extensions)if(e.critical&&!Xi.includes(e.extnID))return!1;return t.verifyWithPublicKey(this.tbsView,this.signatureValue,r,this.signatureAlgorithm)}}CertificateRevocationList.CLASS_NAME="CertificateRevocationList";const en="crlId",tn="crlValue",rn="parsedValue",sn=[en,tn];class CRLBag extends PkiObject{constructor(e={}){super(),this.crlId=getParametersValue(e,en,CRLBag.defaultValues(en)),this.crlValue=getParametersValue(e,tn,CRLBag.defaultValues(tn)),rn in e&&(this.parsedValue=getParametersValue(e,rn,CRLBag.defaultValues(rn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case en:return ke;case tn:return new Any;case rn:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case en:return t===ke;case tn:return t instanceof Any;case rn:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.id||"id"}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.value||"value"})]})]})}fromSchema(e){clearProps(e,sn);const t=compareSchema(e,e,CRLBag.schema({names:{id:en,value:tn}}));if(AsnError.assertSchema(t,this.className),this.crlId=t.result.crlId.valueBlock.toString(),this.crlValue=t.result.crlValue,this.crlId!==St)throw new Error(`Incorrect CRL_ID value in CRLBag: ${this.crlId}`);this.parsedValue=CertificateRevocationList.fromBER(this.certValue.valueBlock.valueHex)}toSchema(){return this.parsedValue&&(this.crlId=St,this.crlValue=new OctetString({valueHex:this.parsedValue.toSchema().toBER(!1)})),new Sequence({value:[new ObjectIdentifier({value:this.crlId}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.crlValue.toSchema()]})]})}toJSON(){return{crlId:this.crlId,crlValue:this.crlValue.toJSON()}}}CRLBag.CLASS_NAME="CRLBag";const an="version",nn="encryptedContentInfo",on="unprotectedAttrs",ln=[an,nn,on];class EncryptedData extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,an,EncryptedData.defaultValues(an)),this.encryptedContentInfo=getParametersValue(e,nn,EncryptedData.defaultValues(nn)),on in e&&(this.unprotectedAttrs=getParametersValue(e,on,EncryptedData.defaultValues(on))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case an:return 0;case nn:return new EncryptedContentInfo;case on:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case an:return 0===t;case nn:return EncryptedContentInfo.compareWithDefault("contentType",t.contentType)&&EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&EncryptedContentInfo.compareWithDefault("encryptedContent",t.encryptedContent);case on:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||ke}),EncryptedContentInfo.schema(t.encryptedContentInfo||{}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Repeated({name:t.unprotectedAttrs||ke,value:Attribute.schema()})]})]})}fromSchema(e){clearProps(e,ln);const t=compareSchema(e,e,EncryptedData.schema({names:{version:an,encryptedContentInfo:{names:{blockName:nn}},unprotectedAttrs:on}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.encryptedContentInfo=new EncryptedContentInfo({schema:t.result.encryptedContentInfo}),on in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new Attribute({schema:e})))}toSchema(){const e=[];return e.push(new Integer({value:this.version})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={version:this.version,encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}async encrypt(e,t=getCrypto(!0)){ArgumentError.assert(e,"parameters","object");const r={...e,contentType:"1.2.840.113549.1.7.1"};this.encryptedContentInfo=await t.encryptEncryptedContentInfo(r)}async decrypt(e,t=getCrypto(!0)){ArgumentError.assert(e,"parameters","object");const r={...e,encryptedContentInfo:this.encryptedContentInfo};return t.decryptEncryptedContentInfo(r)}}EncryptedData.CLASS_NAME="EncryptedData";const cn="encryptionAlgorithm",un="encryptedData",hn="parsedValue",mn=[cn,un];class PKCS8ShroudedKeyBag extends PkiObject{constructor(e={}){super(),this.encryptionAlgorithm=getParametersValue(e,cn,PKCS8ShroudedKeyBag.defaultValues(cn)),this.encryptedData=getParametersValue(e,un,PKCS8ShroudedKeyBag.defaultValues(un)),hn in e&&(this.parsedValue=getParametersValue(e,hn,PKCS8ShroudedKeyBag.defaultValues(hn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case cn:return new AlgorithmIdentifier;case un:return new OctetString;case hn:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case cn:return AlgorithmIdentifier.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case un:return t.isEqual(PKCS8ShroudedKeyBag.defaultValues(e));case hn:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[AlgorithmIdentifier.schema(t.encryptionAlgorithm||{names:{blockName:cn}}),new Choice({value:[new OctetString({name:t.encryptedData||un}),new OctetString({idBlock:{isConstructed:!0},name:t.encryptedData||un})]})]})}fromSchema(e){clearProps(e,mn);const t=compareSchema(e,e,PKCS8ShroudedKeyBag.schema({names:{encryptionAlgorithm:{names:{blockName:cn}},encryptedData:un}}));AsnError.assertSchema(t,this.className),this.encryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.encryptionAlgorithm}),this.encryptedData=t.result.encryptedData}toSchema(){return new Sequence({value:[this.encryptionAlgorithm.toSchema(),this.encryptedData]})}toJSON(){return{encryptionAlgorithm:this.encryptionAlgorithm.toJSON(),encryptedData:this.encryptedData.toJSON()}}async parseInternalValues(e,t=getCrypto(!0)){const r=new EncryptedData({encryptedContentInfo:new EncryptedContentInfo({contentEncryptionAlgorithm:this.encryptionAlgorithm,encryptedContent:this.encryptedData})}),s=await r.decrypt(e,t);this.parsedValue=PrivateKeyInfo.fromBER(s)}async makeInternalValues(e,t=getCrypto(!0)){if(!this.parsedValue)throw new Error('Please initialize "parsedValue" first');const r=new EncryptedData,s={...e,contentToEncrypt:this.parsedValue.toSchema().toBER(!1)};if(await r.encrypt(s,t),!r.encryptedContentInfo.encryptedContent)throw new Error("The filed `encryptedContent` in EncryptedContentInfo is empty");this.encryptionAlgorithm=r.encryptedContentInfo.contentEncryptionAlgorithm,this.encryptedData=r.encryptedContentInfo.encryptedContent}}PKCS8ShroudedKeyBag.CLASS_NAME="PKCS8ShroudedKeyBag";const fn="secretTypeId",gn="secretValue",dn=[fn,gn];class SecretBag extends PkiObject{constructor(e={}){super(),this.secretTypeId=getParametersValue(e,fn,SecretBag.defaultValues(fn)),this.secretValue=getParametersValue(e,gn,SecretBag.defaultValues(gn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case fn:return ke;case gn:return new Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case fn:return t===ke;case gn:return t instanceof Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.id||"id"}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.value||"value"})]})]})}fromSchema(e){clearProps(e,dn);const t=compareSchema(e,e,SecretBag.schema({names:{id:fn,value:gn}}));AsnError.assertSchema(t,this.className),this.secretTypeId=t.result.secretTypeId.valueBlock.toString(),this.secretValue=t.result.secretValue}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.secretTypeId}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.secretValue.toSchema()]})]})}toJSON(){return{secretTypeId:this.secretTypeId,secretValue:this.secretValue.toJSON()}}}SecretBag.CLASS_NAME="SecretBag";class SafeBagValueFactory{static getItems(){return this.items||(this.items={},SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.1",PrivateKeyInfo),SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.2",PKCS8ShroudedKeyBag),SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.3",CertBag),SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.4",CRLBag),SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.5",SecretBag),SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.6",SafeContents)),this.items}static register(e,t){this.getItems()[e]=t}static find(e){return this.getItems()[e]||null}}const pn="bagId",Sn="bagValue",yn="bagAttributes",wn=[pn,Sn,yn];class SafeBag extends PkiObject{constructor(e={}){super(),this.bagId=getParametersValue(e,pn,SafeBag.defaultValues(pn)),this.bagValue=getParametersValue(e,Sn,SafeBag.defaultValues(Sn)),yn in e&&(this.bagAttributes=getParametersValue(e,yn,SafeBag.defaultValues(yn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case pn:return ke;case Sn:return new Any;case yn:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case pn:return t===ke;case Sn:return t instanceof Any;case yn:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.bagId||pn}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.bagValue||Sn})]}),new Set({optional:!0,value:[new Repeated({name:t.bagAttributes||yn,value:Attribute.schema()})]})]})}fromSchema(e){clearProps(e,wn);const t=compareSchema(e,e,SafeBag.schema({names:{bagId:pn,bagValue:Sn,bagAttributes:yn}}));AsnError.assertSchema(t,this.className),this.bagId=t.result.bagId.valueBlock.toString();const r=SafeBagValueFactory.find(this.bagId);if(!r)throw new Error(`Invalid BAG_ID for SafeBag: ${this.bagId}`);this.bagValue=new r({schema:t.result.bagValue}),yn in t.result&&(this.bagAttributes=Array.from(t.result.bagAttributes,e=>new Attribute({schema:e})))}toSchema(){const e=[new ObjectIdentifier({value:this.bagId}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.bagValue.toSchema()]})];return this.bagAttributes&&e.push(new Set({value:Array.from(this.bagAttributes,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={bagId:this.bagId,bagValue:this.bagValue.toJSON()};return this.bagAttributes&&(e.bagAttributes=Array.from(this.bagAttributes,e=>e.toJSON())),e}}SafeBag.CLASS_NAME="SafeBag";const vn="safeBags";class SafeContents extends PkiObject{constructor(e={}){super(),this.safeBags=getParametersValue(e,vn,SafeContents.defaultValues(vn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===vn?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===vn?0===t.length:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.safeBags||ke,value:SafeBag.schema()})]})}fromSchema(e){clearProps(e,[vn]);const t=compareSchema(e,e,SafeContents.schema({names:{safeBags:vn}}));AsnError.assertSchema(t,this.className),this.safeBags=Array.from(t.result.safeBags,e=>new SafeBag({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.safeBags,e=>e.toSchema())})}toJSON(){return{safeBags:Array.from(this.safeBags,e=>e.toJSON())}}}SafeContents.CLASS_NAME="SafeContents";const bn="otherCertFormat",An="otherCert",kn=[bn,An];class OtherCertificateFormat extends PkiObject{constructor(e={}){super(),this.otherCertFormat=getParametersValue(e,bn,OtherCertificateFormat.defaultValues(bn)),this.otherCert=getParametersValue(e,An,OtherCertificateFormat.defaultValues(An)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case bn:return ke;case An:return new Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.otherCertFormat||bn}),new Any({name:t.otherCert||An})]})}fromSchema(e){clearProps(e,kn);const t=compareSchema(e,e,OtherCertificateFormat.schema());AsnError.assertSchema(t,this.className),this.otherCertFormat=t.result.otherCertFormat.valueBlock.toString(),this.otherCert=t.result.otherCert}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.otherCertFormat}),this.otherCert]})}toJSON(){const e={otherCertFormat:this.otherCertFormat};return this.otherCert instanceof Any||(e.otherCert=this.otherCert.toJSON()),e}}const Cn="certificates",Vn=[Cn];class CertificateSet extends PkiObject{constructor(e={}){super(),this.certificates=getParametersValue(e,Cn,CertificateSet.defaultValues(Cn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Cn?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Set({name:t.blockName||ke,value:[new Repeated({name:t.certificates||Cn,value:new Choice({value:[Certificate.schema(),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any]}),new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new Sequence]}),new Constructed({idBlock:{tagClass:3,tagNumber:2},value:AttributeCertificateV2.schema().valueBlock.value}),new Constructed({idBlock:{tagClass:3,tagNumber:3},value:OtherCertificateFormat.schema().valueBlock.value})]})})]})}fromSchema(e){clearProps(e,Vn);const t=compareSchema(e,e,CertificateSet.schema());AsnError.assertSchema(t,this.className),this.certificates=Array.from(t.result.certificates||[],e=>{const t=e.idBlock.tagNumber;if(1===e.idBlock.tagClass)return new Certificate({schema:e});const r=new Sequence({value:e.valueBlock.value});switch(t){case 1:return 1===r.valueBlock.value[0].valueBlock.value[0].valueBlock.valueDec?new AttributeCertificateV2({schema:r}):new AttributeCertificateV1({schema:r});case 2:return new AttributeCertificateV2({schema:r});case 3:return new OtherCertificateFormat({schema:r})}return e})}toSchema(){return new Set({value:Array.from(this.certificates,e=>{switch(!0){case e instanceof Certificate:return e.toSchema();case e instanceof AttributeCertificateV1:return new Constructed({idBlock:{tagClass:3,tagNumber:1},value:e.toSchema().valueBlock.value});case e instanceof AttributeCertificateV2:return new Constructed({idBlock:{tagClass:3,tagNumber:2},value:e.toSchema().valueBlock.value});case e instanceof OtherCertificateFormat:return new Constructed({idBlock:{tagClass:3,tagNumber:3},value:e.toSchema().valueBlock.value})}return e.toSchema()})})}toJSON(){return{certificates:Array.from(this.certificates,e=>e.toJSON())}}}CertificateSet.CLASS_NAME="CertificateSet";const Bn="otherRevInfoFormat",In="otherRevInfo",Nn=[Bn,In];class OtherRevocationInfoFormat extends PkiObject{constructor(e={}){super(),this.otherRevInfoFormat=getParametersValue(e,Bn,OtherRevocationInfoFormat.defaultValues(Bn)),this.otherRevInfo=getParametersValue(e,In,OtherRevocationInfoFormat.defaultValues(In)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Bn:return ke;case In:return new Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.otherRevInfoFormat||Bn}),new Any({name:t.otherRevInfo||In})]})}fromSchema(e){clearProps(e,Nn);const t=compareSchema(e,e,OtherRevocationInfoFormat.schema());AsnError.assertSchema(t,this.className),this.otherRevInfoFormat=t.result.otherRevInfoFormat.valueBlock.toString(),this.otherRevInfo=t.result.otherRevInfo}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.otherRevInfoFormat}),this.otherRevInfo]})}toJSON(){const e={otherRevInfoFormat:this.otherRevInfoFormat};return this.otherRevInfo instanceof Any||(e.otherRevInfo=this.otherRevInfo.toJSON()),e}}OtherRevocationInfoFormat.CLASS_NAME="OtherRevocationInfoFormat";const Pn="crls",En="otherRevocationInfos",Dn=[Pn];class RevocationInfoChoices extends PkiObject{constructor(e={}){super(),this.crls=getParametersValue(e,Pn,RevocationInfoChoices.defaultValues(Pn)),this.otherRevocationInfos=getParametersValue(e,En,RevocationInfoChoices.defaultValues(En)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Pn:case En:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Set({name:t.blockName||ke,value:[new Repeated({name:t.crls||ke,value:new Choice({value:[CertificateRevocationList.schema(),new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new ObjectIdentifier,new Any]})]})})]})}fromSchema(e){clearProps(e,Dn);const t=compareSchema(e,e,RevocationInfoChoices.schema({names:{crls:Pn}}));if(AsnError.assertSchema(t,this.className),t.result.crls)for(const e of t.result.crls)1===e.idBlock.tagClass?this.crls.push(new CertificateRevocationList({schema:e})):this.otherRevocationInfos.push(new OtherRevocationInfoFormat({schema:e}))}toSchema(){const e=[];return e.push(...Array.from(this.crls,e=>e.toSchema())),e.push(...Array.from(this.otherRevocationInfos,e=>{const t=e.toSchema();return t.idBlock.tagClass=3,t.idBlock.tagNumber=1,t})),new Set({value:e})}toJSON(){return{crls:Array.from(this.crls,e=>e.toJSON()),otherRevocationInfos:Array.from(this.otherRevocationInfos,e=>e.toJSON())}}}RevocationInfoChoices.CLASS_NAME="RevocationInfoChoices";const On="certs",xn="crls",Rn=[On,xn];class OriginatorInfo extends PkiObject{constructor(e={}){super(),this.crls=getParametersValue(e,xn,OriginatorInfo.defaultValues(xn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case On:return new CertificateSet;case xn:return new RevocationInfoChoices;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case On:return 0===t.certificates.length;case xn:return 0===t.crls.length&&0===t.otherRevocationInfos.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Constructed({name:t.certs||ke,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:CertificateSet.schema().valueBlock.value}),new Constructed({name:t.crls||ke,optional:!0,idBlock:{tagClass:3,tagNumber:1},value:RevocationInfoChoices.schema().valueBlock.value})]})}fromSchema(e){clearProps(e,Rn);const t=compareSchema(e,e,OriginatorInfo.schema({names:{certs:On,crls:xn}}));AsnError.assertSchema(t,this.className),On in t.result&&(this.certs=new CertificateSet({schema:new Set({value:t.result.certs.valueBlock.value})})),xn in t.result&&(this.crls=new RevocationInfoChoices({schema:new Set({value:t.result.crls.valueBlock.value})}))}toSchema(){const e=[];return this.certs&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.certs.toSchema().valueBlock.value})),this.crls&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.crls.toSchema().valueBlock.value})),new Sequence({value:e})}toJSON(){const e={};return this.certs&&(e.certs=this.certs.toJSON()),this.crls&&(e.crls=this.crls.toJSON()),e}}OriginatorInfo.CLASS_NAME="OriginatorInfo";const Kn="issuer",Un="serialNumber",Tn=[Kn,Un];class IssuerAndSerialNumber extends PkiObject{constructor(e={}){super(),this.issuer=getParametersValue(e,Kn,IssuerAndSerialNumber.defaultValues(Kn)),this.serialNumber=getParametersValue(e,Un,IssuerAndSerialNumber.defaultValues(Un)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Kn:return new RelativeDistinguishedNames;case Un:return new Integer;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[RelativeDistinguishedNames.schema(t.issuer||{}),new Integer({name:t.serialNumber||ke})]})}fromSchema(e){clearProps(e,Tn);const t=compareSchema(e,e,IssuerAndSerialNumber.schema({names:{issuer:{names:{blockName:Kn}},serialNumber:Un}}));AsnError.assertSchema(t,this.className),this.issuer=new RelativeDistinguishedNames({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber}toSchema(){return new Sequence({value:[this.issuer.toSchema(),this.serialNumber]})}toJSON(){return{issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()}}}IssuerAndSerialNumber.CLASS_NAME="IssuerAndSerialNumber";const Ln="variant",Hn="value",qn=["blockName"];class RecipientIdentifier extends PkiObject{constructor(e={}){super(),this.variant=getParametersValue(e,Ln,RecipientIdentifier.defaultValues(Ln)),Hn in e&&(this.value=getParametersValue(e,Hn,RecipientIdentifier.defaultValues(Hn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ln:return-1;case Hn:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ln:return-1===t;case Hn:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Choice({value:[IssuerAndSerialNumber.schema({names:{blockName:t.blockName||ke}}),new Primitive({name:t.blockName||ke,idBlock:{tagClass:3,tagNumber:0}})]})}fromSchema(e){clearProps(e,qn);const t=compareSchema(e,e,RecipientIdentifier.schema({names:{blockName:"blockName"}}));AsnError.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new IssuerAndSerialNumber({schema:t.result.blockName})):(this.variant=2,this.value=new OctetString({valueHex:t.result.blockName.valueBlock.valueHex}))}toSchema(){switch(this.variant){case 1:if(!(this.value instanceof IssuerAndSerialNumber))throw new Error("Incorrect type of RecipientIdentifier.value. It should be IssuerAndSerialNumber.");return this.value.toSchema();case 2:if(!(this.value instanceof OctetString))throw new Error("Incorrect type of RecipientIdentifier.value. It should be ASN.1 OctetString.");return new Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.value.valueBlock.valueHexView});default:return new Any}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant||!this.value||(e.value=this.value.toJSON()),e}}RecipientIdentifier.CLASS_NAME="RecipientIdentifier";const jn="version",Mn="rid",Jn="keyEncryptionAlgorithm",_n="encryptedKey",Fn="recipientCertificate",$n=[jn,Mn,Jn,_n];class KeyTransRecipientInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,jn,KeyTransRecipientInfo.defaultValues(jn)),this.rid=getParametersValue(e,Mn,KeyTransRecipientInfo.defaultValues(Mn)),this.keyEncryptionAlgorithm=getParametersValue(e,Jn,KeyTransRecipientInfo.defaultValues(Jn)),this.encryptedKey=getParametersValue(e,_n,KeyTransRecipientInfo.defaultValues(_n)),this.recipientCertificate=getParametersValue(e,Fn,KeyTransRecipientInfo.defaultValues(Fn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case jn:return-1;case Mn:return{};case Jn:return new AlgorithmIdentifier;case _n:return new OctetString;case Fn:return new Certificate;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case jn:return t===KeyTransRecipientInfo.defaultValues(jn);case Mn:return 0===Object.keys(t).length;case Jn:case _n:return t.isEqual(KeyTransRecipientInfo.defaultValues(e));case Fn:return!1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||ke}),RecipientIdentifier.schema(t.rid||{}),AlgorithmIdentifier.schema(t.keyEncryptionAlgorithm||{}),new OctetString({name:t.encryptedKey||ke})]})}fromSchema(e){clearProps(e,$n);const t=compareSchema(e,e,KeyTransRecipientInfo.schema({names:{version:jn,rid:{names:{blockName:Mn}},keyEncryptionAlgorithm:{names:{blockName:Jn}},encryptedKey:_n}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,3===t.result.rid.idBlock.tagClass?this.rid=new OctetString({valueHex:t.result.rid.valueBlock.valueHex}):this.rid=new IssuerAndSerialNumber({schema:t.result.rid}),this.keyEncryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){const e=[];return this.rid instanceof IssuerAndSerialNumber?(this.version=0,e.push(new Integer({value:this.version})),e.push(this.rid.toSchema())):(this.version=2,e.push(new Integer({value:this.version})),e.push(new Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.rid.valueBlock.valueHexView}))),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new Sequence({value:e})}toJSON(){return{version:this.version,rid:this.rid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}KeyTransRecipientInfo.CLASS_NAME="KeyTransRecipientInfo";const Wn="algorithm",Gn="publicKey",zn=[Wn,Gn];class OriginatorPublicKey extends PkiObject{constructor(e={}){super(),this.algorithm=getParametersValue(e,Wn,OriginatorPublicKey.defaultValues(Wn)),this.publicKey=getParametersValue(e,Gn,OriginatorPublicKey.defaultValues(Gn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Wn:return new AlgorithmIdentifier;case Gn:return new BitString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Wn:case Gn:return t.isEqual(OriginatorPublicKey.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[AlgorithmIdentifier.schema(t.algorithm||{}),new BitString({name:t.publicKey||ke})]})}fromSchema(e){clearProps(e,zn);const t=compareSchema(e,e,OriginatorPublicKey.schema({names:{algorithm:{names:{blockName:Wn}},publicKey:Gn}}));AsnError.assertSchema(t,this.className),this.algorithm=new AlgorithmIdentifier({schema:t.result.algorithm}),this.publicKey=t.result.publicKey}toSchema(){return new Sequence({value:[this.algorithm.toSchema(),this.publicKey]})}toJSON(){return{algorithm:this.algorithm.toJSON(),publicKey:this.publicKey.toJSON()}}}OriginatorPublicKey.CLASS_NAME="OriginatorPublicKey";const Qn="variant",Zn="value",Yn=["blockName"];class OriginatorIdentifierOrKey extends PkiObject{constructor(e={}){super(),this.variant=getParametersValue(e,Qn,OriginatorIdentifierOrKey.defaultValues(Qn)),Zn in e&&(this.value=getParametersValue(e,Zn,OriginatorIdentifierOrKey.defaultValues(Zn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Qn:return-1;case Zn:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Qn:return-1===t;case Zn:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Choice({value:[IssuerAndSerialNumber.schema({names:{blockName:t.blockName||ke}}),new Primitive({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||ke}),new Constructed({idBlock:{tagClass:3,tagNumber:1},name:t.blockName||ke,value:OriginatorPublicKey.schema().valueBlock.value})]})}fromSchema(e){clearProps(e,Yn);const t=compareSchema(e,e,OriginatorIdentifierOrKey.schema({names:{blockName:"blockName"}}));AsnError.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new IssuerAndSerialNumber({schema:t.result.blockName})):0===t.result.blockName.idBlock.tagNumber?(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=4,this.variant=2,this.value=t.result.blockName):(this.variant=3,this.value=new OriginatorPublicKey({schema:new Sequence({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return this.value.idBlock.tagClass=3,this.value.idBlock.tagNumber=0,this.value;case 3:{const e=this.value.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}default:return new Any}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant&&3!==this.variant||(e.value=this.value.toJSON()),e}}OriginatorIdentifierOrKey.CLASS_NAME="OriginatorIdentifierOrKey";const Xn="keyAttrId",eo="keyAttr",to=[Xn,eo];class OtherKeyAttribute extends PkiObject{constructor(e={}){super(),this.keyAttrId=getParametersValue(e,Xn,OtherKeyAttribute.defaultValues(Xn)),eo in e&&(this.keyAttr=getParametersValue(e,eo,OtherKeyAttribute.defaultValues(eo))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Xn:return ke;case eo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Xn:return"string"==typeof t&&t===ke;case eo:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({optional:t.optional||!0,name:t.blockName||ke,value:[new ObjectIdentifier({name:t.keyAttrId||ke}),new Any({optional:!0,name:t.keyAttr||ke})]})}fromSchema(e){clearProps(e,to);const t=compareSchema(e,e,OtherKeyAttribute.schema({names:{keyAttrId:Xn,keyAttr:eo}}));AsnError.assertSchema(t,this.className),this.keyAttrId=t.result.keyAttrId.valueBlock.toString(),eo in t.result&&(this.keyAttr=t.result.keyAttr)}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.keyAttrId})),eo in this&&e.push(this.keyAttr),new Sequence({value:e})}toJSON(){const e={keyAttrId:this.keyAttrId};return eo in this&&(e.keyAttr=this.keyAttr.toJSON()),e}}OtherKeyAttribute.CLASS_NAME="OtherKeyAttribute";const ro="subjectKeyIdentifier",so="date",ao="other",io=[ro,so,ao];class RecipientKeyIdentifier extends PkiObject{constructor(e={}){super(),this.subjectKeyIdentifier=getParametersValue(e,ro,RecipientKeyIdentifier.defaultValues(ro)),so in e&&(this.date=getParametersValue(e,so,RecipientKeyIdentifier.defaultValues(so))),ao in e&&(this.other=getParametersValue(e,ao,RecipientKeyIdentifier.defaultValues(ao))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ro:return new OctetString;case so:return new GeneralizedTime;case ao:return new OtherKeyAttribute;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ro:return t.isEqual(RecipientKeyIdentifier.defaultValues(ro));case so:return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case ao:return t.keyAttrId===ke&&"keyAttr"in t==!1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new OctetString({name:t.subjectKeyIdentifier||ke}),new GeneralizedTime({optional:!0,name:t.date||ke}),OtherKeyAttribute.schema(t.other||{})]})}fromSchema(e){clearProps(e,io);const t=compareSchema(e,e,RecipientKeyIdentifier.schema({names:{subjectKeyIdentifier:ro,date:so,other:{names:{blockName:ao}}}}));AsnError.assertSchema(t,this.className),this.subjectKeyIdentifier=t.result.subjectKeyIdentifier,so in t.result&&(this.date=t.result.date),ao in t.result&&(this.other=new OtherKeyAttribute({schema:t.result.other}))}toSchema(){const e=[];return e.push(this.subjectKeyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new Sequence({value:e})}toJSON(){const e={subjectKeyIdentifier:this.subjectKeyIdentifier.toJSON()};return this.date&&(e.date=this.date.toJSON()),this.other&&(e.other=this.other.toJSON()),e}}RecipientKeyIdentifier.CLASS_NAME="RecipientKeyIdentifier";const no="variant",oo="value",lo=["blockName"];class KeyAgreeRecipientIdentifier extends PkiObject{constructor(e={}){super(),this.variant=getParametersValue(e,no,KeyAgreeRecipientIdentifier.defaultValues(no)),this.value=getParametersValue(e,oo,KeyAgreeRecipientIdentifier.defaultValues(oo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case no:return-1;case oo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case no:return-1===t;case oo:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Choice({value:[IssuerAndSerialNumber.schema(t.issuerAndSerialNumber||{names:{blockName:t.blockName||ke}}),new Constructed({name:t.blockName||ke,idBlock:{tagClass:3,tagNumber:0},value:RecipientKeyIdentifier.schema(t.rKeyId||{names:{blockName:t.blockName||ke}}).valueBlock.value})]})}fromSchema(e){clearProps(e,lo);const t=compareSchema(e,e,KeyAgreeRecipientIdentifier.schema({names:{blockName:"blockName"}}));AsnError.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new IssuerAndSerialNumber({schema:t.result.blockName})):(this.variant=2,this.value=new RecipientKeyIdentifier({schema:new Sequence({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.value.toSchema().valueBlock.value});default:return new Any}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant||(e.value=this.value.toJSON()),e}}KeyAgreeRecipientIdentifier.CLASS_NAME="KeyAgreeRecipientIdentifier";const co="rid",uo="encryptedKey",ho=[co,uo];class RecipientEncryptedKey extends PkiObject{constructor(e={}){super(),this.rid=getParametersValue(e,co,RecipientEncryptedKey.defaultValues(co)),this.encryptedKey=getParametersValue(e,uo,RecipientEncryptedKey.defaultValues(uo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case co:return new KeyAgreeRecipientIdentifier;case uo:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case co:return-1===t.variant&&"value"in t==!1;case uo:return t.isEqual(RecipientEncryptedKey.defaultValues(uo));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[KeyAgreeRecipientIdentifier.schema(t.rid||{}),new OctetString({name:t.encryptedKey||ke})]})}fromSchema(e){clearProps(e,ho);const t=compareSchema(e,e,RecipientEncryptedKey.schema({names:{rid:{names:{blockName:co}},encryptedKey:uo}}));AsnError.assertSchema(t,this.className),this.rid=new KeyAgreeRecipientIdentifier({schema:t.result.rid}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new Sequence({value:[this.rid.toSchema(),this.encryptedKey]})}toJSON(){return{rid:this.rid.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}RecipientEncryptedKey.CLASS_NAME="RecipientEncryptedKey";const mo="encryptedKeys",fo="RecipientEncryptedKeys",go=[fo];class RecipientEncryptedKeys extends PkiObject{constructor(e={}){super(),this.encryptedKeys=getParametersValue(e,mo,RecipientEncryptedKeys.defaultValues(mo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===mo?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===mo?0===t.length:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.RecipientEncryptedKeys||ke,value:RecipientEncryptedKey.schema()})]})}fromSchema(e){clearProps(e,go);const t=compareSchema(e,e,RecipientEncryptedKeys.schema({names:{RecipientEncryptedKeys:fo}}));AsnError.assertSchema(t,this.className),this.encryptedKeys=Array.from(t.result.RecipientEncryptedKeys,e=>new RecipientEncryptedKey({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.encryptedKeys,e=>e.toSchema())})}toJSON(){return{encryptedKeys:Array.from(this.encryptedKeys,e=>e.toJSON())}}}RecipientEncryptedKeys.CLASS_NAME="RecipientEncryptedKeys";const po="version",So="originator",yo="ukm",wo="keyEncryptionAlgorithm",vo="recipientEncryptedKeys",bo="recipientCertificate",Ao="recipientPublicKey",ko=[po,So,yo,wo,vo];class KeyAgreeRecipientInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,po,KeyAgreeRecipientInfo.defaultValues(po)),this.originator=getParametersValue(e,So,KeyAgreeRecipientInfo.defaultValues(So)),yo in e&&(this.ukm=getParametersValue(e,yo,KeyAgreeRecipientInfo.defaultValues(yo))),this.keyEncryptionAlgorithm=getParametersValue(e,wo,KeyAgreeRecipientInfo.defaultValues(wo)),this.recipientEncryptedKeys=getParametersValue(e,vo,KeyAgreeRecipientInfo.defaultValues(vo)),this.recipientCertificate=getParametersValue(e,bo,KeyAgreeRecipientInfo.defaultValues(bo)),this.recipientPublicKey=getParametersValue(e,Ao,KeyAgreeRecipientInfo.defaultValues(Ao)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case po:return 0;case So:return new OriginatorIdentifierOrKey;case yo:return new OctetString;case wo:return new AlgorithmIdentifier;case vo:return new RecipientEncryptedKeys;case bo:return new Certificate;case Ao:return null;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case po:return 0===t;case So:return-1===t.variant&&"value"in t==!1;case yo:return t.isEqual(KeyAgreeRecipientInfo.defaultValues(yo));case wo:return t.algorithmId===ke&&"algorithmParams"in t==!1;case vo:return 0===t.encryptedKeys.length;case bo:case Ao:return!1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||ke}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[OriginatorIdentifierOrKey.schema(t.originator||{})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new OctetString({name:t.ukm||ke})]}),AlgorithmIdentifier.schema(t.keyEncryptionAlgorithm||{}),RecipientEncryptedKeys.schema(t.recipientEncryptedKeys||{})]})}fromSchema(e){clearProps(e,ko);const t=compareSchema(e,e,KeyAgreeRecipientInfo.schema({names:{version:po,originator:{names:{blockName:So}},ukm:yo,keyEncryptionAlgorithm:{names:{blockName:wo}},recipientEncryptedKeys:{names:{blockName:vo}}}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.originator=new OriginatorIdentifierOrKey({schema:t.result.originator}),yo in t.result&&(this.ukm=t.result.ukm),this.keyEncryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.keyEncryptionAlgorithm}),this.recipientEncryptedKeys=new RecipientEncryptedKeys({schema:t.result.recipientEncryptedKeys})}toSchema(){const e=[];return e.push(new Integer({value:this.version})),e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.originator.toSchema()]})),this.ukm&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[this.ukm]})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.recipientEncryptedKeys.toSchema()),new Sequence({value:e})}toJSON(){const e={version:this.version,originator:this.originator.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),recipientEncryptedKeys:this.recipientEncryptedKeys.toJSON()};return this.ukm&&(e.ukm=this.ukm.toJSON()),e}}KeyAgreeRecipientInfo.CLASS_NAME="KeyAgreeRecipientInfo";const Co="keyIdentifier",Vo="date",Bo="other",Io=[Co,Vo,Bo];class KEKIdentifier extends PkiObject{constructor(e={}){super(),this.keyIdentifier=getParametersValue(e,Co,KEKIdentifier.defaultValues(Co)),Vo in e&&(this.date=getParametersValue(e,Vo,KEKIdentifier.defaultValues(Vo))),Bo in e&&(this.other=getParametersValue(e,Bo,KEKIdentifier.defaultValues(Bo))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Co:return new OctetString;case Vo:return new GeneralizedTime;case Bo:return new OtherKeyAttribute;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Co:return t.isEqual(KEKIdentifier.defaultValues(Co));case Vo:return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case Bo:return t.compareWithDefault("keyAttrId",t.keyAttrId)&&"keyAttr"in t==!1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new OctetString({name:t.keyIdentifier||ke}),new GeneralizedTime({optional:!0,name:t.date||ke}),OtherKeyAttribute.schema(t.other||{})]})}fromSchema(e){clearProps(e,Io);const t=compareSchema(e,e,KEKIdentifier.schema({names:{keyIdentifier:Co,date:Vo,other:{names:{blockName:Bo}}}}));AsnError.assertSchema(t,this.className),this.keyIdentifier=t.result.keyIdentifier,Vo in t.result&&(this.date=t.result.date),Bo in t.result&&(this.other=new OtherKeyAttribute({schema:t.result.other}))}toSchema(){const e=[];return e.push(this.keyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new Sequence({value:e})}toJSON(){const e={keyIdentifier:this.keyIdentifier.toJSON()};return this.date&&(e.date=this.date),this.other&&(e.other=this.other.toJSON()),e}}KEKIdentifier.CLASS_NAME="KEKIdentifier";const No="version",Po="kekid",Eo="keyEncryptionAlgorithm",Do="encryptedKey",Oo="preDefinedKEK",xo=[No,Po,Eo,Do];class KEKRecipientInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,No,KEKRecipientInfo.defaultValues(No)),this.kekid=getParametersValue(e,Po,KEKRecipientInfo.defaultValues(Po)),this.keyEncryptionAlgorithm=getParametersValue(e,Eo,KEKRecipientInfo.defaultValues(Eo)),this.encryptedKey=getParametersValue(e,Do,KEKRecipientInfo.defaultValues(Do)),this.preDefinedKEK=getParametersValue(e,Oo,KEKRecipientInfo.defaultValues(Oo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case No:return 0;case Po:return new KEKIdentifier;case Eo:return new AlgorithmIdentifier;case Do:return new OctetString;case Oo:return Ae;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"KEKRecipientInfo":return t===KEKRecipientInfo.defaultValues(No);case Po:return t.compareWithDefault("keyIdentifier",t.keyIdentifier)&&"date"in t==!1&&"other"in t==!1;case Eo:return t.algorithmId===ke&&"algorithmParams"in t==!1;case Do:return t.isEqual(KEKRecipientInfo.defaultValues(Do));case Oo:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||ke}),KEKIdentifier.schema(t.kekid||{}),AlgorithmIdentifier.schema(t.keyEncryptionAlgorithm||{}),new OctetString({name:t.encryptedKey||ke})]})}fromSchema(e){clearProps(e,xo);const t=compareSchema(e,e,KEKRecipientInfo.schema({names:{version:No,kekid:{names:{blockName:Po}},keyEncryptionAlgorithm:{names:{blockName:Eo}},encryptedKey:Do}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.kekid=new KEKIdentifier({schema:t.result.kekid}),this.keyEncryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new Sequence({value:[new Integer({value:this.version}),this.kekid.toSchema(),this.keyEncryptionAlgorithm.toSchema(),this.encryptedKey]})}toJSON(){return{version:this.version,kekid:this.kekid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}KEKRecipientInfo.CLASS_NAME="KEKRecipientInfo";const Ro="version",Ko="keyDerivationAlgorithm",Uo="keyEncryptionAlgorithm",To="encryptedKey",Lo="password",Ho=[Ro,Ko,Uo,To];class PasswordRecipientinfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Ro,PasswordRecipientinfo.defaultValues(Ro)),Ko in e&&(this.keyDerivationAlgorithm=getParametersValue(e,Ko,PasswordRecipientinfo.defaultValues(Ko))),this.keyEncryptionAlgorithm=getParametersValue(e,Uo,PasswordRecipientinfo.defaultValues(Uo)),this.encryptedKey=getParametersValue(e,To,PasswordRecipientinfo.defaultValues(To)),this.password=getParametersValue(e,Lo,PasswordRecipientinfo.defaultValues(Lo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ro:return-1;case Ko:case Uo:return new AlgorithmIdentifier;case To:return new OctetString;case Lo:return Ae;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ro:return-1===t;case Ko:case Uo:return t.algorithmId===ke&&"algorithmParams"in t==!1;case To:return t.isEqual(PasswordRecipientinfo.defaultValues(To));case Lo:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||ke}),new Constructed({name:t.keyDerivationAlgorithm||ke,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:AlgorithmIdentifier.schema().valueBlock.value}),AlgorithmIdentifier.schema(t.keyEncryptionAlgorithm||{}),new OctetString({name:t.encryptedKey||ke})]})}fromSchema(e){clearProps(e,Ho);const t=compareSchema(e,e,PasswordRecipientinfo.schema({names:{version:Ro,keyDerivationAlgorithm:Ko,keyEncryptionAlgorithm:{names:{blockName:Uo}},encryptedKey:To}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,Ko in t.result&&(this.keyDerivationAlgorithm=new AlgorithmIdentifier({schema:new Sequence({value:t.result.keyDerivationAlgorithm.valueBlock.value})})),this.keyEncryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){const e=[];return e.push(new Integer({value:this.version})),this.keyDerivationAlgorithm&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.keyDerivationAlgorithm.toSchema().valueBlock.value})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new Sequence({value:e})}toJSON(){const e={version:this.version,keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()};return this.keyDerivationAlgorithm&&(e.keyDerivationAlgorithm=this.keyDerivationAlgorithm.toJSON()),e}}PasswordRecipientinfo.CLASS_NAME="PasswordRecipientInfo";const qo="oriType",jo="oriValue",Mo=[qo,jo];class OtherRecipientInfo extends PkiObject{constructor(e={}){super(),this.oriType=getParametersValue(e,qo,OtherRecipientInfo.defaultValues(qo)),this.oriValue=getParametersValue(e,jo,OtherRecipientInfo.defaultValues(jo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case qo:return ke;case jo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case qo:return t===ke;case jo:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.oriType||ke}),new Any({name:t.oriValue||ke})]})}fromSchema(e){clearProps(e,Mo);const t=compareSchema(e,e,OtherRecipientInfo.schema({names:{oriType:qo,oriValue:jo}}));AsnError.assertSchema(t,this.className),this.oriType=t.result.oriType.valueBlock.toString(),this.oriValue=t.result.oriValue}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.oriType}),this.oriValue]})}toJSON(){const e={oriType:this.oriType};return OtherRecipientInfo.compareWithDefault(jo,this.oriValue)||(e.oriValue=this.oriValue.toJSON()),e}}OtherRecipientInfo.CLASS_NAME="OtherRecipientInfo";const Jo="variant",_o="value",Fo=["blockName"];class RecipientInfo extends PkiObject{constructor(e={}){super(),this.variant=getParametersValue(e,Jo,RecipientInfo.defaultValues(Jo)),_o in e&&(this.value=getParametersValue(e,_o,RecipientInfo.defaultValues(_o))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Jo:return-1;case _o:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Jo:return t===RecipientInfo.defaultValues(e);case _o:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Choice({value:[KeyTransRecipientInfo.schema({names:{blockName:t.blockName||ke}}),new Constructed({name:t.blockName||ke,idBlock:{tagClass:3,tagNumber:1},value:KeyAgreeRecipientInfo.schema().valueBlock.value}),new Constructed({name:t.blockName||ke,idBlock:{tagClass:3,tagNumber:2},value:KEKRecipientInfo.schema().valueBlock.value}),new Constructed({name:t.blockName||ke,idBlock:{tagClass:3,tagNumber:3},value:PasswordRecipientinfo.schema().valueBlock.value}),new Constructed({name:t.blockName||ke,idBlock:{tagClass:3,tagNumber:4},value:OtherRecipientInfo.schema().valueBlock.value})]})}fromSchema(e){clearProps(e,Fo);const t=compareSchema(e,e,RecipientInfo.schema({names:{blockName:"blockName"}}));if(AsnError.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass)this.variant=1,this.value=new KeyTransRecipientInfo({schema:t.result.blockName});else{const e=new Sequence({value:t.result.blockName.valueBlock.value});switch(t.result.blockName.idBlock.tagNumber){case 1:this.variant=2,this.value=new KeyAgreeRecipientInfo({schema:e});break;case 2:this.variant=3,this.value=new KEKRecipientInfo({schema:e});break;case 3:this.variant=4,this.value=new PasswordRecipientinfo({schema:e});break;case 4:this.variant=5,this.value=new OtherRecipientInfo({schema:e});break;default:throw new Error("Incorrect structure of RecipientInfo block")}}}toSchema(){ParameterError.assertEmpty(this.value,"value","RecipientInfo");const e=this.value.toSchema();switch(this.variant){case 1:return e;case 2:case 3:case 4:return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.variant-1,e;default:return new Any}}toJSON(){const e={variant:this.variant};return this.value&&this.variant>=1&&this.variant<=4&&(e.value=this.value.toJSON()),e}}RecipientInfo.CLASS_NAME="RecipientInfo";const $o="hashAlgorithm",Wo="maskGenAlgorithm",Go="pSourceAlgorithm",zo=[$o,Wo,Go];class RSAESOAEPParams extends PkiObject{constructor(e={}){super(),this.hashAlgorithm=getParametersValue(e,$o,RSAESOAEPParams.defaultValues($o)),this.maskGenAlgorithm=getParametersValue(e,Wo,RSAESOAEPParams.defaultValues(Wo)),this.pSourceAlgorithm=getParametersValue(e,Go,RSAESOAEPParams.defaultValues(Go)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case $o:return new AlgorithmIdentifier({algorithmId:"1.3.14.3.2.26",algorithmParams:new Null});case Wo:return new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new AlgorithmIdentifier({algorithmId:"1.3.14.3.2.26",algorithmParams:new Null}).toSchema()});case Go:return new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.9",algorithmParams:new OctetString({valueHex:new Uint8Array([218,57,163,238,94,107,75,13,50,85,191,239,149,96,24,144,175,216,7,9]).buffer})});default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Constructed({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[AlgorithmIdentifier.schema(t.hashAlgorithm||{})]}),new Constructed({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[AlgorithmIdentifier.schema(t.maskGenAlgorithm||{})]}),new Constructed({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[AlgorithmIdentifier.schema(t.pSourceAlgorithm||{})]})]})}fromSchema(e){clearProps(e,zo);const t=compareSchema(e,e,RSAESOAEPParams.schema({names:{hashAlgorithm:{names:{blockName:$o}},maskGenAlgorithm:{names:{blockName:Wo}},pSourceAlgorithm:{names:{blockName:Go}}}}));AsnError.assertSchema(t,this.className),$o in t.result&&(this.hashAlgorithm=new AlgorithmIdentifier({schema:t.result.hashAlgorithm})),Wo in t.result&&(this.maskGenAlgorithm=new AlgorithmIdentifier({schema:t.result.maskGenAlgorithm})),Go in t.result&&(this.pSourceAlgorithm=new AlgorithmIdentifier({schema:t.result.pSourceAlgorithm}))}toSchema(){const e=[];return this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues($o))||e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues(Wo))||e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues(Go))||e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.pSourceAlgorithm.toSchema()]})),new Sequence({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues($o))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues(Wo))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues(Go))||(e.pSourceAlgorithm=this.pSourceAlgorithm.toJSON()),e}}RSAESOAEPParams.CLASS_NAME="RSAESOAEPParams";const Qo="keyInfo",Zo="entityUInfo",Yo="suppPubInfo",Xo=[Qo,Zo,Yo];class ECCCMSSharedInfo extends PkiObject{constructor(e={}){super(),this.keyInfo=getParametersValue(e,Qo,ECCCMSSharedInfo.defaultValues(Qo)),Zo in e&&(this.entityUInfo=getParametersValue(e,Zo,ECCCMSSharedInfo.defaultValues(Zo))),this.suppPubInfo=getParametersValue(e,Yo,ECCCMSSharedInfo.defaultValues(Yo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Qo:return new AlgorithmIdentifier;case Zo:case Yo:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Qo:case Zo:case Yo:return t.isEqual(ECCCMSSharedInfo.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[AlgorithmIdentifier.schema(t.keyInfo||{}),new Constructed({name:t.entityUInfo||ke,idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[new OctetString]}),new Constructed({name:t.suppPubInfo||ke,idBlock:{tagClass:3,tagNumber:2},value:[new OctetString]})]})}fromSchema(e){clearProps(e,Xo);const t=compareSchema(e,e,ECCCMSSharedInfo.schema({names:{keyInfo:{names:{blockName:Qo}},entityUInfo:Zo,suppPubInfo:Yo}}));AsnError.assertSchema(t,this.className),this.keyInfo=new AlgorithmIdentifier({schema:t.result.keyInfo}),Zo in t.result&&(this.entityUInfo=t.result.entityUInfo.valueBlock.value[0]),this.suppPubInfo=t.result.suppPubInfo.valueBlock.value[0]}toSchema(){const e=[];return e.push(this.keyInfo.toSchema()),this.entityUInfo&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.entityUInfo]})),e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.suppPubInfo]})),new Sequence({value:e})}toJSON(){const e={keyInfo:this.keyInfo.toJSON(),suppPubInfo:this.suppPubInfo.toJSON()};return this.entityUInfo&&(e.entityUInfo=this.entityUInfo.toJSON()),e}}ECCCMSSharedInfo.CLASS_NAME="ECCCMSSharedInfo";const el="version",tl="originatorInfo",rl="recipientInfos",sl="encryptedContentInfo",al="unprotectedAttrs",il=[el,tl,rl,sl,al],nl={kdfAlgorithm:"SHA-512",kekEncryptionLength:256},ol={"P-256":256,"P-384":384,"P-521":528};class EnvelopedData extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,el,EnvelopedData.defaultValues(el)),tl in e&&(this.originatorInfo=getParametersValue(e,tl,EnvelopedData.defaultValues(tl))),this.recipientInfos=getParametersValue(e,rl,EnvelopedData.defaultValues(rl)),this.encryptedContentInfo=getParametersValue(e,sl,EnvelopedData.defaultValues(sl)),al in e&&(this.unprotectedAttrs=getParametersValue(e,al,EnvelopedData.defaultValues(al))),this.policy={disableSplit:!!e.disableSplit},e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case el:return 0;case tl:return new OriginatorInfo;case rl:return[];case sl:return new EncryptedContentInfo;case al:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case el:return t===EnvelopedData.defaultValues(e);case tl:return 0===t.certs.certificates.length&&0===t.crls.crls.length;case rl:case al:return 0===t.length;case sl:return EncryptedContentInfo.compareWithDefault("contentType",t.contentType)&&EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&EncryptedContentInfo.compareWithDefault("encryptedContent",t.encryptedContent);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||ke}),new Constructed({name:t.originatorInfo||ke,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:OriginatorInfo.schema().valueBlock.value}),new Set({value:[new Repeated({name:t.recipientInfos||ke,value:RecipientInfo.schema()})]}),EncryptedContentInfo.schema(t.encryptedContentInfo||{}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Repeated({name:t.unprotectedAttrs||ke,value:Attribute.schema()})]})]})}fromSchema(e){clearProps(e,il);const t=compareSchema(e,e,EnvelopedData.schema({names:{version:el,originatorInfo:tl,recipientInfos:rl,encryptedContentInfo:{names:{blockName:sl}},unprotectedAttrs:al}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,tl in t.result&&(this.originatorInfo=new OriginatorInfo({schema:new Sequence({value:t.result.originatorInfo.valueBlock.value})})),this.recipientInfos=Array.from(t.result.recipientInfos,e=>new RecipientInfo({schema:e})),this.encryptedContentInfo=new EncryptedContentInfo({schema:t.result.encryptedContentInfo}),al in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new Attribute({schema:e})))}toSchema(){const e=[];return e.push(new Integer({value:this.version})),this.originatorInfo&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:this.originatorInfo.toSchema().valueBlock.value})),e.push(new Set({value:Array.from(this.recipientInfos,e=>e.toSchema())})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={version:this.version,recipientInfos:Array.from(this.recipientInfos,e=>e.toJSON()),encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.originatorInfo&&(e.originatorInfo=this.originatorInfo.toJSON()),this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}addRecipientByCertificate(e,t,r,s=getCrypto(!0)){const a=Object.assign({useOAEP:!0,oaepHashAlgorithm:"SHA-512"},nl,t||{});if(-1!==e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549"))r=1;else{if(-1===e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045"))throw new Error(`Unknown type of certificate's public key: ${e.subjectPublicKeyInfo.algorithm.algorithmId}`);r=2}switch(r){case 1:{let t,r;if(!0===a.useOAEP){t=s.getOIDByAlgorithm({name:"RSA-OAEP"},!0,"keyEncryptionAlgorithm");const e=s.getOIDByAlgorithm({name:a.oaepHashAlgorithm},!0,"RSAES-OAEP-params"),i=new AlgorithmIdentifier({algorithmId:e,algorithmParams:new Null});r=new RSAESOAEPParams({hashAlgorithm:i,maskGenAlgorithm:new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:i.toSchema()})}).toSchema()}else{if(t=s.getOIDByAlgorithm({name:"RSAES-PKCS1-v1_5"}),t===ke)throw new Error("Can not find OID for RSAES-PKCS1-v1_5");r=new Null}const i=new KeyTransRecipientInfo({version:0,rid:new IssuerAndSerialNumber({issuer:e.issuer,serialNumber:e.serialNumber}),keyEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:t,algorithmParams:r}),recipientCertificate:e});this.recipientInfos.push(new RecipientInfo({variant:1,value:i}))}break;case 2:{const t=new KeyAgreeRecipientIdentifier({variant:1,value:new IssuerAndSerialNumber({issuer:e.issuer,serialNumber:e.serialNumber})});this._addKeyAgreeRecipientInfo(t,a,{recipientCertificate:e},s)}break;default:throw new Error(`Unknown "variant" value: ${r}`)}return!0}addRecipientByPreDefinedData(e,t={},r,s=getCrypto(!0)){if(ArgumentError.assert(e,"preDefinedData","ArrayBuffer"),!e.byteLength)throw new Error("Pre-defined data could have zero length");if(!t.keyIdentifier){const e=new ArrayBuffer(16),r=new Uint8Array(e);s.getRandomValues(r),t.keyIdentifier=e}switch(t.hmacHashAlgorithm||(t.hmacHashAlgorithm="SHA-512"),void 0===t.iterationCount&&(t.iterationCount=2048),t.keyEncryptionAlgorithm||(t.keyEncryptionAlgorithm={name:"AES-KW",length:256}),t.keyEncryptionAlgorithmParams||(t.keyEncryptionAlgorithmParams=new Null),r){case 1:{const r=s.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),a=new KEKRecipientInfo({version:4,kekid:new KEKIdentifier({keyIdentifier:new OctetString({valueHex:t.keyIdentifier})}),keyEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:r,algorithmParams:t.keyEncryptionAlgorithmParams}),preDefinedKEK:e});this.recipientInfos.push(new RecipientInfo({variant:3,value:a}))}break;case 2:{const r=s.getOIDByAlgorithm({name:"PBKDF2"},!0,"keyDerivationAlgorithm"),a=new ArrayBuffer(64),i=new Uint8Array(a);s.getRandomValues(i);const n=s.getOIDByAlgorithm({name:"HMAC",hash:{name:t.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),o=new PBKDF2Params({salt:new OctetString({valueHex:a}),iterationCount:t.iterationCount,prf:new AlgorithmIdentifier({algorithmId:n,algorithmParams:new Null})}),l=s.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),c=new PasswordRecipientinfo({version:0,keyDerivationAlgorithm:new AlgorithmIdentifier({algorithmId:r,algorithmParams:o.toSchema()}),keyEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:l,algorithmParams:t.keyEncryptionAlgorithmParams}),password:e});this.recipientInfos.push(new RecipientInfo({variant:4,value:c}))}break;default:throw new Error(`Unknown value for "variant": ${r}`)}}addRecipientByKeyIdentifier(e,t,r,s=getCrypto(!0)){const a=Object.assign({},nl,r||{}),i=new KeyAgreeRecipientIdentifier({variant:2,value:new RecipientKeyIdentifier({subjectKeyIdentifier:new OctetString({valueHex:t})})});this._addKeyAgreeRecipientInfo(i,a,{recipientPublicKey:e},s)}_addKeyAgreeRecipientInfo(e,t,r,s=getCrypto(!0)){const a=new RecipientEncryptedKey({rid:e}),i=s.getOIDByAlgorithm({name:"AES-KW",length:t.kekEncryptionLength},!0,"keyEncryptionAlgorithm"),n=new AlgorithmIdentifier({algorithmId:i}),o=s.getOIDByAlgorithm({name:"ECDH",kdf:t.kdfAlgorithm},!0,"KeyAgreeRecipientInfo"),l=new ArrayBuffer(64),c=new Uint8Array(l);s.getRandomValues(c);const u={version:3,ukm:new OctetString({valueHex:l}),keyEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:o,algorithmParams:n.toSchema()}),recipientEncryptedKeys:new RecipientEncryptedKeys({encryptedKeys:[a]})},h=new KeyAgreeRecipientInfo(Object.assign(u,r));this.recipientInfos.push(new RecipientInfo({variant:2,value:h}))}async encrypt(e,t,r=getCrypto(!0)){const s=new ArrayBuffer(16),a=new Uint8Array(s);r.getRandomValues(a);const i=new Uint8Array(t),n=r.getOIDByAlgorithm(e,!0,"contentEncryptionAlgorithm"),o=await r.generateKey(e,!0,["encrypt"]),l=await r.encrypt({name:e.name,iv:a},o,i),c=await r.exportKey("raw",o);this.version=2,this.encryptedContentInfo=new EncryptedContentInfo({disableSplit:this.policy.disableSplit,contentType:"1.2.840.113549.1.7.1",contentEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:n,algorithmParams:new OctetString({valueHex:s})}),encryptedContent:new OctetString({valueHex:l})});const SubKeyAgreeRecipientInfo=async e=>{const t=this.recipientInfos[e].value;let s,a;if(t.recipientPublicKey)s=t.recipientPublicKey.algorithm.namedCurve,a=t.recipientPublicKey;else{if(!t.recipientCertificate)throw new Error("Unsupported RecipientInfo");{const i=t.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(i.constructor.blockName()!==ObjectIdentifier.blockName())throw new Error(`Incorrect "recipientCertificate" for index ${e}`);switch(i.valueBlock.toString()){case"1.2.840.10045.3.1.7":s="P-256";break;case"1.3.132.0.34":s="P-384";break;case"1.3.132.0.35":s="P-521";break;default:throw new Error(`Incorrect curve OID for index ${e}`)}a=await t.recipientCertificate.getPublicKey({algorithm:{algorithm:{name:"ECDH",namedCurve:s},usages:[]}},r)}}const i=ol[s],n=await r.generateKey({name:"ECDH",namedCurve:s},!0,["deriveBits"]),l=await r.exportKey("spki",n.publicKey),c=await r.deriveBits({name:"ECDH",public:a},n.privateKey,i),u=new AlgorithmIdentifier({schema:t.keyEncryptionAlgorithm.algorithmParams}),h=r.getAlgorithmByOID(u.algorithmId,!0,"aesKWAlgorithm");let m=h.length;const f=new ArrayBuffer(4),g=new Uint8Array(f);for(let e=3;e>=0;e--)g[e]=m,m>>=8;const d=new ECCCMSSharedInfo({keyInfo:new AlgorithmIdentifier({algorithmId:u.algorithmId}),entityUInfo:t.ukm,suppPubInfo:new OctetString({valueHex:f})}).toSchema().toBER(!1),p=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm"),S=await kdf(p.kdf,c,h.length,d,r),y=await r.importKey("raw",S,{name:"AES-KW"},!0,["wrapKey"]),w=await r.wrapKey("raw",o,y,{name:"AES-KW"}),v=new OriginatorIdentifierOrKey;return v.variant=3,v.value=OriginatorPublicKey.fromBER(l),t.originator=v,t.recipientEncryptedKeys.encryptedKeys[0].encryptedKey=new OctetString({valueHex:w}),{ecdhPrivateKey:n.privateKey}},SubKeyTransRecipientInfo=async e=>{const t=this.recipientInfos[e].value,s=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if("RSA-OAEP"===s.name){const e=t.keyEncryptionAlgorithm.algorithmParams,a=new RSAESOAEPParams({schema:e});if(s.hash=r.getAlgorithmByOID(a.hashAlgorithm.algorithmId),"name"in s.hash==!1)throw new Error(`Incorrect OID for hash algorithm: ${a.hashAlgorithm.algorithmId}`)}try{const e=await t.recipientCertificate.getPublicKey({algorithm:{algorithm:s,usages:["encrypt","wrapKey"]}},r),a=await r.encrypt(e.algorithm,e,c);t.encryptedKey=new OctetString({valueHex:a})}catch{}},SubKEKRecipientInfo=async e=>{const t=this.recipientInfos[e].value,s=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),a=await r.importKey("raw",new Uint8Array(t.preDefinedKEK),s,!0,["wrapKey"]),i=await r.wrapKey("raw",o,a,s);t.encryptedKey=new OctetString({valueHex:i})},SubPasswordRecipientinfo=async e=>{const t=this.recipientInfos[e].value;let s;if(!t.keyDerivationAlgorithm)throw new Error('Please append encoded "keyDerivationAlgorithm"');if(!t.keyDerivationAlgorithm.algorithmParams)throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');try{s=new PBKDF2Params({schema:t.keyDerivationAlgorithm.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "keyDerivationAlgorithm"')}const a=new Uint8Array(t.password),i=await r.importKey("raw",a,"PBKDF2",!1,["deriveKey"]),n=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm");let l="SHA-1";if(s.prf){l=r.getAlgorithmByOID(s.prf.algorithmId,!0,"prfAlgorithm").hash.name}const c=new Uint8Array(s.salt.valueBlock.valueHex),u=s.iterationCount,h=await r.deriveKey({name:"PBKDF2",hash:{name:l},salt:c,iterations:u},i,n,!0,["wrapKey"]),m=await r.wrapKey("raw",o,h,n);t.encryptedKey=new OctetString({valueHex:m})},u=[];for(let e=0;e<this.recipientInfos.length;e++)switch(this.recipientInfos[e].variant){case 1:u.push(await SubKeyTransRecipientInfo(e));break;case 2:u.push(await SubKeyAgreeRecipientInfo(e));break;case 3:u.push(await SubKEKRecipientInfo(e));break;case 4:u.push(await SubPasswordRecipientinfo(e));break;default:throw new Error(`Unknown recipient type in array with index ${e}`)}return u}async decrypt(e,t,r=getCrypto(!0)){const s=t||{};if(e+1>this.recipientInfos.length)throw new Error('Maximum value for "index" is: '+(this.recipientInfos.length-1));const SubKeyAgreeRecipientInfo=async e=>{const t=this.recipientInfos[e].value;let a,i,n;const o=t.originator;if(s.recipientCertificate){const t=s.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(t.constructor.blockName()!==ObjectIdentifier.blockName())throw new Error(`Incorrect "recipientCertificate" for index ${e}`);a=t.valueBlock.toString()}else{if(!o.value.algorithm.algorithmParams)throw new Error('Parameter "recipientCertificate" is mandatory for "KeyAgreeRecipientInfo" if algorithm params are missing from originator');{const t=o.value.algorithm.algorithmParams;if(t.constructor.blockName()!==ObjectIdentifier.blockName())throw new Error(`Incorrect originator for index ${e}`);a=t.valueBlock.toString()}}if(!s.recipientPrivateKey)throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyAgreeRecipientInfo"');switch(a){case"1.2.840.10045.3.1.7":i="P-256",n=256;break;case"1.3.132.0.34":i="P-384",n=384;break;case"1.3.132.0.35":i="P-521",n=528;break;default:throw new Error(`Incorrect curve OID for index ${e}`)}let l,c=r;BufferSourceConverter.isBufferSource(s.recipientPrivateKey)?l=await r.importKey("pkcs8",s.recipientPrivateKey,{name:"ECDH",namedCurve:i},!0,["deriveBits"]):(l=s.recipientPrivateKey,"crypto"in s&&s.crypto&&(c=s.crypto.subtle)),"algorithmParams"in o.value.algorithm==!1&&(o.value.algorithm.algorithmParams=new ObjectIdentifier({value:a}));const u=o.value.toSchema().toBER(!1),h=await r.importKey("spki",u,{name:"ECDH",namedCurve:i},!0,[]),m=await c.deriveBits({name:"ECDH",public:h},l,n);async function applyKDF(e){e=e||!1;const s=new AlgorithmIdentifier({schema:t.keyEncryptionAlgorithm.algorithmParams}),a=r.getAlgorithmByOID(s.algorithmId,!0,"kwAlgorithm");let i=a.length;const n=new ArrayBuffer(4),o=new Uint8Array(n);for(let e=3;e>=0;e--)o[e]=i,i>>=8;const l={algorithmId:s.algorithmId};e&&(l.algorithmParams=new Null);const c=new ECCCMSSharedInfo({keyInfo:new AlgorithmIdentifier(l),entityUInfo:t.ukm,suppPubInfo:new OctetString({valueHex:n})}).toSchema().toBER(!1),u=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm");if(!u.name)throw new Error(`Incorrect OID for key encryption algorithm: ${t.keyEncryptionAlgorithm.algorithmId}`);return kdf(u.kdf,m,a.length,c,r)}const f=await applyKDF(),importAesKwKey=async e=>r.importKey("raw",e,{name:"AES-KW"},!0,["unwrapKey"]),g=await importAesKwKey(f),unwrapSessionKey=async e=>{const s=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,a=r.getAlgorithmByOID(s,!0,"contentEncryptionAlgorithm");return r.unwrapKey("raw",t.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHexView,e,{name:"AES-KW"},a,!0,["decrypt"])};try{return await unwrapSessionKey(g)}catch{const e=await applyKDF(!0);return unwrapSessionKey(await importAesKwKey(e))}},SubKeyTransRecipientInfo=async e=>{const t=this.recipientInfos[e].value;if(!s.recipientPrivateKey)throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyTransRecipientInfo"');const a=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if("RSA-OAEP"===a.name){const e=t.keyEncryptionAlgorithm.algorithmParams,s=new RSAESOAEPParams({schema:e});if(a.hash=r.getAlgorithmByOID(s.hashAlgorithm.algorithmId),"name"in a.hash==!1)throw new Error(`Incorrect OID for hash algorithm: ${s.hashAlgorithm.algorithmId}`)}let i,n=r;BufferSourceConverter.isBufferSource(s.recipientPrivateKey)?i=await r.importKey("pkcs8",s.recipientPrivateKey,a,!0,["decrypt"]):(i=s.recipientPrivateKey,"crypto"in s&&s.crypto&&(n=s.crypto.subtle));const o=await n.decrypt(i.algorithm,i,t.encryptedKey.valueBlock.valueHexView),l=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,c=r.getAlgorithmByOID(l,!0,"contentEncryptionAlgorithm");if("name"in c==!1)throw new Error(`Incorrect "contentEncryptionAlgorithm": ${l}`);return r.importKey("raw",o,c,!0,["decrypt"])},SubKEKRecipientInfo=async e=>{const t=this.recipientInfos[e].value;if(!s.preDefinedData)throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');const a=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),i=await r.importKey("raw",s.preDefinedData,a,!0,["unwrapKey"]),n=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,o=r.getAlgorithmByOID(n,!0,"contentEncryptionAlgorithm");if(!o.name)throw new Error(`Incorrect "contentEncryptionAlgorithm": ${n}`);return r.unwrapKey("raw",t.encryptedKey.valueBlock.valueHexView,i,a,o,!0,["decrypt"])},SubPasswordRecipientinfo=async e=>{const t=this.recipientInfos[e].value;let a;if(!s.preDefinedData)throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');if(!t.keyDerivationAlgorithm)throw new Error('Please append encoded "keyDerivationAlgorithm"');if(!t.keyDerivationAlgorithm.algorithmParams)throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');try{a=new PBKDF2Params({schema:t.keyDerivationAlgorithm.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "keyDerivationAlgorithm"')}const i=await r.importKey("raw",s.preDefinedData,"PBKDF2",!1,["deriveKey"]),n=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm"),o=a.prf?r.getAlgorithmByOID(a.prf.algorithmId,!0,"prfAlgorithm").hash.name:"SHA-1",l=new Uint8Array(a.salt.valueBlock.valueHex),c=a.iterationCount,u=await r.deriveKey({name:"PBKDF2",hash:{name:o},salt:l,iterations:c},i,n,!0,["unwrapKey"]),h=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,m=r.getAlgorithmByOID(h,!0,"contentEncryptionAlgorithm");return r.unwrapKey("raw",t.encryptedKey.valueBlock.valueHexView,u,n,m,!0,["decrypt"])};let a;switch(this.recipientInfos[e].variant){case 1:a=await SubKeyTransRecipientInfo(e);break;case 2:a=await SubKeyAgreeRecipientInfo(e);break;case 3:a=await SubKEKRecipientInfo(e);break;case 4:a=await SubPasswordRecipientinfo(e);break;default:throw new Error(`Unknown recipient type in array with index ${e}`)}const i=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,n=r.getAlgorithmByOID(i,!0,"contentEncryptionAlgorithm"),o=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex,l=new Uint8Array(o);if(!this.encryptedContentInfo.encryptedContent)throw new Error("Required property `encryptedContent` is empty");const c=this.encryptedContentInfo.getEncryptedContent();return r.decrypt({name:n.name,iv:l},a,c)}}EnvelopedData.CLASS_NAME="EnvelopedData";const ll="safeContents",cl="parsedValue",ul="contentInfos";class AuthenticatedSafe extends PkiObject{constructor(e={}){super(),this.safeContents=getParametersValue(e,ll,AuthenticatedSafe.defaultValues(ll)),cl in e&&(this.parsedValue=getParametersValue(e,cl,AuthenticatedSafe.defaultValues(cl))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ll:return[];case cl:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ll:return 0===t.length;case cl:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Repeated({name:t.contentInfos||ke,value:ContentInfo.schema()})]})}fromSchema(e){clearProps(e,[ul]);const t=compareSchema(e,e,AuthenticatedSafe.schema({names:{contentInfos:ul}}));AsnError.assertSchema(t,this.className),this.safeContents=Array.from(t.result.contentInfos,e=>new ContentInfo({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.safeContents,e=>e.toSchema())})}toJSON(){return{safeContents:Array.from(this.safeContents,e=>e.toJSON())}}async parseInternalValues(e,t=getCrypto(!0)){if(ParameterError.assert(e,ll),ArgumentError.assert(e.safeContents,ll,"Array"),e.safeContents.length!==this.safeContents.length)throw new ArgumentError('Length of "parameters.safeContents" must be equal to "this.safeContents.length"');this.parsedValue={safeContents:[]};for(const[r,s]of this.safeContents.entries()){const a=e.safeContents[r],i=`parameters.safeContents[${r}]`;switch(s.contentType){case ht:{ArgumentError.assert(s.content,"this.safeContents[j].content",OctetString);const e=s.content.getValue();this.parsedValue.safeContents.push({privacyMode:0,value:SafeContents.fromBER(e)})}break;case ft:{const e=new EnvelopedData({schema:s.content});ParameterError.assert(i,a,"recipientCertificate","recipientKey");const r=a,n=r.recipientCertificate,o=r.recipientKey,l=await e.decrypt(0,{recipientCertificate:n,recipientPrivateKey:o},t);this.parsedValue.safeContents.push({privacyMode:2,value:SafeContents.fromBER(l)})}break;case gt:{const e=new EncryptedData({schema:s.content});ParameterError.assert(i,a,"password");const r=a.password,n=await e.decrypt({password:r},t);this.parsedValue.safeContents.push({privacyMode:1,value:SafeContents.fromBER(n)})}break;default:throw new Error(`Unknown "contentType" for AuthenticatedSafe: " ${s.contentType}`)}}}async makeInternalValues(e,t=getCrypto(!0)){if(!this.parsedValue)throw new Error('Please run "parseValues" first or add "parsedValue" manually');if(ArgumentError.assert(this.parsedValue,"this.parsedValue","object"),ArgumentError.assert(this.parsedValue.safeContents,"this.parsedValue.safeContents","Array"),ArgumentError.assert(e,"parameters","object"),ParameterError.assert(e,"safeContents"),ArgumentError.assert(e.safeContents,"parameters.safeContents","Array"),e.safeContents.length!==this.parsedValue.safeContents.length)throw new ArgumentError('Length of "parameters.safeContents" must be equal to "this.parsedValue.safeContents"');this.safeContents=[];for(const[r,s]of this.parsedValue.safeContents.entries())switch(ParameterError.assert("content",s,"privacyMode","value"),ArgumentError.assert(s.value,"content.value",SafeContents),s.privacyMode){case 0:{const e=s.value.toSchema().toBER(!1);this.safeContents.push(new ContentInfo({contentType:"1.2.840.113549.1.7.1",content:new OctetString({valueHex:e})}))}break;case 1:{const a=new EncryptedData,i=e.safeContents[r];i.contentToEncrypt=s.value.toSchema().toBER(!1),await a.encrypt(i,t),this.safeContents.push(new ContentInfo({contentType:"1.2.840.113549.1.7.6",content:a.toSchema()}))}break;case 2:{const a=new EnvelopedData,i=s.value.toSchema().toBER(!1),n=e.safeContents[r];switch(ParameterError.assert(`parameters.safeContents[${r}]`,n,"encryptingCertificate","encryptionAlgorithm"),!0){case"aes-cbc"===n.encryptionAlgorithm.name.toLowerCase():case"aes-gcm"===n.encryptionAlgorithm.name.toLowerCase():break;default:throw new Error(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${n.encryptionAlgorithm}`)}switch(!0){case 128===n.encryptionAlgorithm.length:case 192===n.encryptionAlgorithm.length:case 256===n.encryptionAlgorithm.length:break;default:throw new Error(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${n.encryptionAlgorithm.length}`)}const o=n.encryptionAlgorithm;a.addRecipientByCertificate(n.encryptingCertificate,{},void 0,t),await a.encrypt(o,i,t),this.safeContents.push(new ContentInfo({contentType:"1.2.840.113549.1.7.3",content:a.toSchema()}))}break;default:throw new Error(`Incorrect value for "content.privacyMode": ${s.privacyMode}`)}return this}}AuthenticatedSafe.CLASS_NAME="AuthenticatedSafe";const hl="hashAlgorithm",ml="issuerNameHash",fl="issuerKeyHash",gl="serialNumber",dl=[hl,ml,fl,gl];class CertID extends PkiObject{static async create(e,t,r=getCrypto(!0)){const s=new CertID;return await s.createForCertificate(e,t,r),s}constructor(e={}){super(),this.hashAlgorithm=getParametersValue(e,hl,CertID.defaultValues(hl)),this.issuerNameHash=getParametersValue(e,ml,CertID.defaultValues(ml)),this.issuerKeyHash=getParametersValue(e,fl,CertID.defaultValues(fl)),this.serialNumber=getParametersValue(e,gl,CertID.defaultValues(gl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case hl:return new AlgorithmIdentifier;case ml:case fl:return new OctetString;case gl:return new Integer;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case hl:return t.algorithmId===ke&&"algorithmParams"in t==!1;case ml:case fl:case gl:return t.isEqual(CertID.defaultValues(gl));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[AlgorithmIdentifier.schema(t.hashAlgorithmObject||{names:{blockName:t.hashAlgorithm||ke}}),new OctetString({name:t.issuerNameHash||ke}),new OctetString({name:t.issuerKeyHash||ke}),new Integer({name:t.serialNumber||ke})]})}fromSchema(e){clearProps(e,dl);const t=compareSchema(e,e,CertID.schema({names:{hashAlgorithm:hl,issuerNameHash:ml,issuerKeyHash:fl,serialNumber:gl}}));AsnError.assertSchema(t,this.className),this.hashAlgorithm=new AlgorithmIdentifier({schema:t.result.hashAlgorithm}),this.issuerNameHash=t.result.issuerNameHash,this.issuerKeyHash=t.result.issuerKeyHash,this.serialNumber=t.result.serialNumber}toSchema(){return new Sequence({value:[this.hashAlgorithm.toSchema(),this.issuerNameHash,this.issuerKeyHash,this.serialNumber]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),issuerNameHash:this.issuerNameHash.toJSON(),issuerKeyHash:this.issuerKeyHash.toJSON(),serialNumber:this.serialNumber.toJSON()}}isEqual(e){return this.hashAlgorithm.algorithmId===e.hashAlgorithm.algorithmId&&(!!BufferSourceConverter.isEqual(this.issuerNameHash.valueBlock.valueHexView,e.issuerNameHash.valueBlock.valueHexView)&&(!!BufferSourceConverter.isEqual(this.issuerKeyHash.valueBlock.valueHexView,e.issuerKeyHash.valueBlock.valueHexView)&&!!this.serialNumber.isEqual(e.serialNumber)))}async createForCertificate(e,t,r=getCrypto(!0)){ParameterError.assert(t,hl,"issuerCertificate");const s=r.getOIDByAlgorithm({name:t.hashAlgorithm},!0,"hashAlgorithm");this.hashAlgorithm=new AlgorithmIdentifier({algorithmId:s,algorithmParams:new Null});const a=t.issuerCertificate;this.serialNumber=e.serialNumber;const i=await r.digest({name:t.hashAlgorithm},a.subject.toSchema().toBER(!1));this.issuerNameHash=new OctetString({valueHex:i});const n=a.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView,o=await r.digest({name:t.hashAlgorithm},n);this.issuerKeyHash=new OctetString({valueHex:o})}}CertID.CLASS_NAME="CertID";const pl="certID",Sl="certStatus",yl="thisUpdate",wl="nextUpdate",vl="singleExtensions",bl=[pl,Sl,yl,wl,vl];class SingleResponse extends PkiObject{constructor(e={}){super(),this.certID=getParametersValue(e,pl,SingleResponse.defaultValues(pl)),this.certStatus=getParametersValue(e,Sl,SingleResponse.defaultValues(Sl)),this.thisUpdate=getParametersValue(e,yl,SingleResponse.defaultValues(yl)),wl in e&&(this.nextUpdate=getParametersValue(e,wl,SingleResponse.defaultValues(wl))),vl in e&&(this.singleExtensions=getParametersValue(e,vl,SingleResponse.defaultValues(vl))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case pl:return new CertID;case Sl:return{};case yl:case wl:return new Date(0,0,0);case vl:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case pl:return CertID.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&CertID.compareWithDefault("issuerNameHash",t.issuerNameHash)&&CertID.compareWithDefault("issuerKeyHash",t.issuerKeyHash)&&CertID.compareWithDefault("serialNumber",t.serialNumber);case Sl:return 0===Object.keys(t).length;case yl:case wl:return t===SingleResponse.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[CertID.schema(t.certID||{}),new Choice({value:[new Primitive({name:t.certStatus||ke,idBlock:{tagClass:3,tagNumber:0}}),new Constructed({name:t.certStatus||ke,idBlock:{tagClass:3,tagNumber:1},value:[new GeneralizedTime,new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Enumerated]})]}),new Primitive({name:t.certStatus||ke,idBlock:{tagClass:3,tagNumber:2},lenBlock:{length:1}})]}),new GeneralizedTime({name:t.thisUpdate||ke}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new GeneralizedTime({name:t.nextUpdate||ke})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[Extensions.schema(t.singleExtensions||{})]})]})}fromSchema(e){clearProps(e,bl);const t=compareSchema(e,e,SingleResponse.schema({names:{certID:{names:{blockName:pl}},certStatus:Sl,thisUpdate:yl,nextUpdate:wl,singleExtensions:{names:{blockName:vl}}}}));AsnError.assertSchema(t,this.className),this.certID=new CertID({schema:t.result.certID}),this.certStatus=t.result.certStatus,this.thisUpdate=t.result.thisUpdate.toDate(),wl in t.result&&(this.nextUpdate=t.result.nextUpdate.toDate()),vl in t.result&&(this.singleExtensions=Array.from(t.result.singleExtensions.valueBlock.value,e=>new Extension({schema:e})))}toSchema(){const e=[];return e.push(this.certID.toSchema()),e.push(this.certStatus),e.push(new GeneralizedTime({valueDate:this.thisUpdate})),this.nextUpdate&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new GeneralizedTime({valueDate:this.nextUpdate})]})),this.singleExtensions&&e.push(new Sequence({value:Array.from(this.singleExtensions,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={certID:this.certID.toJSON(),certStatus:this.certStatus.toJSON(),thisUpdate:this.thisUpdate};return this.nextUpdate&&(e.nextUpdate=this.nextUpdate),this.singleExtensions&&(e.singleExtensions=Array.from(this.singleExtensions,e=>e.toJSON())),e}}SingleResponse.CLASS_NAME="SingleResponse";const Al="tbs",kl="version",Cl="responderID",Vl="producedAt",Bl="responses",Il="responseExtensions",Nl="ResponseData",Pl=`${Nl}.${kl}`,El=`${Nl}.${Cl}`,Dl=`${Nl}.${Vl}`,Ol=`${Nl}.${Bl}`,xl=`${Nl}.${Il}`,Rl=[Nl,Pl,El,Dl,Ol,xl];class ResponseData extends PkiObject{get tbs(){return BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(getParametersValue(e,Al,ResponseData.defaultValues(Al))),kl in e&&(this.version=getParametersValue(e,kl,ResponseData.defaultValues(kl))),this.responderID=getParametersValue(e,Cl,ResponseData.defaultValues(Cl)),this.producedAt=getParametersValue(e,Vl,ResponseData.defaultValues(Vl)),this.responses=getParametersValue(e,Bl,ResponseData.defaultValues(Bl)),Il in e&&(this.responseExtensions=getParametersValue(e,Il,ResponseData.defaultValues(Il))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case kl:return 0;case Al:return Ae;case Cl:return{};case Vl:return new Date(0,0,0);case Bl:case Il:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Al:return 0===t.byteLength;case Cl:return 0===Object.keys(t).length;case Vl:return t===ResponseData.defaultValues(e);case Bl:case Il:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Nl,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Integer({name:t.version||Pl})]}),new Choice({value:[new Constructed({name:t.responderID||El,idBlock:{tagClass:3,tagNumber:1},value:[RelativeDistinguishedNames.schema(t.ResponseDataByName||{names:{blockName:"ResponseData.byName"}})]}),new Constructed({name:t.responderID||El,idBlock:{tagClass:3,tagNumber:2},value:[new OctetString({name:t.ResponseDataByKey||"ResponseData.byKey"})]})]}),new GeneralizedTime({name:t.producedAt||Dl}),new Sequence({value:[new Repeated({name:Ol,value:SingleResponse.schema(t.response||{})})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[Extensions.schema(t.extensions||{names:{blockName:xl}})]})]})}fromSchema(e){clearProps(e,Rl);const t=compareSchema(e,e,ResponseData.schema());AsnError.assertSchema(t,this.className),this.tbsView=t.result.ResponseData.valueBeforeDecodeView,Pl in t.result&&(this.version=t.result[Pl].valueBlock.valueDec),1===t.result[El].idBlock.tagNumber?this.responderID=new RelativeDistinguishedNames({schema:t.result[El].valueBlock.value[0]}):this.responderID=t.result[El].valueBlock.value[0],this.producedAt=t.result[Dl].toDate(),this.responses=Array.from(t.result[Ol],e=>new SingleResponse({schema:e})),xl in t.result&&(this.responseExtensions=Array.from(t.result[xl].valueBlock.value,e=>new Extension({schema:e})))}toSchema(e=!1){let t;if(!1===e){if(!this.tbsView.byteLength)return ResponseData.schema();const e=fromBER(this.tbsView);AsnError.assert(e,"TBS Response Data"),t=e.result}else{const e=[];kl in this&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Integer({value:this.version})]})),this.responderID instanceof RelativeDistinguishedNames?e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.responderID.toSchema()]})):e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.responderID]})),e.push(new GeneralizedTime({valueDate:this.producedAt})),e.push(new Sequence({value:Array.from(this.responses,e=>e.toSchema())})),this.responseExtensions&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new Sequence({value:Array.from(this.responseExtensions,e=>e.toSchema())})]})),t=new Sequence({value:e})}return t}toJSON(){const e={};return kl in this&&(e.version=this.version),this.responderID&&(e.responderID=this.responderID),this.producedAt&&(e.producedAt=this.producedAt),this.responses&&(e.responses=Array.from(this.responses,e=>e.toJSON())),this.responseExtensions&&(e.responseExtensions=Array.from(this.responseExtensions,e=>e.toJSON())),e}}ResponseData.CLASS_NAME="ResponseData";const Kl="trustedCerts",Ul="certs",Tl="crls",Ll="ocsps",Hl="checkDate",ql="findOrigin",jl="findIssuer";var Ml;!function(e){e[e.unknown=-1]="unknown",e[e.success=0]="success",e[e.noRevocation=11]="noRevocation",e[e.noPath=60]="noPath",e[e.noValidPath=97]="noValidPath"}(Ml||(Ml={}));class ChainValidationError extends Error{constructor(e,t){super(t),this.name=ChainValidationError.NAME,this.code=e,this.message=t}}ChainValidationError.NAME="ChainValidationError";class CertificateChainValidationEngine{constructor(e={}){this.trustedCerts=getParametersValue(e,Kl,this.defaultValues(Kl)),this.certs=getParametersValue(e,Ul,this.defaultValues(Ul)),this.crls=getParametersValue(e,Tl,this.defaultValues(Tl)),this.ocsps=getParametersValue(e,Ll,this.defaultValues(Ll)),this.checkDate=getParametersValue(e,Hl,this.defaultValues(Hl)),this.findOrigin=getParametersValue(e,ql,this.defaultValues(ql)),this.findIssuer=getParametersValue(e,jl,this.defaultValues(jl))}static defaultFindOrigin(e,t){0===e.tbsView.byteLength&&(e.tbsView=new Uint8Array(e.encodeTBS().toBER()));for(const r of t.certs)if(0===r.tbsView.byteLength&&(r.tbsView=new Uint8Array(r.encodeTBS().toBER())),BufferSourceConverter.isEqual(e.tbsView,r.tbsView))return"Intermediate Certificates";for(const r of t.trustedCerts)if(0===r.tbsView.byteLength&&(r.tbsView=new Uint8Array(r.encodeTBS().toBER())),BufferSourceConverter.isEqual(e.tbsView,r.tbsView))return"Trusted Certificates";return"Unknown"}async defaultFindIssuer(e,t,r=getCrypto(!0)){const s=[];let a=null,i=null,n=null;if(e.subject.isEqual(e.issuer))try{if(await e.verify(void 0,r))return[e]}catch(e){}if(e.extensions)for(const t of e.extensions)if(t.extnID===lt&&t.parsedValue instanceof AuthorityKeyIdentifier){t.parsedValue.keyIdentifier?a=t.parsedValue.keyIdentifier:(t.parsedValue.authorityCertIssuer&&(i=t.parsedValue.authorityCertIssuer),t.parsedValue.authorityCertSerialNumber&&(n=t.parsedValue.authorityCertSerialNumber));break}function checkCertificate(t){if(null!==a&&t.extensions){let e=!1;for(const r of t.extensions)if("2.5.29.14"===r.extnID&&r.parsedValue){e=!0,BufferSourceConverter.isEqual(r.parsedValue.valueBlock.valueHex,a.valueBlock.valueHexView)&&s.push(t);break}if(e)return}let r=!1;null!==n&&(r=t.serialNumber.isEqual(n)),null!==i?t.subject.isEqual(i)&&r&&s.push(t):e.issuer.isEqual(t.subject)&&s.push(t)}for(const e of t.trustedCerts)checkCertificate(e);for(const e of t.certs)checkCertificate(e);for(let t=s.length-1;t>=0;t--)try{!1===await e.verify(s[t],r)&&s.splice(t,1)}catch(e){s.splice(t,1)}return s}defaultValues(e){switch(e){case Kl:case Ul:case Tl:case Ll:return[];case Hl:return new Date;case ql:return CertificateChainValidationEngine.defaultFindOrigin;case jl:return this.defaultFindIssuer;default:throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${e}`)}}async sort(e=!1,t=getCrypto(!0)){const r=[],buildPath=async(e,t)=>{const r=[];function checkUnique(e){let t=!0;for(let r=0;r<e.length;r++){for(let s=0;s<e.length;s++)if(s!==r&&e[r]===e[s]){t=!1;break}if(!t)break}return t}if(function(e,t){for(let r=0;r<t.length;r++)if(BufferSourceConverter.isEqual(e.tbsView,t[r].tbsView))return!0;return!1}(e,this.trustedCerts))return[[e]];const s=await this.findIssuer(e,this,t);if(0===s.length)throw new Error("No valid certificate paths found");for(let a=0;a<s.length;a++){if(BufferSourceConverter.isEqual(s[a].tbsView,e.tbsView)){r.push([s[a]]);continue}const i=await buildPath(s[a],t);for(let e=0;e<i.length;e++){const t=i[e].slice();t.splice(0,0,s[a]),checkUnique(t)?r.push(t):r.push(i[e])}}return r},findCRL=async e=>{const s=[],a=[],i=[];if(s.push(...r.filter(t=>e.issuer.isEqual(t.subject))),0===s.length)return{status:1,statusMessage:"No certificate's issuers"};if(a.push(...this.crls.filter(t=>t.issuer.isEqual(e.issuer))),0===a.length)return{status:2,statusMessage:"No CRLs for specific certificate issuer"};for(let e=0;e<a.length;e++){const r=a[e];if(!(r.nextUpdate&&r.nextUpdate.value<this.checkDate))for(let r=0;r<s.length;r++)try{if(await a[e].verify({issuerCertificate:s[r]},t)){i.push({crl:a[e],certificate:s[r]});break}}catch(e){}}return i.length?{status:0,statusMessage:ke,result:i}:{status:3,statusMessage:"No valid CRLs found"}},findOCSP=async(e,r)=>{const s=t.getAlgorithmByOID(e.signatureAlgorithm.algorithmId);if(!s.name)return 1;if(!s.hash)return 1;for(let s=0;s<this.ocsps.length;s++){const a=this.ocsps[s],i=await a.getCertificateStatus(e,r,t);if(i.isForCertificate)return 0===i.status?0:1}return 2};async function checkForCA(e,t=!1){let r=!1,s=!1,a=!1,i=!1;if(e.extensions){for(let t=0;t<e.extensions.length;t++){const n=e.extensions[t];if(n.critical&&!n.parsedValue)return{result:!1,resultCode:6,resultMessage:`Unable to parse critical certificate extension: ${n.extnID}`};if("2.5.29.15"===n.extnID){a=!0;const e=new Uint8Array(n.parsedValue.valueBlock.valueHex);4&~e[0]||(s=!0),2&~e[0]||(i=!0)}n.extnID===Xe&&"cA"in n.parsedValue&&!0===n.parsedValue.cA&&(r=!0)}if(!0===s&&!1===r)return{result:!1,resultCode:3,resultMessage:'Unable to build certificate chain - using "keyCertSign" flag set without BasicConstraints'};if(!0===a&&!0===r&&!1===s)return{result:!1,resultCode:4,resultMessage:'Unable to build certificate chain - "keyCertSign" flag was not set'};if(!0===r&&!0===a&&t&&!1===i)return{result:!1,resultCode:5,resultMessage:'Unable to build certificate chain - intermediate certificate must have "cRLSign" key usage flag'}}return!1===r?{result:!1,resultCode:7,resultMessage:"Unable to build certificate chain - more than one possible end-user certificate"}:{result:!0,resultCode:0,resultMessage:ke}}r.push(...this.trustedCerts),r.push(...this.certs);for(let e=0;e<r.length;e++)for(let t=0;t<r.length;t++)if(e!==t&&BufferSourceConverter.isEqual(r[e].tbsView,r[t].tbsView)){r.splice(t,1),e=0;break}const s=r[r.length-1];let a;const i=[s];if(a=await buildPath(s,t),0===a.length)throw new ChainValidationError(Ml.noPath,"Unable to find certificate path");for(let e=a.length-1;e>=0;e--){let t=!1;for(let r=0;r<a[e].length;r++){const s=a[e][r];for(let e=0;e<this.trustedCerts.length;e++)if(BufferSourceConverter.isEqual(s.tbsView,this.trustedCerts[e].tbsView)){t=!0;break}if(t)break}t||a.splice(e,1)}if(0===a.length)throw new ChainValidationError(Ml.noValidPath,"No valid certificate paths found");let n=a[0].length,o=0;for(let e=0;e<a.length;e++)a[e].length<n&&(n=a[e].length,o=e);for(let e=0;e<a[o].length;e++)i.push(a[o][e]);if(a=await(async(t,r)=>{for(let e=0;e<t.length;e++)if(t[e].notBefore.value>r||t[e].notAfter.value<r)return{result:!1,resultCode:8,resultMessage:"The certificate is either not yet valid or expired"};if(t.length<2)return{result:!1,resultCode:9,resultMessage:"Too short certificate path"};for(let e=t.length-2;e>=0;e--)if(!1===t[e].issuer.isEqual(t[e].subject)&&!1===t[e].issuer.isEqual(t[e+1].subject))return{result:!1,resultCode:10,resultMessage:"Incorrect name chaining"};if(0!==this.crls.length||0!==this.ocsps.length)for(let r=0;r<t.length-1;r++){let s=2,a={status:0,statusMessage:ke};if(0!==this.ocsps.length)switch(s=await findOCSP(t[r],t[r+1]),s){case 0:continue;case 1:return{result:!1,resultCode:12,resultMessage:"One of certificates was revoked via OCSP response"}}if(0!==this.crls.length){if(a=await findCRL(t[r]),0===a.status&&a.result)for(let e=0;e<a.result.length;e++){if(a.result[e].crl.isCertificateRevoked(t[r]))return{result:!1,resultCode:12,resultMessage:"One of certificates had been revoked"};if(!1===(await checkForCA(a.result[e].certificate,!0)).result)return{result:!1,resultCode:13,resultMessage:"CRL issuer certificate is not a CA certificate or does not have crlSign flag"}}else if(!1===e)throw new ChainValidationError(Ml.noRevocation,`No revocation values found for one of certificates: ${a.statusMessage}`)}else if(2===s)return{result:!1,resultCode:11,resultMessage:"No revocation values found for one of certificates"};if(2===s&&2===a.status&&e){const e=t[r+1];let s=!1;if(e.extensions)for(const t of e.extensions)switch(t.extnID){case st:case at:case ut:s=!0}if(s)throw new ChainValidationError(Ml.noRevocation,`No revocation values found for one of certificates: ${a.statusMessage}`)}}for(const[e,r]of t.entries()){if(!e)continue;if(!(await checkForCA(r)).result)return{result:!1,resultCode:14,resultMessage:"One of intermediate certificates is not a CA certificate"}}return{result:!0}})(i,this.checkDate),!1===a.result)throw a;return i}async verify(e={},t=getCrypto(!0)){function compareDNSName(e,t){const r=stringPrep(e),s=stringPrep(t),a=r.split("."),i=s.split("."),n=a.length,o=i.length;if(0===n||0===o||n<o)return!1;for(let e=0;e<n;e++)if(0===a[e].length)return!1;for(let e=0;e<o;e++)if(0===i[e].length){if(0===e){if(1===o)return!1;continue}return!1}for(let e=0;e<o;e++)if(0!==i[o-1-e].length&&0!==a[n-1-e].localeCompare(i[o-1-e]))return!1;return!0}function compareRFC822Name(e,t){const r=stringPrep(e),s=stringPrep(t),a=r.split("@"),i=s.split("@");if(0===a.length||0===i.length||a.length<i.length)return!1;if(1===i.length){if(compareDNSName(a[1],i[0])){const e=a[1].split("."),t=i[0].split(".");return 0===t[0].length||e.length===t.length}return!1}return 0===r.localeCompare(s)}function compareUniformResourceIdentifier(e,t){let r=stringPrep(e);const s=stringPrep(t),a=r.split("/");if(s.split("/").length>1)return!1;if(a.length>1)for(let e=0;e<a.length;e++)if(a[e].length>0&&":"!==a[e].charAt(a[e].length-1)){r=a[e].split(":")[0];break}if(compareDNSName(r,s)){const e=r.split("."),t=s.split(".");return 0===t[0].length||e.length===t.length}return!1}function compareIPAddress(e,t){const r=e.valueBlock.valueHexView,s=t.valueBlock.valueHexView;if(4===r.length&&8===s.length){for(let e=0;e<4;e++)if((r[e]^s[e])&s[e+4])return!1;return!0}if(16===r.length&&32===s.length){for(let e=0;e<16;e++)if((r[e]^s[e])&s[e+16])return!1;return!0}return!1}function compareDirectoryName(e,t){if(0===e.typesAndValues.length||0===t.typesAndValues.length)return!0;if(e.typesAndValues.length<t.typesAndValues.length)return!1;let r=!0,s=0;for(let a=0;a<t.typesAndValues.length;a++){let i=!1;for(let n=s;n<e.typesAndValues.length;n++)if(i=e.typesAndValues[n].isEqual(t.typesAndValues[a]),e.typesAndValues[n].type===t.typesAndValues[a].type&&(r=r&&i),!0===i){if(0===s||s===n){s=n+1;break}return!1}if(!1===i)return!1}return 0!==s&&r}try{if(0===this.certs.length)throw new Error("Empty certificate array");const r=e.passedWhenNotRevValues||!1,s=e.initialPolicySet||[nt],a=e.initialExplicitPolicy||!1,i=e.initialPolicyMappingInhibit||!1,n=e.initialInhibitPolicy||!1,o=e.initialPermittedSubtreesSet||[],l=e.initialExcludedSubtreesSet||[],c=e.initialRequiredNameForms||[];let u=a,h=i,m=n;const f=[!1,!1,!1];let g=0,d=0,p=0,S=o,y=l;const w=c;let v=1;this.certs=await this.sort(r,t);const b=[];b.push(nt);const A=[],k=new Array(this.certs.length-1);for(let e=0;e<this.certs.length-1;e++)k[e]=!0;A.push(k);const C=new Array(this.certs.length-1),V=new Array(this.certs.length-1);let B=u?this.certs.length-1:-1;for(let e=this.certs.length-2;e>=0;e--,v++){const t=this.certs[e];if(t.extensions){for(let r=0;r<t.extensions.length;r++){const s=t.extensions[r];if(s.extnID===it){V[e]=s.parsedValue;for(let t=0;t<b.length;t++)if(b[t]===nt){delete A[t][e];break}for(let t=0;t<s.parsedValue.certificatePolicies.length;t++){let r=-1;const a=s.parsedValue.certificatePolicies[t].policyIdentifier;for(let e=0;e<b.length;e++)if(a===b[e]){r=e;break}if(-1===r){b.push(a);const t=new Array(this.certs.length-1);t[e]=!0,A.push(t)}else A[r][e]=!0}}if(s.extnID===ot){if(h)return{result:!1,resultCode:98,resultMessage:"Policy mapping prohibited"};C[e]=s.parsedValue}s.extnID===ct&&!1===u&&(0===s.parsedValue.requireExplicitPolicy?(u=!0,B=e):!1===f[0]?(f[0]=!0,g=s.parsedValue.requireExplicitPolicy):g=g>s.parsedValue.requireExplicitPolicy?s.parsedValue.requireExplicitPolicy:g,0===s.parsedValue.inhibitPolicyMapping?h=!0:!1===f[1]?(f[1]=!0,d=s.parsedValue.inhibitPolicyMapping+1):d=d>s.parsedValue.inhibitPolicyMapping+1?s.parsedValue.inhibitPolicyMapping+1:d),"2.5.29.54"===s.extnID&&!1===m&&(0===s.parsedValue.valueBlock.valueDec?m=!0:!1===f[2]?(f[2]=!0,p=s.parsedValue.valueBlock.valueDec):p=p>s.parsedValue.valueBlock.valueDec?s.parsedValue.valueBlock.valueDec:p)}if(!0===m){let t=-1;for(let e=0;e<b.length;e++)if(b[e]===nt){t=e;break}-1!==t&&delete A[0][e]}!1===u&&!0===f[0]&&(g--,0===g&&(u=!0,B=e,f[0]=!1)),!1===h&&!0===f[1]&&(d--,0===d&&(h=!0,f[1]=!1)),!1===m&&!0===f[2]&&(p--,0===p&&(m=!0,f[2]=!1))}}for(let e=0;e<this.certs.length-1;e++)if(e<this.certs.length-2&&void 0!==C[e+1])for(let t=0;t<C[e+1].mappings.length;t++){if(C[e+1].mappings[t].issuerDomainPolicy===nt||C[e+1].mappings[t].subjectDomainPolicy===nt)return{result:!1,resultCode:99,resultMessage:'The "anyPolicy" should not be a part of policy mapping scheme'};let r=-1,s=-1;for(let a=0;a<b.length;a++)b[a]===C[e+1].mappings[t].issuerDomainPolicy&&(r=a),b[a]===C[e+1].mappings[t].subjectDomainPolicy&&(s=a);void 0!==A[r][e]&&delete A[r][e];for(let a=0;a<V[e].certificatePolicies.length;a++)if(C[e+1].mappings[t].subjectDomainPolicy===V[e].certificatePolicies[a].policyIdentifier&&-1!==r&&-1!==s)for(let t=0;t<=e;t++)void 0!==A[s][t]&&(A[r][t]=!0,delete A[s][t])}for(let e=0;e<b.length;e++)if(b[e]===nt)for(let t=0;t<B;t++)delete A[e][t];const I=[];for(let e=0;e<A.length;e++){let t=!0;for(let r=0;r<this.certs.length-1;r++){let s=!1;if(r<B&&b[e]===nt&&b.length>1){t=!1;break}if(void 0===A[e][r]){if(r>=B)for(let e=0;e<b.length;e++)if(b[e]===nt){!0===A[e][r]&&(s=!0);break}if(!s){t=!1;break}}}!0===t&&I.push(b[e])}let N=[];if(1===s.length&&s[0]===nt&&!1===u)N=s;else if(1===I.length&&I[0]===nt)N=s;else for(let e=0;e<I.length;e++)for(let t=0;t<s.length;t++)if(s[t]===I[e]||s[t]===nt){N.push(I[e]);break}const P={result:N.length>0,resultCode:0,resultMessage:N.length>0?ke:'Zero "userConstrPolicies" array, no intersections with "authConstrPolicies"',authConstrPolicies:I,userConstrPolicies:N,explicitPolicyIndicator:u,policyMappings:C,certificatePath:this.certs};if(0===N.length)return P;if(!1===P.result)return P;v=1;for(let e=this.certs.length-2;e>=0;e--,v++){const t=this.certs[e];let r=[],s=[],a=[];if(t.extensions)for(let e=0;e<t.extensions.length;e++){const i=t.extensions[e];i.extnID===rt&&("permittedSubtrees"in i.parsedValue&&(s=s.concat(i.parsedValue.permittedSubtrees)),"excludedSubtrees"in i.parsedValue&&(a=a.concat(i.parsedValue.excludedSubtrees))),i.extnID===Ze&&(r=r.concat(i.parsedValue.altNames))}let i=w.length<=0;for(let e=0;e<w.length;e++)switch(w[e].base.type){case 4:if(w[e].base.value.typesAndValues.length!==t.subject.typesAndValues.length)continue;i=!0;for(let r=0;r<t.subject.typesAndValues.length;r++)if(t.subject.typesAndValues[r].type!==w[e].base.value.typesAndValues[r].type){i=!1;break}if(!0===i)break}if(!1===i)throw P.result=!1,P.resultCode=21,P.resultMessage="No necessary name form found",P;const n=[[],[],[],[],[]];for(let e=0;e<S.length;e++)switch(S[e].base.type){case 1:n[0].push(S[e]);break;case 2:n[1].push(S[e]);break;case 4:n[2].push(S[e]);break;case 6:n[3].push(S[e]);break;case 7:n[4].push(S[e])}for(let e=0;e<5;e++){let s=!1,a=!1;const i=n[e];for(let n=0;n<i.length;n++){switch(e){case 0:if(r.length>0)for(let e=0;e<r.length;e++)1===r[e].type&&(a=!0,s=s||compareRFC822Name(r[e].value,i[n].base.value));else for(let e=0;e<t.subject.typesAndValues.length;e++)"1.2.840.113549.1.9.1"!==t.subject.typesAndValues[e].type&&"0.9.2342.19200300.100.1.3"!==t.subject.typesAndValues[e].type||(a=!0,s=s||compareRFC822Name(t.subject.typesAndValues[e].value.valueBlock.value,i[n].base.value));break;case 1:if(r.length>0)for(let e=0;e<r.length;e++)2===r[e].type&&(a=!0,s=s||compareDNSName(r[e].value,i[n].base.value));break;case 2:a=!0,s=compareDirectoryName(t.subject,i[n].base.value);break;case 3:if(r.length>0)for(let e=0;e<r.length;e++)6===r[e].type&&(a=!0,s=s||compareUniformResourceIdentifier(r[e].value,i[n].base.value));break;case 4:if(r.length>0)for(let e=0;e<r.length;e++)7===r[e].type&&(a=!0,s=s||compareIPAddress(r[e].value,i[n].base.value))}if(s)break}if(!1===s&&i.length>0&&a)throw P.result=!1,P.resultCode=41,P.resultMessage='Failed to meet "permitted sub-trees" name constraint',P}let o=!1;for(let e=0;e<y.length;e++){switch(y[e].base.type){case 1:if(r.length>=0)for(let t=0;t<r.length;t++)1===r[t].type&&(o=o||compareRFC822Name(r[t].value,y[e].base.value));else for(let r=0;r<t.subject.typesAndValues.length;r++)"1.2.840.113549.1.9.1"!==t.subject.typesAndValues[r].type&&"0.9.2342.19200300.100.1.3"!==t.subject.typesAndValues[r].type||(o=o||compareRFC822Name(t.subject.typesAndValues[r].value.valueBlock.value,y[e].base.value));break;case 2:if(r.length>0)for(let t=0;t<r.length;t++)2===r[t].type&&(o=o||compareDNSName(r[t].value,y[e].base.value));break;case 4:o=o||compareDirectoryName(t.subject,y[e].base.value);break;case 6:if(r.length>0)for(let t=0;t<r.length;t++)6===r[t].type&&(o=o||compareUniformResourceIdentifier(r[t].value,y[e].base.value));break;case 7:if(r.length>0)for(let t=0;t<r.length;t++)7===r[t].type&&(o=o||compareIPAddress(r[t].value,y[e].base.value))}if(o)break}if(!0===o)throw P.result=!1,P.resultCode=42,P.resultMessage='Failed to meet "excluded sub-trees" name constraint',P;S=S.concat(s),y=y.concat(a)}return P}catch(e){return e instanceof Error?e instanceof ChainValidationError?{result:!1,resultCode:e.code,resultMessage:e.message,error:e}:{result:!1,resultCode:Ml.unknown,resultMessage:e.message,error:e}:e&&"object"==typeof e&&"resultMessage"in e?e:{result:!1,resultCode:-1,resultMessage:`${e}`}}}}const Jl="tbsResponseData",_l="signatureAlgorithm",Fl="signature",$l="certs",Wl="BasicOCSPResponse",Gl=`${Wl}.${Jl}`,zl=`${Wl}.${_l}`,Ql=`${Wl}.${Fl}`,Zl=`${Wl}.${$l}`,Yl=[Gl,zl,Ql,Zl];class BasicOCSPResponse extends PkiObject{constructor(e={}){super(),this.tbsResponseData=getParametersValue(e,Jl,BasicOCSPResponse.defaultValues(Jl)),this.signatureAlgorithm=getParametersValue(e,_l,BasicOCSPResponse.defaultValues(_l)),this.signature=getParametersValue(e,Fl,BasicOCSPResponse.defaultValues(Fl)),$l in e&&(this.certs=getParametersValue(e,$l,BasicOCSPResponse.defaultValues($l))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Jl:return new ResponseData;case _l:return new AlgorithmIdentifier;case Fl:return new BitString;case $l:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"type":{let e=ResponseData.compareWithDefault("tbs",t.tbs)&&ResponseData.compareWithDefault("responderID",t.responderID)&&ResponseData.compareWithDefault("producedAt",t.producedAt)&&ResponseData.compareWithDefault("responses",t.responses);return"responseExtensions"in t&&(e=e&&ResponseData.compareWithDefault("responseExtensions",t.responseExtensions)),e}case _l:return t.algorithmId===ke&&"algorithmParams"in t==!1;case Fl:return t.isEqual(BasicOCSPResponse.defaultValues(e));case $l:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Wl,value:[ResponseData.schema(t.tbsResponseData||{names:{blockName:Gl}}),AlgorithmIdentifier.schema(t.signatureAlgorithm||{names:{blockName:zl}}),new BitString({name:t.signature||Ql}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Sequence({value:[new Repeated({name:Zl,value:Certificate.schema(t.certs||{})})]})]})]})}fromSchema(e){clearProps(e,Yl);const t=compareSchema(e,e,BasicOCSPResponse.schema());AsnError.assertSchema(t,this.className),this.tbsResponseData=new ResponseData({schema:t.result[Gl]}),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result[zl]}),this.signature=t.result[Ql],Zl in t.result&&(this.certs=Array.from(t.result[Zl],e=>new Certificate({schema:e})))}toSchema(){const e=[];return e.push(this.tbsResponseData.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Sequence({value:Array.from(this.certs,e=>e.toSchema())})]})),new Sequence({value:e})}toJSON(){const e={tbsResponseData:this.tbsResponseData.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,e=>e.toJSON())),e}async getCertificateStatus(e,t,r=getCrypto(!0)){const s={isForCertificate:!1,status:2},a={},i=[];for(const s of this.tbsResponseData.responses){const n=r.getAlgorithmByOID(s.certID.hashAlgorithm.algorithmId,!0,"CertID.hashAlgorithm");if(!a[n.name]){a[n.name]=1;const s=new CertID;i.push(s),await s.createForCertificate(e,{hashAlgorithm:n.name,issuerCertificate:t},r)}}for(const e of this.tbsResponseData.responses)for(const t of i)if(e.certID.isEqual(t)){s.isForCertificate=!0;try{switch(e.certStatus.idBlock.isConstructed){case!0:1===e.certStatus.idBlock.tagNumber&&(s.status=1);break;case!1:switch(e.certStatus.idBlock.tagNumber){case 0:s.status=0;break;case 2:s.status=2}}}catch(e){}return s}return s}async sign(e,t="SHA-1",r=getCrypto(!0)){if(!e)throw new Error("Need to provide a private key for signing");const s=await r.getSignatureParameters(e,t),a=s.parameters.algorithm;if(!("name"in a))throw new Error("Empty algorithm");this.signatureAlgorithm=s.signatureAlgorithm,this.tbsResponseData.tbsView=new Uint8Array(this.tbsResponseData.toSchema(!0).toBER());const i=await r.signWithPrivateKey(this.tbsResponseData.tbsView,e,{algorithm:a});this.signature=new BitString({valueHex:i})}async verify(e={},t=getCrypto(!0)){let r=null,s=-1;const a=e.trustedCerts||[];if(!this.certs)throw new Error("No certificates attached to the BasicOCSPResponse");switch(!0){case this.tbsResponseData.responderID instanceof RelativeDistinguishedNames:for(const[e,t]of this.certs.entries())if(t.subject.isEqual(this.tbsResponseData.responderID)){s=e;break}break;case this.tbsResponseData.responderID instanceof OctetString:for(const[e,r]of this.certs.entries()){if(isEqualBuffer(await t.digest({name:"sha-1"},r.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView),this.tbsResponseData.responderID.valueBlock.valueHex)){s=e;break}}break;default:throw new Error("Wrong value for responderID")}if(-1===s)throw new Error("Correct certificate was not found in OCSP response");r=this.certs[s];const i=[r];for(const e of this.certs){const t=await checkCA(e,r);t&&i.push(t)}const n=new CertificateChainValidationEngine({certs:i,trustedCerts:a});if(!(await n.verify({},t)).result)throw new Error("Validation of signer's certificate failed");return t.verifyWithPublicKey(this.tbsResponseData.tbsView,this.signature,this.certs[s].subjectPublicKeyInfo,this.signatureAlgorithm)}}BasicOCSPResponse.CLASS_NAME="BasicOCSPResponse";const Xl="tbs",ec="version",tc="subject",rc="subjectPublicKeyInfo",sc="attributes",ac="signatureAlgorithm",ic="signatureValue",nc="CertificationRequestInfo",oc=`${nc}.version`,lc=`${nc}.subject`,cc=`${nc}.subjectPublicKeyInfo`,uc=`${nc}.attributes`,hc=[nc,oc,lc,cc,uc,ac,ic];function CertificationRequestInfo(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.CertificationRequestInfo||nc,value:[new Integer({name:t.CertificationRequestInfoVersion||oc}),RelativeDistinguishedNames.schema(t.subject||{names:{blockName:lc}}),PublicKeyInfo.schema({names:{blockName:cc}}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({optional:!0,name:t.CertificationRequestInfoAttributes||uc,value:Attribute.schema(t.attributes||{})})]})]})}class CertificationRequest extends PkiObject{get tbs(){return BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(getParametersValue(e,Xl,CertificationRequest.defaultValues(Xl))),this.version=getParametersValue(e,ec,CertificationRequest.defaultValues(ec)),this.subject=getParametersValue(e,tc,CertificationRequest.defaultValues(tc)),this.subjectPublicKeyInfo=getParametersValue(e,rc,CertificationRequest.defaultValues(rc)),sc in e&&(this.attributes=getParametersValue(e,sc,CertificationRequest.defaultValues(sc))),this.signatureAlgorithm=getParametersValue(e,ac,CertificationRequest.defaultValues(ac)),this.signatureValue=getParametersValue(e,ic,CertificationRequest.defaultValues(ic)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Xl:return Ae;case ec:return 0;case tc:return new RelativeDistinguishedNames;case rc:return new PublicKeyInfo;case sc:return[];case ac:return new AlgorithmIdentifier;case ic:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({value:[CertificationRequestInfo(t.certificationRequestInfo||{}),new Sequence({name:t.signatureAlgorithm||ac,value:[new ObjectIdentifier,new Any({optional:!0})]}),new BitString({name:t.signatureValue||ic})]})}fromSchema(e){clearProps(e,hc);const t=compareSchema(e,e,CertificationRequest.schema());AsnError.assertSchema(t,this.className),this.tbsView=t.result.CertificationRequestInfo.valueBeforeDecodeView,this.version=t.result[oc].valueBlock.valueDec,this.subject=new RelativeDistinguishedNames({schema:t.result[lc]}),this.subjectPublicKeyInfo=new PublicKeyInfo({schema:t.result[cc]}),uc in t.result&&(this.attributes=Array.from(t.result[uc],e=>new Attribute({schema:e}))),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[new Integer({value:this.version}),this.subject.toSchema(),this.subjectPublicKeyInfo.toSchema()];return sc in this&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes||[],e=>e.toSchema())})),new Sequence({value:e})}toSchema(e=!1){let t;if(!1===e){if(0===this.tbsView.byteLength)return CertificationRequest.schema();const e=fromBER(this.tbsView);AsnError.assert(e,"PKCS#10 Certificate Request"),t=e.result}else t=this.encodeTBS();return new Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:Convert.ToHex(this.tbsView),version:this.version,subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return sc in this&&(e.attributes=Array.from(this.attributes||[],e=>e.toJSON())),e}async sign(e,t="SHA-1",r=getCrypto(!0)){if(!e)throw new Error("Need to provide a private key for signing");const s=await r.getSignatureParameters(e,t),a=s.parameters;this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());const i=await r.signWithPrivateKey(this.tbsView,e,a);this.signatureValue=new BitString({valueHex:i})}async verify(e=getCrypto(!0)){return e.verifyWithPublicKey(this.tbsView,this.signatureValue,this.subjectPublicKeyInfo,this.signatureAlgorithm)}async getPublicKey(e,t=getCrypto(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}}CertificationRequest.CLASS_NAME="CertificationRequest";const mc="digestAlgorithm",fc="digest",gc=[mc,fc];class DigestInfo extends PkiObject{constructor(e={}){super(),this.digestAlgorithm=getParametersValue(e,mc,DigestInfo.defaultValues(mc)),this.digest=getParametersValue(e,fc,DigestInfo.defaultValues(fc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case mc:return new AlgorithmIdentifier;case fc:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case mc:return AlgorithmIdentifier.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case fc:return t.isEqual(DigestInfo.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[AlgorithmIdentifier.schema(t.digestAlgorithm||{names:{blockName:mc}}),new OctetString({name:t.digest||fc})]})}fromSchema(e){clearProps(e,gc);const t=compareSchema(e,e,DigestInfo.schema({names:{digestAlgorithm:{names:{blockName:mc}},digest:fc}}));AsnError.assertSchema(t,this.className),this.digestAlgorithm=new AlgorithmIdentifier({schema:t.result.digestAlgorithm}),this.digest=t.result.digest}toSchema(){return new Sequence({value:[this.digestAlgorithm.toSchema(),this.digest]})}toJSON(){return{digestAlgorithm:this.digestAlgorithm.toJSON(),digest:this.digest.toJSON()}}}DigestInfo.CLASS_NAME="DigestInfo";const dc="eContentType",pc="eContent",Sc=[dc,pc];class EncapsulatedContentInfo extends PkiObject{constructor(e={}){if(super(),this.eContentType=getParametersValue(e,dc,EncapsulatedContentInfo.defaultValues(dc)),pc in e&&(this.eContent=getParametersValue(e,pc,EncapsulatedContentInfo.defaultValues(pc)),1===this.eContent.idBlock.tagClass&&4===this.eContent.idBlock.tagNumber&&!1===this.eContent.idBlock.isConstructed)){const e=new OctetString({idBlock:{isConstructed:!0},isConstructed:!0});let t=0;const r=this.eContent.valueBlock.valueHexView.slice().buffer;let s=r.byteLength;for(;s>0;){const a=new Uint8Array(r,t,t+65536>r.byteLength?r.byteLength-t:65536),i=new ArrayBuffer(a.length),n=new Uint8Array(i);for(let e=0;e<n.length;e++)n[e]=a[e];e.valueBlock.value.push(new OctetString({valueHex:i})),s-=a.length,t+=a.length}this.eContent=e}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case dc:return ke;case pc:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case dc:return t===ke;case pc:return 1===t.idBlock.tagClass&&4===t.idBlock.tagNumber&&t.isEqual(EncapsulatedContentInfo.defaultValues(pc));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.eContentType||ke}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.eContent||ke})]})]})}fromSchema(e){clearProps(e,Sc);const t=compareSchema(e,e,EncapsulatedContentInfo.schema({names:{eContentType:dc,eContent:pc}}));AsnError.assertSchema(t,this.className),this.eContentType=t.result.eContentType.valueBlock.toString(),pc in t.result&&(this.eContent=t.result.eContent)}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.eContentType})),this.eContent&&!1===EncapsulatedContentInfo.compareWithDefault(pc,this.eContent)&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.eContent]})),new Sequence({value:e})}toJSON(){const e={eContentType:this.eContentType};return this.eContent&&!1===EncapsulatedContentInfo.compareWithDefault(pc,this.eContent)&&(e.eContent=this.eContent.toJSON()),e}}EncapsulatedContentInfo.CLASS_NAME="EncapsulatedContentInfo";const yc="mac",wc="macSalt",vc="iterations",bc=[yc,wc,vc];class MacData extends PkiObject{constructor(e={}){super(),this.mac=getParametersValue(e,yc,MacData.defaultValues(yc)),this.macSalt=getParametersValue(e,wc,MacData.defaultValues(wc)),vc in e&&(this.iterations=getParametersValue(e,vc,MacData.defaultValues(vc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case yc:return new DigestInfo;case wc:return new OctetString;case vc:return 1;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case yc:return DigestInfo.compareWithDefault("digestAlgorithm",t.digestAlgorithm)&&DigestInfo.compareWithDefault("digest",t.digest);case wc:return t.isEqual(MacData.defaultValues(e));case vc:return t===MacData.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,optional:t.optional||!0,value:[DigestInfo.schema(t.mac||{names:{blockName:yc}}),new OctetString({name:t.macSalt||wc}),new Integer({optional:!0,name:t.iterations||vc})]})}fromSchema(e){clearProps(e,bc);const t=compareSchema(e,e,MacData.schema({names:{mac:{names:{blockName:yc}},macSalt:wc,iterations:vc}}));AsnError.assertSchema(t,this.className),this.mac=new DigestInfo({schema:t.result.mac}),this.macSalt=t.result.macSalt,vc in t.result&&(this.iterations=t.result.iterations.valueBlock.valueDec)}toSchema(){const e=[this.mac.toSchema(),this.macSalt];return void 0!==this.iterations&&e.push(new Integer({value:this.iterations})),new Sequence({value:e})}toJSON(){const e={mac:this.mac.toJSON(),macSalt:this.macSalt.toJSON()};return void 0!==this.iterations&&(e.iterations=this.iterations),e}}MacData.CLASS_NAME="MacData";const Ac="hashAlgorithm",kc="hashedMessage",Cc=[Ac,kc];class MessageImprint extends PkiObject{static async create(e,t,r=getCrypto(!0)){const s=r.getOIDByAlgorithm({name:e},!0,"hashAlgorithm"),a=await r.digest(e,t);return new MessageImprint({hashAlgorithm:new AlgorithmIdentifier({algorithmId:s,algorithmParams:new Null}),hashedMessage:new OctetString({valueHex:a})})}constructor(e={}){super(),this.hashAlgorithm=getParametersValue(e,Ac,MessageImprint.defaultValues(Ac)),this.hashedMessage=getParametersValue(e,kc,MessageImprint.defaultValues(kc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ac:return new AlgorithmIdentifier;case kc:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ac:return t.algorithmId===ke&&"algorithmParams"in t==!1;case kc:return 0===t.isEqual(MessageImprint.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[AlgorithmIdentifier.schema(t.hashAlgorithm||{}),new OctetString({name:t.hashedMessage||ke})]})}fromSchema(e){clearProps(e,Cc);const t=compareSchema(e,e,MessageImprint.schema({names:{hashAlgorithm:{names:{blockName:Ac}},hashedMessage:kc}}));AsnError.assertSchema(t,this.className),this.hashAlgorithm=new AlgorithmIdentifier({schema:t.result.hashAlgorithm}),this.hashedMessage=t.result.hashedMessage}toSchema(){return new Sequence({value:[this.hashAlgorithm.toSchema(),this.hashedMessage]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),hashedMessage:this.hashedMessage.toJSON()}}}MessageImprint.CLASS_NAME="MessageImprint";const Vc="reqCert",Bc="singleRequestExtensions",Ic=[Vc,Bc];class Request extends PkiObject{constructor(e={}){super(),this.reqCert=getParametersValue(e,Vc,Request.defaultValues(Vc)),Bc in e&&(this.singleRequestExtensions=getParametersValue(e,Bc,Request.defaultValues(Bc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Vc:return new CertID;case Bc:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Vc:return t.isEqual(Request.defaultValues(e));case Bc:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[CertID.schema(t.reqCert||{}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Extension.schema(t.extensions||{names:{blockName:t.singleRequestExtensions||ke}})]})]})}fromSchema(e){clearProps(e,Ic);const t=compareSchema(e,e,Request.schema({names:{reqCert:{names:{blockName:Vc}},extensions:{names:{blockName:Bc}}}}));AsnError.assertSchema(t,this.className),this.reqCert=new CertID({schema:t.result.reqCert}),Bc in t.result&&(this.singleRequestExtensions=Array.from(t.result.singleRequestExtensions.valueBlock.value,e=>new Extension({schema:e})))}toSchema(){const e=[];return e.push(this.reqCert.toSchema()),this.singleRequestExtensions&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Sequence({value:Array.from(this.singleRequestExtensions,e=>e.toSchema())})]})),new Sequence({value:e})}toJSON(){const e={reqCert:this.reqCert.toJSON()};return this.singleRequestExtensions&&(e.singleRequestExtensions=Array.from(this.singleRequestExtensions,e=>e.toJSON())),e}}Request.CLASS_NAME="Request";const Nc="tbs",Pc="version",Ec="requestorName",Dc="requestList",Oc="requestExtensions",xc="TBSRequest",Rc=`${xc}.${Pc}`,Kc=`${xc}.${Ec}`,Uc=`${xc}.requests`,Tc=`${xc}.${Oc}`,Lc=[xc,Rc,Kc,Uc,Tc];class TBSRequest extends PkiObject{get tbs(){return BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(getParametersValue(e,Nc,TBSRequest.defaultValues(Nc))),Pc in e&&(this.version=getParametersValue(e,Pc,TBSRequest.defaultValues(Pc))),Ec in e&&(this.requestorName=getParametersValue(e,Ec,TBSRequest.defaultValues(Ec))),this.requestList=getParametersValue(e,Dc,TBSRequest.defaultValues(Dc)),Oc in e&&(this.requestExtensions=getParametersValue(e,Oc,TBSRequest.defaultValues(Oc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Nc:return Ae;case Pc:return 0;case Ec:return new GeneralName;case Dc:case Oc:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Nc:return 0===t.byteLength;case Pc:return t===TBSRequest.defaultValues(e);case Ec:return t.type===GeneralName.defaultValues("type")&&0===Object.keys(t.value).length;case Dc:case Oc:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||xc,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Integer({name:t.TBSRequestVersion||Rc})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[GeneralName.schema(t.requestorName||{names:{blockName:Kc}})]}),new Sequence({name:t.requestList||"TBSRequest.requestList",value:[new Repeated({name:t.requests||Uc,value:Request.schema(t.requestNames||{})})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[Extensions.schema(t.extensions||{names:{blockName:t.requestExtensions||Tc}})]})]})}fromSchema(e){clearProps(e,Lc);const t=compareSchema(e,e,TBSRequest.schema());AsnError.assertSchema(t,this.className),this.tbsView=t.result.TBSRequest.valueBeforeDecodeView,Rc in t.result&&(this.version=t.result[Rc].valueBlock.valueDec),Kc in t.result&&(this.requestorName=new GeneralName({schema:t.result[Kc]})),this.requestList=Array.from(t.result[Uc],e=>new Request({schema:e})),Tc in t.result&&(this.requestExtensions=Array.from(t.result[Tc].valueBlock.value,e=>new Extension({schema:e})))}toSchema(e=!1){let t;if(!1===e){if(0===this.tbsView.byteLength)return TBSRequest.schema();const e=fromBER(this.tbsView);if(AsnError.assert(e,"TBS Request"),!(e.result instanceof Sequence))throw new Error("ASN.1 result should be SEQUENCE");t=e.result}else{const e=[];void 0!==this.version&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Integer({value:this.version})]})),this.requestorName&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.requestorName.toSchema()]})),e.push(new Sequence({value:Array.from(this.requestList,e=>e.toSchema())})),this.requestExtensions&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:[new Sequence({value:Array.from(this.requestExtensions,e=>e.toSchema())})]})),t=new Sequence({value:e})}return t}toJSON(){const e={};return null!=this.version&&(e.version=this.version),this.requestorName&&(e.requestorName=this.requestorName.toJSON()),e.requestList=Array.from(this.requestList,e=>e.toJSON()),this.requestExtensions&&(e.requestExtensions=Array.from(this.requestExtensions,e=>e.toJSON())),e}}TBSRequest.CLASS_NAME="TBSRequest";const Hc="signatureAlgorithm",qc="signature",jc="certs";class Signature extends PkiObject{constructor(e={}){super(),this.signatureAlgorithm=getParametersValue(e,Hc,Signature.defaultValues(Hc)),this.signature=getParametersValue(e,qc,Signature.defaultValues(qc)),jc in e&&(this.certs=getParametersValue(e,jc,Signature.defaultValues(jc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Hc:return new AlgorithmIdentifier;case qc:return new BitString;case jc:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Hc:return t.algorithmId===ke&&"algorithmParams"in t==!1;case qc:return t.isEqual(Signature.defaultValues(e));case jc:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[AlgorithmIdentifier.schema(t.signatureAlgorithm||{}),new BitString({name:t.signature||ke}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Sequence({value:[new Repeated({name:t.certs||ke,value:Certificate.schema({})})]})]})]})}fromSchema(e){clearProps(e,[Hc,qc,jc]);const t=compareSchema(e,e,Signature.schema({names:{signatureAlgorithm:{names:{blockName:Hc}},signature:qc,certs:jc}}));AsnError.assertSchema(t,this.className),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signature=t.result.signature,jc in t.result&&(this.certs=Array.from(t.result.certs,e=>new Certificate({schema:e})))}toSchema(){const e=[];return e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Sequence({value:Array.from(this.certs,e=>e.toSchema())})]})),new Sequence({value:e})}toJSON(){const e={signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,e=>e.toJSON())),e}}Signature.CLASS_NAME="Signature";const Mc="tbsRequest",Jc="optionalSignature",_c=[Mc,Jc];class OCSPRequest extends PkiObject{constructor(e={}){super(),this.tbsRequest=getParametersValue(e,Mc,OCSPRequest.defaultValues(Mc)),Jc in e&&(this.optionalSignature=getParametersValue(e,Jc,OCSPRequest.defaultValues(Jc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Mc:return new TBSRequest;case Jc:return new Signature;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Mc:return TBSRequest.compareWithDefault("tbs",t.tbs)&&TBSRequest.compareWithDefault("version",t.version)&&TBSRequest.compareWithDefault("requestorName",t.requestorName)&&TBSRequest.compareWithDefault("requestList",t.requestList)&&TBSRequest.compareWithDefault("requestExtensions",t.requestExtensions);case Jc:return Signature.compareWithDefault("signatureAlgorithm",t.signatureAlgorithm)&&Signature.compareWithDefault("signature",t.signature)&&Signature.compareWithDefault("certs",t.certs);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||"OCSPRequest",value:[TBSRequest.schema(t.tbsRequest||{names:{blockName:Mc}}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Signature.schema(t.optionalSignature||{names:{blockName:Jc}})]})]})}fromSchema(e){clearProps(e,_c);const t=compareSchema(e,e,OCSPRequest.schema());AsnError.assertSchema(t,this.className),this.tbsRequest=new TBSRequest({schema:t.result.tbsRequest}),Jc in t.result&&(this.optionalSignature=new Signature({schema:t.result.optionalSignature}))}toSchema(e=!1){const t=[];return t.push(this.tbsRequest.toSchema(e)),this.optionalSignature&&t.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.optionalSignature.toSchema()]})),new Sequence({value:t})}toJSON(){const e={tbsRequest:this.tbsRequest.toJSON()};return this.optionalSignature&&(e.optionalSignature=this.optionalSignature.toJSON()),e}async createForCertificate(e,t,r=getCrypto(!0)){const s=new CertID;await s.createForCertificate(e,t,r),this.tbsRequest.requestList.push(new Request({reqCert:s}))}async sign(e,t="SHA-1",r=getCrypto(!0)){if(ParameterError.assertEmpty(e,"privateKey","OCSPRequest.sign method"),!this.optionalSignature)throw new Error('Need to create "optionalSignature" field before signing');const s=await r.getSignatureParameters(e,t),a=s.parameters;this.optionalSignature.signatureAlgorithm=s.signatureAlgorithm;const i=this.tbsRequest.toSchema(!0).toBER(!1),n=await r.signWithPrivateKey(i,e,a);this.optionalSignature.signature=new BitString({valueHex:n})}verify(){}}OCSPRequest.CLASS_NAME="OCSPRequest";const Fc="responseType",$c="response",Wc=[Fc,$c];class ResponseBytes extends PkiObject{constructor(e={}){super(),this.responseType=getParametersValue(e,Fc,ResponseBytes.defaultValues(Fc)),this.response=getParametersValue(e,$c,ResponseBytes.defaultValues($c)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Fc:return ke;case $c:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Fc:return t===ke;case $c:return t.isEqual(ResponseBytes.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new ObjectIdentifier({name:t.responseType||ke}),new OctetString({name:t.response||ke})]})}fromSchema(e){clearProps(e,Wc);const t=compareSchema(e,e,ResponseBytes.schema({names:{responseType:Fc,response:$c}}));AsnError.assertSchema(t,this.className),this.responseType=t.result.responseType.valueBlock.toString(),this.response=t.result.response}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.responseType}),this.response]})}toJSON(){return{responseType:this.responseType,response:this.response.toJSON()}}}ResponseBytes.CLASS_NAME="ResponseBytes";const Gc="responseStatus",zc="responseBytes";class OCSPResponse extends PkiObject{constructor(e={}){super(),this.responseStatus=getParametersValue(e,Gc,OCSPResponse.defaultValues(Gc)),zc in e&&(this.responseBytes=getParametersValue(e,zc,OCSPResponse.defaultValues(zc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Gc:return new Enumerated;case zc:return new ResponseBytes;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Gc:return t.isEqual(OCSPResponse.defaultValues(e));case zc:return ResponseBytes.compareWithDefault("responseType",t.responseType)&&ResponseBytes.compareWithDefault("response",t.response);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||"OCSPResponse",value:[new Enumerated({name:t.responseStatus||Gc}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[ResponseBytes.schema(t.responseBytes||{names:{blockName:zc}})]})]})}fromSchema(e){clearProps(e,[Gc,zc]);const t=compareSchema(e,e,OCSPResponse.schema());AsnError.assertSchema(t,this.className),this.responseStatus=t.result.responseStatus,zc in t.result&&(this.responseBytes=new ResponseBytes({schema:t.result.responseBytes}))}toSchema(){const e=[];return e.push(this.responseStatus),this.responseBytes&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.responseBytes.toSchema()]})),new Sequence({value:e})}toJSON(){const e={responseStatus:this.responseStatus.toJSON()};return this.responseBytes&&(e.responseBytes=this.responseBytes.toJSON()),e}async getCertificateStatus(e,t,r=getCrypto(!0)){let s;const a={isForCertificate:!1,status:2};if(!this.responseBytes)return a;if(this.responseBytes.responseType!==yt)return a;try{const e=fromBER(this.responseBytes.response.valueBlock.valueHexView);AsnError.assert(e,"Basic OCSP response"),s=new BasicOCSPResponse({schema:e.result})}catch(e){return a}return s.getCertificateStatus(e,t,r)}async sign(e,t,r=getCrypto(!0)){var s;if(this.responseBytes&&this.responseBytes.responseType===yt){return BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView).sign(e,t,r)}throw new Error(`Unknown ResponseBytes type: ${(null===(s=this.responseBytes)||void 0===s?void 0:s.responseType)||"Unknown"}`)}async verify(e=null,t=getCrypto(!0)){var r;if(zc in this==!1)throw new Error("Empty ResponseBytes field");if(this.responseBytes&&this.responseBytes.responseType===yt){const r=BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView);return null!==e&&(r.certs||(r.certs=[]),r.certs.push(e)),r.verify({},t)}throw new Error(`Unknown ResponseBytes type: ${(null===(r=this.responseBytes)||void 0===r?void 0:r.responseType)||"Unknown"}`)}}OCSPResponse.CLASS_NAME="OCSPResponse";const Qc="type",Zc="attributes",Yc="encodedValue",Xc=[Zc];class SignedAndUnsignedAttributes extends PkiObject{constructor(e={}){super(),this.type=getParametersValue(e,Qc,SignedAndUnsignedAttributes.defaultValues(Qc)),this.attributes=getParametersValue(e,Zc,SignedAndUnsignedAttributes.defaultValues(Zc)),this.encodedValue=getParametersValue(e,Yc,SignedAndUnsignedAttributes.defaultValues(Yc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Qc:return-1;case Zc:return[];case Yc:return Ae;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Qc:return t===SignedAndUnsignedAttributes.defaultValues(Qc);case Zc:return 0===t.length;case Yc:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Constructed({name:t.blockName||ke,optional:!0,idBlock:{tagClass:3,tagNumber:t.tagNumber||0},value:[new Repeated({name:t.attributes||ke,value:Attribute.schema()})]})}fromSchema(e){clearProps(e,Xc);const t=compareSchema(e,e,SignedAndUnsignedAttributes.schema({names:{tagNumber:this.type,attributes:Zc}}));AsnError.assertSchema(t,this.className),this.type=t.result.idBlock.tagNumber,this.encodedValue=BufferSourceConverter.toArrayBuffer(t.result.valueBeforeDecodeView);if(new Uint8Array(this.encodedValue)[0]=49,Zc in t.result!=!1)this.attributes=Array.from(t.result.attributes,e=>new Attribute({schema:e}));else if(0===this.type)throw new Error("Wrong structure of SignedUnsignedAttributes")}toSchema(){if(SignedAndUnsignedAttributes.compareWithDefault(Qc,this.type)||SignedAndUnsignedAttributes.compareWithDefault(Zc,this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:this.type},value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){if(SignedAndUnsignedAttributes.compareWithDefault(Qc,this.type)||SignedAndUnsignedAttributes.compareWithDefault(Zc,this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return{type:this.type,attributes:Array.from(this.attributes,e=>e.toJSON())}}}SignedAndUnsignedAttributes.CLASS_NAME="SignedAndUnsignedAttributes";const eu="version",tu="sid",ru="digestAlgorithm",su="signedAttrs",au="signatureAlgorithm",iu="signature",nu="unsignedAttrs",ou="SignerInfo",lu=`${ou}.${eu}`,cu=`${ou}.${tu}`,uu=`${ou}.${ru}`,hu=`${ou}.${su}`,mu=`${ou}.${au}`,fu=`${ou}.${iu}`,gu=`${ou}.${nu}`,du=[lu,cu,uu,hu,mu,fu,gu];class SignerInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,eu,SignerInfo.defaultValues(eu)),this.sid=getParametersValue(e,tu,SignerInfo.defaultValues(tu)),this.digestAlgorithm=getParametersValue(e,ru,SignerInfo.defaultValues(ru)),su in e&&(this.signedAttrs=getParametersValue(e,su,SignerInfo.defaultValues(su))),this.signatureAlgorithm=getParametersValue(e,au,SignerInfo.defaultValues(au)),this.signature=getParametersValue(e,iu,SignerInfo.defaultValues(iu)),nu in e&&(this.unsignedAttrs=getParametersValue(e,nu,SignerInfo.defaultValues(nu))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eu:return 0;case tu:return new Any;case ru:return new AlgorithmIdentifier;case su:return new SignedAndUnsignedAttributes({type:0});case au:return new AlgorithmIdentifier;case iu:return new OctetString;case nu:return new SignedAndUnsignedAttributes({type:1});default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case eu:return SignerInfo.defaultValues(eu)===t;case tu:return t instanceof Any;case ru:return t instanceof AlgorithmIdentifier!=!1&&t.isEqual(SignerInfo.defaultValues(ru));case su:return SignedAndUnsignedAttributes.compareWithDefault("type",t.type)&&SignedAndUnsignedAttributes.compareWithDefault("attributes",t.attributes)&&SignedAndUnsignedAttributes.compareWithDefault("encodedValue",t.encodedValue);case au:return t instanceof AlgorithmIdentifier!=!1&&t.isEqual(SignerInfo.defaultValues(au));case iu:case nu:return SignedAndUnsignedAttributes.compareWithDefault("type",t.type)&&SignedAndUnsignedAttributes.compareWithDefault("attributes",t.attributes)&&SignedAndUnsignedAttributes.compareWithDefault("encodedValue",t.encodedValue);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:ou,value:[new Integer({name:t.version||lu}),new Choice({value:[IssuerAndSerialNumber.schema(t.sidSchema||{names:{blockName:cu}}),new Choice({value:[new Constructed({optional:!0,name:t.sid||cu,idBlock:{tagClass:3,tagNumber:0},value:[new OctetString]}),new Primitive({optional:!0,name:t.sid||cu,idBlock:{tagClass:3,tagNumber:0}})]})]}),AlgorithmIdentifier.schema(t.digestAlgorithm||{names:{blockName:uu}}),SignedAndUnsignedAttributes.schema(t.signedAttrs||{names:{blockName:hu,tagNumber:0}}),AlgorithmIdentifier.schema(t.signatureAlgorithm||{names:{blockName:mu}}),new OctetString({name:t.signature||fu}),SignedAndUnsignedAttributes.schema(t.unsignedAttrs||{names:{blockName:gu,tagNumber:1}})]})}fromSchema(e){clearProps(e,du);const t=compareSchema(e,e,SignerInfo.schema());AsnError.assertSchema(t,this.className),this.version=t.result[lu].valueBlock.valueDec;const r=t.result[cu];1===r.idBlock.tagClass?this.sid=new IssuerAndSerialNumber({schema:r}):this.sid=r,this.digestAlgorithm=new AlgorithmIdentifier({schema:t.result[uu]}),hu in t.result&&(this.signedAttrs=new SignedAndUnsignedAttributes({type:0,schema:t.result[hu]})),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result[mu]}),this.signature=t.result[fu],gu in t.result&&(this.unsignedAttrs=new SignedAndUnsignedAttributes({type:1,schema:t.result[gu]}))}toSchema(){if(SignerInfo.compareWithDefault(tu,this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');const e=[];return e.push(new Integer({value:this.version})),this.sid instanceof IssuerAndSerialNumber?e.push(this.sid.toSchema()):e.push(this.sid),e.push(this.digestAlgorithm.toSchema()),this.signedAttrs&&!1===SignerInfo.compareWithDefault(su,this.signedAttrs)&&e.push(this.signedAttrs.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.unsignedAttrs&&!1===SignerInfo.compareWithDefault(nu,this.unsignedAttrs)&&e.push(this.unsignedAttrs.toSchema()),new Sequence({value:e})}toJSON(){if(SignerInfo.compareWithDefault(tu,this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');const e={version:this.version,digestAlgorithm:this.digestAlgorithm.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.sid instanceof Any||(e.sid=this.sid.toJSON()),this.signedAttrs&&!1===SignerInfo.compareWithDefault(su,this.signedAttrs)&&(e.signedAttrs=this.signedAttrs.toJSON()),this.unsignedAttrs&&!1===SignerInfo.compareWithDefault(nu,this.unsignedAttrs)&&(e.unsignedAttrs=this.unsignedAttrs.toJSON()),e}}SignerInfo.CLASS_NAME="SignerInfo";const pu="version",Su="policy",yu="messageImprint",wu="serialNumber",vu="genTime",bu="ordering",Au="nonce",ku="accuracy",Cu="tsa",Vu="extensions",Bu="TSTInfo",Iu=`${Bu}.${pu}`,Nu=`${Bu}.${Su}`,Pu=`${Bu}.${yu}`,Eu=`${Bu}.${wu}`,Du=`${Bu}.${vu}`,Ou=`${Bu}.${ku}`,xu=`${Bu}.${bu}`,Ru=`${Bu}.${Au}`,Ku=`${Bu}.${Cu}`,Uu=`${Bu}.${Vu}`,Tu=[Iu,Nu,Pu,Eu,Du,Ou,xu,Ru,Ku,Uu];class TSTInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,pu,TSTInfo.defaultValues(pu)),this.policy=getParametersValue(e,Su,TSTInfo.defaultValues(Su)),this.messageImprint=getParametersValue(e,yu,TSTInfo.defaultValues(yu)),this.serialNumber=getParametersValue(e,wu,TSTInfo.defaultValues(wu)),this.genTime=getParametersValue(e,vu,TSTInfo.defaultValues(vu)),ku in e&&(this.accuracy=getParametersValue(e,ku,TSTInfo.defaultValues(ku))),bu in e&&(this.ordering=getParametersValue(e,bu,TSTInfo.defaultValues(bu))),Au in e&&(this.nonce=getParametersValue(e,Au,TSTInfo.defaultValues(Au))),Cu in e&&(this.tsa=getParametersValue(e,Cu,TSTInfo.defaultValues(Cu))),Vu in e&&(this.extensions=getParametersValue(e,Vu,TSTInfo.defaultValues(Vu))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case pu:return 0;case Su:return ke;case yu:return new MessageImprint;case wu:return new Integer;case vu:return new Date(0,0,0);case ku:return new Accuracy;case bu:return!1;case Au:return new Integer;case Cu:return new GeneralName;case Vu:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case pu:case Su:case vu:case bu:return t===TSTInfo.defaultValues(bu);case yu:return MessageImprint.compareWithDefault(Ac,t.hashAlgorithm)&&MessageImprint.compareWithDefault(kc,t.hashedMessage);case wu:case Au:return t.isEqual(TSTInfo.defaultValues(Au));case ku:return Accuracy.compareWithDefault(xe,t.seconds)&&Accuracy.compareWithDefault(Re,t.millis)&&Accuracy.compareWithDefault(Ke,t.micros);case Cu:return GeneralName.compareWithDefault(Ne,t.type)&&GeneralName.compareWithDefault(Pe,t.value);case Vu:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Bu,value:[new Integer({name:t.version||Iu}),new ObjectIdentifier({name:t.policy||Nu}),MessageImprint.schema(t.messageImprint||{names:{blockName:Pu}}),new Integer({name:t.serialNumber||Eu}),new GeneralizedTime({name:t.genTime||Du}),Accuracy.schema(t.accuracy||{names:{blockName:Ou}}),new Boolean({name:t.ordering||xu,optional:!0}),new Integer({name:t.nonce||Ru,optional:!0}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[GeneralName.schema(t.tsa||{names:{blockName:Ku}})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Repeated({name:t.extensions||Uu,value:Extension.schema(t.extension||{})})]})]})}fromSchema(e){clearProps(e,Tu);const t=compareSchema(e,e,TSTInfo.schema());AsnError.assertSchema(t,this.className),this.version=t.result[Iu].valueBlock.valueDec,this.policy=t.result[Nu].valueBlock.toString(),this.messageImprint=new MessageImprint({schema:t.result[Pu]}),this.serialNumber=t.result[Eu],this.genTime=t.result[Du].toDate(),Ou in t.result&&(this.accuracy=new Accuracy({schema:t.result[Ou]})),xu in t.result&&(this.ordering=t.result[xu].valueBlock.value),Ru in t.result&&(this.nonce=t.result[Ru]),Ku in t.result&&(this.tsa=new GeneralName({schema:t.result[Ku]})),Uu in t.result&&(this.extensions=Array.from(t.result[Uu],e=>new Extension({schema:e})))}toSchema(){const e=[];return e.push(new Integer({value:this.version})),e.push(new ObjectIdentifier({value:this.policy})),e.push(this.messageImprint.toSchema()),e.push(this.serialNumber),e.push(new GeneralizedTime({valueDate:this.genTime})),this.accuracy&&e.push(this.accuracy.toSchema()),void 0!==this.ordering&&e.push(new Boolean({value:this.ordering})),this.nonce&&e.push(this.nonce),this.tsa&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.tsa.toSchema()]})),this.extensions&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.extensions,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={version:this.version,policy:this.policy,messageImprint:this.messageImprint.toJSON(),serialNumber:this.serialNumber.toJSON(),genTime:this.genTime};return this.accuracy&&(e.accuracy=this.accuracy.toJSON()),void 0!==this.ordering&&(e.ordering=this.ordering),this.nonce&&(e.nonce=this.nonce.toJSON()),this.tsa&&(e.tsa=this.tsa.toJSON()),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}async verify(e,t=getCrypto(!0)){if(!e.data)throw new Error('"data" is a mandatory attribute for TST_INFO verification');const r=e.data;if(e.notBefore&&this.genTime<e.notBefore)throw new Error("Generation time for TSTInfo object is less than notBefore value");if(e.notAfter&&this.genTime>e.notAfter)throw new Error("Generation time for TSTInfo object is more than notAfter value");const s=t.getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId,!0,"MessageImprint.hashAlgorithm"),a=await t.digest(s.name,new Uint8Array(r));return BufferSourceConverter.isEqual(a,this.messageImprint.hashedMessage.valueBlock.valueHexView)}}TSTInfo.CLASS_NAME="TSTInfo";const Lu="version",Hu="digestAlgorithms",qu="encapContentInfo",ju="certificates",Mu="crls",Ju="signerInfos",_u="ocsps",Fu="SignedData",$u=`${Fu}.${Lu}`,Wu=`${Fu}.${Hu}`,Gu=`${Fu}.${qu}`,zu=`${Fu}.${ju}`,Qu=`${Fu}.${Mu}`,Zu=`${Fu}.${Ju}`,Yu=[$u,Wu,Gu,zu,Qu,Zu];class SignedDataVerifyError extends Error{constructor({message:e,code:t=0,date:r=new Date,signatureVerified:s=null,signerCertificate:a=null,signerCertificateVerified:i=null,timestampSerial:n=null,certificatePath:o=[]}){super(e),this.name="SignedDataVerifyError",this.date=r,this.code=t,this.timestampSerial=n,this.signatureVerified=s,this.signerCertificate=a,this.signerCertificateVerified=i,this.certificatePath=o}}class SignedData extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Lu,SignedData.defaultValues(Lu)),this.digestAlgorithms=getParametersValue(e,Hu,SignedData.defaultValues(Hu)),this.encapContentInfo=getParametersValue(e,qu,SignedData.defaultValues(qu)),ju in e&&(this.certificates=getParametersValue(e,ju,SignedData.defaultValues(ju))),Mu in e&&(this.crls=getParametersValue(e,Mu,SignedData.defaultValues(Mu))),_u in e&&(this.ocsps=getParametersValue(e,_u,SignedData.defaultValues(_u))),this.signerInfos=getParametersValue(e,Ju,SignedData.defaultValues(Ju)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Lu:return 0;case Hu:return[];case qu:return new EncapsulatedContentInfo;case ju:case Mu:case _u:case Ju:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Lu:return t===SignedData.defaultValues(Lu);case qu:return EncapsulatedContentInfo.compareWithDefault("eContentType",t.eContentType)&&EncapsulatedContentInfo.compareWithDefault("eContent",t.eContent);case Hu:case ju:case Mu:case _u:case Ju:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return void 0===t.optional&&(t.optional=!1),new Sequence({name:t.blockName||Fu,optional:t.optional,value:[new Integer({name:t.version||$u}),new Set({value:[new Repeated({name:t.digestAlgorithms||Wu,value:AlgorithmIdentifier.schema()})]}),EncapsulatedContentInfo.schema(t.encapContentInfo||{names:{blockName:Gu}}),new Constructed({name:t.certificates||zu,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:CertificateSet.schema().valueBlock.value}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:RevocationInfoChoices.schema(t.crls||{names:{crls:Qu}}).valueBlock.value}),new Set({value:[new Repeated({name:t.signerInfos||Zu,value:SignerInfo.schema()})]})]})}fromSchema(e){clearProps(e,Yu);const t=compareSchema(e,e,SignedData.schema());if(AsnError.assertSchema(t,this.className),this.version=t.result[$u].valueBlock.valueDec,Wu in t.result&&(this.digestAlgorithms=Array.from(t.result[Wu],e=>new AlgorithmIdentifier({schema:e}))),this.encapContentInfo=new EncapsulatedContentInfo({schema:t.result[Gu]}),zu in t.result){const e=new CertificateSet({schema:new Set({value:t.result[zu].valueBlock.value})});this.certificates=e.certificates.slice(0)}Qu in t.result&&(this.crls=Array.from(t.result[Qu],e=>1===e.idBlock.tagClass?new CertificateRevocationList({schema:e}):(e.idBlock.tagClass=1,e.idBlock.tagNumber=16,new OtherRevocationInfoFormat({schema:e})))),Zu in t.result&&(this.signerInfos=Array.from(t.result[Zu],e=>new SignerInfo({schema:e})))}toSchema(e=!1){const t=[];if(this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof OtherCertificateFormat)||this.crls&&this.crls.length&&this.crls.some(e=>e instanceof OtherRevocationInfoFormat)?this.version=5:this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof AttributeCertificateV2)?this.version=4:this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof AttributeCertificateV1)||this.signerInfos.some(e=>3===e.version)||this.encapContentInfo.eContentType!==SignedData.ID_DATA?this.version=3:this.version=1,t.push(new Integer({value:this.version})),t.push(new Set({value:Array.from(this.digestAlgorithms,e=>e.toSchema())})),t.push(this.encapContentInfo.toSchema()),this.certificates){const e=new CertificateSet({certificates:this.certificates}).toSchema();t.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:e.valueBlock.value}))}return this.crls&&t.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.crls,t=>{if(t instanceof OtherRevocationInfoFormat){const e=t.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}return t.toSchema(e)})})),t.push(new Set({value:Array.from(this.signerInfos,e=>e.toSchema())})),new Sequence({value:t})}toJSON(){const e={version:this.version,digestAlgorithms:Array.from(this.digestAlgorithms,e=>e.toJSON()),encapContentInfo:this.encapContentInfo.toJSON(),signerInfos:Array.from(this.signerInfos,e=>e.toJSON())};return this.certificates&&(e.certificates=Array.from(this.certificates,e=>e.toJSON())),this.crls&&(e.crls=Array.from(this.crls,e=>e.toJSON())),e}async verify({signer:e=-1,data:t=Ae,trustedCerts:r=[],checkDate:s=new Date,checkChain:a=!1,passedWhenNotRevValues:i=!1,extendedMode:n=!1,findOrigin:o=null,findIssuer:l=null}={},c=getCrypto(!0)){let u=null,h=null;try{let m=Ae,f=ke,g=[];const d=this.signerInfos[e];if(!d)throw new SignedDataVerifyError({date:s,code:1,message:"Unable to get signer by supplied index"});if(!this.certificates)throw new SignedDataVerifyError({date:s,code:2,message:"No certificates attached to this signed data"});if(d.sid instanceof IssuerAndSerialNumber){for(const e of this.certificates)if(e instanceof Certificate&&e.issuer.isEqual(d.sid.issuer)&&e.serialNumber.isEqual(d.sid.serialNumber)){u=e;break}}else{const e=d.sid,t=e.idBlock.isConstructed?e.valueBlock.value[0].valueBlock.valueHex:e.valueBlock.valueHex;for(const e of this.certificates){if(!(e instanceof Certificate))continue;if(isEqualBuffer(await c.digest({name:"sha-1"},e.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView),t)){u=e;break}}}if(!u)throw new SignedDataVerifyError({date:s,code:3,message:"Unable to find signer certificate"});if("1.2.840.113549.1.9.16.1.4"===this.encapContentInfo.eContentType){if(!this.encapContentInfo.eContent)throw new SignedDataVerifyError({date:s,code:15,message:"Error during verification: TSTInfo eContent is empty",signatureVerified:null,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0});let e;try{e=TSTInfo.fromBER(this.encapContentInfo.eContent.valueBlock.valueHexView)}catch(e){throw new SignedDataVerifyError({date:s,code:15,message:"Error during verification: TSTInfo wrong ASN.1 schema ",signatureVerified:null,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0})}if(s=e.genTime,h=e.serialNumber.valueBlock.valueHexView.slice(),0===t.byteLength)throw new SignedDataVerifyError({date:s,code:4,message:"Missed detached data input array"});if(!await e.verify({data:t},c))throw new SignedDataVerifyError({date:s,code:15,message:"Error during verification: TSTInfo verification is failed",signatureVerified:!1,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0})}if(a){const e=this.certificates.filter(e=>e instanceof Certificate&&!!checkCA(e,u)),t={checkDate:s,certs:e,trustedCerts:r};l&&(t.findIssuer=l),o&&(t.findOrigin=o);const a=new CertificateChainValidationEngine(t);if(a.certs.push(u),this.crls)for(const e of this.crls)"thisUpdate"in e?a.crls.push(e):e.otherRevInfoFormat===yt&&a.ocsps.push(new BasicOCSPResponse({schema:e.otherRevInfo}));this.ocsps&&a.ocsps.push(...this.ocsps);const n=await a.verify({passedWhenNotRevValues:i},c).catch(e=>{throw new SignedDataVerifyError({date:s,code:5,message:`Validation of signer's certificate failed with error: ${e instanceof Object?e.resultMessage:e}`,signerCertificate:u,signerCertificateVerified:!1})});if(n.certificatePath&&(g=n.certificatePath),!n.result)throw new SignedDataVerifyError({date:s,code:5,message:`Validation of signer's certificate failed: ${n.resultMessage}`,signerCertificate:u,signerCertificateVerified:!1})}const p=c.getAlgorithmByOID(d.digestAlgorithm.algorithmId);if(!("name"in p))throw new SignedDataVerifyError({date:s,code:7,message:`Unsupported signature algorithm: ${d.digestAlgorithm.algorithmId}`,signerCertificate:u,signerCertificateVerified:!0});f=p.name;const S=this.encapContentInfo.eContent;if(S)t=1===S.idBlock.tagClass&&4===S.idBlock.tagNumber?S.getValue():S.valueBlock.valueBeforeDecodeView;else if(0===t.byteLength)throw new SignedDataVerifyError({date:s,code:8,message:"Missed detached data input array",signerCertificate:u,signerCertificateVerified:!0});if(d.signedAttrs){let e=!1,t=!1;for(const r of d.signedAttrs.attributes)if("1.2.840.113549.1.9.3"===r.type&&(e=!0),"1.2.840.113549.1.9.4"===r.type&&(t=!0,m=r.values[0].valueBlock.valueHex),e&&t)break;if(!1===e)throw new SignedDataVerifyError({date:s,code:9,message:'Attribute "content-type" is a mandatory attribute for "signed attributes"',signerCertificate:u,signerCertificateVerified:!0});if(!1===t)throw new SignedDataVerifyError({date:s,code:10,message:'Attribute "message-digest" is a mandatory attribute for "signed attributes"',signatureVerified:null,signerCertificate:u,signerCertificateVerified:!0})}if(d.signedAttrs){if(!isEqualBuffer(await c.digest(f,new Uint8Array(t)),m))throw new SignedDataVerifyError({date:s,code:15,message:"Error during verification: Message digest doesn't match",signatureVerified:null,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0});t=d.signedAttrs.encodedValue}const y="1.2.840.113549.1.1.1"===d.signatureAlgorithm.algorithmId?await c.verifyWithPublicKey(t,d.signature,u.subjectPublicKeyInfo,d.signatureAlgorithm,f):await c.verifyWithPublicKey(t,d.signature,u.subjectPublicKeyInfo,d.signatureAlgorithm);return n?{date:s,code:14,message:ke,signatureVerified:y,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0,certificatePath:g}:y}catch(e){if(e instanceof SignedDataVerifyError)throw e;throw new SignedDataVerifyError({date:s,code:15,message:`Error during verification: ${e instanceof Error?e.message:e}`,signatureVerified:null,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0})}}async sign(e,t,r="SHA-1",s=Ae,a=getCrypto(!0)){var i;if(!e)throw new Error("Need to provide a private key for signing");const n=this.signerInfos[t];if(!n)throw new RangeError("SignerInfo index is out of range");!(null===(i=n.signedAttrs)||void 0===i?void 0:i.attributes.length)&&"hash"in e.algorithm&&"hash"in e.algorithm&&e.algorithm.hash&&(r=e.algorithm.hash.name);const o=a.getOIDByAlgorithm({name:r},!0,"hashAlgorithm");0===this.digestAlgorithms.filter(e=>e.algorithmId===o).length&&this.digestAlgorithms.push(new AlgorithmIdentifier({algorithmId:o,algorithmParams:new Null})),n.digestAlgorithm=new AlgorithmIdentifier({algorithmId:o,algorithmParams:new Null});const l=await a.getSignatureParameters(e,r),c=l.parameters;if(n.signatureAlgorithm=l.signatureAlgorithm,n.signedAttrs)if(0!==n.signedAttrs.encodedValue.byteLength)s=n.signedAttrs.encodedValue;else{s=n.signedAttrs.toSchema().toBER();BufferSourceConverter.toUint8Array(s)[0]=49}else{const e=this.encapContentInfo.eContent;if(e)s=1===e.idBlock.tagClass&&4===e.idBlock.tagNumber?e.getValue():e.valueBlock.valueBeforeDecodeView;else if(0===s.byteLength)throw new Error("Missed detached data input array")}const u=await a.signWithPrivateKey(s,e,c);n.signature=new OctetString({valueHex:u})}}SignedData.CLASS_NAME="SignedData",SignedData.ID_DATA=ht;const Xu="version",eh="authSafe",th="macData",rh="parsedValue",sh=[Xu,eh,th];class PFX extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Xu,PFX.defaultValues(Xu)),this.authSafe=getParametersValue(e,eh,PFX.defaultValues(eh)),th in e&&(this.macData=getParametersValue(e,th,PFX.defaultValues(th))),rh in e&&(this.parsedValue=getParametersValue(e,rh,PFX.defaultValues(rh))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Xu:return 3;case eh:return new ContentInfo;case th:return new MacData;case rh:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Xu:return t===PFX.defaultValues(e);case eh:return ContentInfo.compareWithDefault("contentType",t.contentType)&&ContentInfo.compareWithDefault("content",t.content);case th:return MacData.compareWithDefault("mac",t.mac)&&MacData.compareWithDefault("macSalt",t.macSalt)&&MacData.compareWithDefault("iterations",t.iterations);case rh:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.version||Xu}),ContentInfo.schema(t.authSafe||{names:{blockName:eh}}),MacData.schema(t.macData||{names:{blockName:th,optional:!0}})]})}fromSchema(e){clearProps(e,sh);const t=compareSchema(e,e,PFX.schema({names:{version:Xu,authSafe:{names:{blockName:eh}},macData:{names:{blockName:th}}}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.authSafe=new ContentInfo({schema:t.result.authSafe}),th in t.result&&(this.macData=new MacData({schema:t.result.macData}))}toSchema(){const e=[new Integer({value:this.version}),this.authSafe.toSchema()];return this.macData&&e.push(this.macData.toSchema()),new Sequence({value:e})}toJSON(){const e={version:this.version,authSafe:this.authSafe.toJSON()};return this.macData&&(e.macData=this.macData.toJSON()),e}async makeInternalValues(e={},t=getCrypto(!0)){if(ArgumentError.assert(e,"parameters","object"),!this.parsedValue)throw new Error('Please call "parseValues" function first in order to make "parsedValue" data');switch(ParameterError.assertEmpty(this.parsedValue.integrityMode,"integrityMode","parsedValue"),ParameterError.assertEmpty(this.parsedValue.authenticatedSafe,"authenticatedSafe","parsedValue"),this.parsedValue.integrityMode){case 0:{if(!("iterations"in e))throw new ParameterError("iterations");ParameterError.assertEmpty(e.pbkdf2HashAlgorithm,"pbkdf2HashAlgorithm"),ParameterError.assertEmpty(e.hmacHashAlgorithm,"hmacHashAlgorithm"),ParameterError.assertEmpty(e.password,"password");const r=new ArrayBuffer(64),s=new Uint8Array(r);t.getRandomValues(s);const a=this.parsedValue.authenticatedSafe.toSchema().toBER(!1);this.authSafe=new ContentInfo({contentType:ContentInfo.DATA,content:new OctetString({valueHex:a})});const i=await t.stampDataWithPassword({password:e.password,hashAlgorithm:e.hmacHashAlgorithm,salt:r,iterationCount:e.iterations,contentToStamp:a});this.macData=new MacData({mac:new DigestInfo({digestAlgorithm:new AlgorithmIdentifier({algorithmId:t.getOIDByAlgorithm({name:e.hmacHashAlgorithm},!0,"hmacHashAlgorithm")}),digest:new OctetString({valueHex:i})}),macSalt:new OctetString({valueHex:r}),iterations:e.iterations})}break;case 1:{if(!("signingCertificate"in e))throw new ParameterError("signingCertificate");ParameterError.assertEmpty(e.privateKey,"privateKey"),ParameterError.assertEmpty(e.hashAlgorithm,"hashAlgorithm");const r=this.parsedValue.authenticatedSafe.toSchema().toBER(!1),s=new SignedData({version:1,encapContentInfo:new EncapsulatedContentInfo({eContentType:"1.2.840.113549.1.7.1",eContent:new OctetString({valueHex:r})}),certificates:[e.signingCertificate]}),a=await t.digest({name:e.hashAlgorithm},new Uint8Array(r)),i=[];i.push(new Attribute({type:"1.2.840.113549.1.9.3",values:[new ObjectIdentifier({value:"1.2.840.113549.1.7.1"})]})),i.push(new Attribute({type:"1.2.840.113549.1.9.5",values:[new UTCTime({valueDate:new Date})]})),i.push(new Attribute({type:"1.2.840.113549.1.9.4",values:[new OctetString({valueHex:a})]})),s.signerInfos.push(new SignerInfo({version:1,sid:new IssuerAndSerialNumber({issuer:e.signingCertificate.issuer,serialNumber:e.signingCertificate.serialNumber}),signedAttrs:new SignedAndUnsignedAttributes({type:0,attributes:i})})),await s.sign(e.privateKey,0,e.hashAlgorithm,void 0,t),this.authSafe=new ContentInfo({contentType:"1.2.840.113549.1.7.2",content:s.toSchema(!0)})}break;default:throw new Error(`Parameter "integrityMode" has unknown value: ${this.parsedValue.integrityMode}`)}}async parseInternalValues(e,t=getCrypto(!0)){switch(ArgumentError.assert(e,"parameters","object"),void 0===e.checkIntegrity&&(e.checkIntegrity=!0),this.parsedValue={},this.authSafe.contentType){case ContentInfo.DATA:{ParameterError.assertEmpty(e.password,"password"),this.parsedValue.integrityMode=0,ArgumentError.assert(this.authSafe.content,"authSafe.content",OctetString);const r=this.authSafe.content.getValue();if(this.parsedValue.authenticatedSafe=AuthenticatedSafe.fromBER(r),e.checkIntegrity){if(!this.macData)throw new Error('Absent "macData" value, can not check PKCS#12 data integrity');const s=t.getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId,!0,"digestAlgorithm");if(!await t.verifyDataStampedWithPassword({password:e.password,hashAlgorithm:s.name,salt:BufferSourceConverter.toArrayBuffer(this.macData.macSalt.valueBlock.valueHexView),iterationCount:this.macData.iterations||1,contentToVerify:r,signatureToVerify:BufferSourceConverter.toArrayBuffer(this.macData.mac.digest.valueBlock.valueHexView)}))throw new Error("Integrity for the PKCS#12 data is broken!")}}break;case ContentInfo.SIGNED_DATA:{this.parsedValue.integrityMode=1;const e=new SignedData({schema:this.authSafe.content}),r=e.encapContentInfo.eContent;ParameterError.assert(r,"eContent","cmsSigned.encapContentInfo"),ArgumentError.assert(r,"eContent",OctetString);const s=r.getValue();this.parsedValue.authenticatedSafe=AuthenticatedSafe.fromBER(s);if(!await e.verify({signer:0,checkChain:!1},t))throw new Error("Integrity for the PKCS#12 data is broken!")}break;default:throw new Error(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`)}}}PFX.CLASS_NAME="PFX";const ah="status",ih="statusStrings",nh="failInfo",oh=[ah,ih,nh];var lh;!function(e){e[e.granted=0]="granted",e[e.grantedWithMods=1]="grantedWithMods",e[e.rejection=2]="rejection",e[e.waiting=3]="waiting",e[e.revocationWarning=4]="revocationWarning",e[e.revocationNotification=5]="revocationNotification"}(lh||(lh={}));class PKIStatusInfo extends PkiObject{constructor(e={}){super(),this.status=getParametersValue(e,ah,PKIStatusInfo.defaultValues(ah)),ih in e&&(this.statusStrings=getParametersValue(e,ih,PKIStatusInfo.defaultValues(ih))),nh in e&&(this.failInfo=getParametersValue(e,nh,PKIStatusInfo.defaultValues(nh))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ah:return 2;case ih:return[];case nh:return new BitString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ah:return t===PKIStatusInfo.defaultValues(e);case ih:return 0===t.length;case nh:return t.isEqual(PKIStatusInfo.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ke,value:[new Integer({name:t.status||ke}),new Sequence({optional:!0,value:[new Repeated({name:t.statusStrings||ke,value:new Utf8String})]}),new BitString({name:t.failInfo||ke,optional:!0})]})}fromSchema(e){clearProps(e,oh);const t=compareSchema(e,e,PKIStatusInfo.schema({names:{status:ah,statusStrings:ih,failInfo:nh}}));AsnError.assertSchema(t,this.className);const r=t.result.status;if(!0===r.valueBlock.isHexOnly||r.valueBlock.valueDec<0||r.valueBlock.valueDec>5)throw new Error('PKIStatusInfo "status" has invalid value');this.status=r.valueBlock.valueDec,ih in t.result&&(this.statusStrings=t.result.statusStrings),nh in t.result&&(this.failInfo=t.result.failInfo)}toSchema(){const e=[];return e.push(new Integer({value:this.status})),this.statusStrings&&e.push(new Sequence({optional:!0,value:this.statusStrings})),this.failInfo&&e.push(this.failInfo),new Sequence({value:e})}toJSON(){const e={status:this.status};return this.statusStrings&&(e.statusStrings=Array.from(this.statusStrings,e=>e.toJSON())),this.failInfo&&(e.failInfo=this.failInfo.toJSON()),e}}PKIStatusInfo.CLASS_NAME="PKIStatusInfo";const ch="version",uh="messageImprint",hh="reqPolicy",mh="nonce",fh="certReq",gh="extensions",dh="TimeStampReq",ph=`${dh}.${ch}`,Sh=`${dh}.${uh}`,yh=`${dh}.${hh}`,wh=`${dh}.${mh}`,vh=`${dh}.${fh}`,bh=`${dh}.${gh}`,Ah=[ph,Sh,yh,wh,vh,bh];class TimeStampReq extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,ch,TimeStampReq.defaultValues(ch)),this.messageImprint=getParametersValue(e,uh,TimeStampReq.defaultValues(uh)),hh in e&&(this.reqPolicy=getParametersValue(e,hh,TimeStampReq.defaultValues(hh))),mh in e&&(this.nonce=getParametersValue(e,mh,TimeStampReq.defaultValues(mh))),fh in e&&(this.certReq=getParametersValue(e,fh,TimeStampReq.defaultValues(fh))),gh in e&&(this.extensions=getParametersValue(e,gh,TimeStampReq.defaultValues(gh))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ch:return 0;case uh:return new MessageImprint;case hh:return ke;case mh:return new Integer;case fh:return!1;case gh:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ch:case hh:case fh:return t===TimeStampReq.defaultValues(e);case uh:return MessageImprint.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&MessageImprint.compareWithDefault("hashedMessage",t.hashedMessage);case mh:return t.isEqual(TimeStampReq.defaultValues(e));case gh:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||dh,value:[new Integer({name:t.version||ph}),MessageImprint.schema(t.messageImprint||{names:{blockName:Sh}}),new ObjectIdentifier({name:t.reqPolicy||yh,optional:!0}),new Integer({name:t.nonce||wh,optional:!0}),new Boolean({name:t.certReq||vh,optional:!0}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({name:t.extensions||bh,value:Extension.schema()})]})]})}fromSchema(e){clearProps(e,Ah);const t=compareSchema(e,e,TimeStampReq.schema());AsnError.assertSchema(t,this.className),this.version=t.result[ph].valueBlock.valueDec,this.messageImprint=new MessageImprint({schema:t.result[Sh]}),yh in t.result&&(this.reqPolicy=t.result[yh].valueBlock.toString()),wh in t.result&&(this.nonce=t.result[wh]),vh in t.result&&(this.certReq=t.result[vh].valueBlock.value),bh in t.result&&(this.extensions=Array.from(t.result[bh],e=>new Extension({schema:e})))}toSchema(){const e=[];return e.push(new Integer({value:this.version})),e.push(this.messageImprint.toSchema()),this.reqPolicy&&e.push(new ObjectIdentifier({value:this.reqPolicy})),this.nonce&&e.push(this.nonce),fh in this&&!1===TimeStampReq.compareWithDefault(fh,this.certReq)&&e.push(new Boolean({value:this.certReq})),this.extensions&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.extensions,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={version:this.version,messageImprint:this.messageImprint.toJSON()};return void 0!==this.reqPolicy&&(e.reqPolicy=this.reqPolicy),void 0!==this.nonce&&(e.nonce=this.nonce.toJSON()),void 0!==this.certReq&&!1===TimeStampReq.compareWithDefault(fh,this.certReq)&&(e.certReq=this.certReq),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}}TimeStampReq.CLASS_NAME="TimeStampReq";const kh="status",Ch="timeStampToken",Vh="TimeStampResp",Bh=`${Vh}.${kh}`,Ih=`${Vh}.${Ch}`,Nh=[Bh,Ih];class TimeStampResp extends PkiObject{constructor(e={}){super(),this.status=getParametersValue(e,kh,TimeStampResp.defaultValues(kh)),Ch in e&&(this.timeStampToken=getParametersValue(e,Ch,TimeStampResp.defaultValues(Ch))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case kh:return new PKIStatusInfo;case Ch:return new ContentInfo;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case kh:return PKIStatusInfo.compareWithDefault(kh,t.status)&&"statusStrings"in t==!1&&"failInfo"in t==!1;case Ch:return t.contentType===ke&&t.content instanceof Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Vh,value:[PKIStatusInfo.schema(t.status||{names:{blockName:Bh}}),ContentInfo.schema(t.timeStampToken||{names:{blockName:Ih,optional:!0}})]})}fromSchema(e){clearProps(e,Nh);const t=compareSchema(e,e,TimeStampResp.schema());AsnError.assertSchema(t,this.className),this.status=new PKIStatusInfo({schema:t.result[Bh]}),Ih in t.result&&(this.timeStampToken=new ContentInfo({schema:t.result[Ih]}))}toSchema(){const e=[];return e.push(this.status.toSchema()),this.timeStampToken&&e.push(this.timeStampToken.toSchema()),new Sequence({value:e})}toJSON(){const e={status:this.status.toJSON()};return this.timeStampToken&&(e.timeStampToken=this.timeStampToken.toJSON()),e}async sign(e,t,r=getCrypto(!0)){this.assertContentType();return new SignedData({schema:this.timeStampToken.content}).sign(e,0,t,void 0,r)}async verify(e={signer:0,trustedCerts:[],data:Ae},t=getCrypto(!0)){this.assertContentType();return new SignedData({schema:this.timeStampToken.content}).verify(e,t)}assertContentType(){if(!this.timeStampToken)throw new Error("timeStampToken is absent in TSP response");if(this.timeStampToken.contentType!==mt)throw new Error(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`)}}TimeStampResp.CLASS_NAME="TimeStampResp",function(){if("undefined"!=typeof self){if("crypto"in self){let e="webcrypto";"webkitSubtle"in self.crypto&&(e="safari"),setEngine(e,new CryptoEngine({name:e,crypto:crypto}))}}else if("undefined"!=typeof crypto&&"webcrypto"in crypto){const e="NodeJS ^15",t=crypto.webcrypto;setEngine(e,new CryptoEngine({name:e,crypto:t}))}}();const verifySignatureWithPem=async(e,t,r)=>{try{const s=e.replace(/-----BEGIN [^-]+-----/,"").replace(/-----END [^-]+-----/,"").replace(/\s+/g,""),a=fromBER(base64ToBytes(s).buffer);let i=new Certificate({schema:a.result}).subjectPublicKeyInfo;if(!i||!i.algorithm||!i.algorithm.algorithmId)throw console.error("Parsed publicKeyInfo:",i),new Error("Could not extract algorithm information from public key");const n=function(e){const t=e.algorithm.algorithmId,r=e.algorithm.algorithmParams;let s;if(t&&"object"==typeof t&&t.valueBlock&&"function"==typeof t.valueBlock.toString)s=t.valueBlock.toString();else{if("string"!=typeof t)throw new Error("Unsupported algorithmOid format");s=t}switch(s){case"1.2.840.10045.2.1":let e;switch(e=r&&"object"==typeof r&&r.valueBlock&&"function"==typeof r.valueBlock.toString?r.valueBlock.toString():"string"==typeof r?r:void 0,e){case"1.2.840.10045.3.1.7":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};case"1.3.132.0.34":return{name:"ECDSA",namedCurve:"P-384",hash:{name:"SHA-384"}};case"1.3.132.0.35":return{name:"ECDSA",namedCurve:"P-521",hash:{name:"SHA-512"}};case void 0:return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error(`Unsupported EC curve: ${e}`)}case"1.2.840.113549.1.1.1":return{name:"RSASSA-PKCS1-v1_5"};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};default:throw new Error(`Unsupported algorithm OID: ${s}`)}}(i),o=i.toSchema().toBER(),l=await crypto.subtle.importKey("spki",o,n,!1,["verify"]);let c;c="ECDSA"===n.name?function(e){try{const t=fromBER(base64ToBytes(e).buffer);if(2!==t.result.valueBlock.value.length)throw new Error("Invalid DER signature structure");const r=t.result.valueBlock.value[0],s=t.result.valueBlock.value[1],a=new Uint8Array(r.valueBlock.valueHex),i=new Uint8Array(s.valueBlock.valueHex),n=padOrTrim(a,32),o=padOrTrim(i,32),l=new Uint8Array(64);return l.set(n,0),l.set(o,32),l.buffer}catch(e){throw console.error("Error converting DER signature to raw:",e),e}}(t):base64ToBytes(t).buffer;const u=(new TextEncoder).encode(r).buffer;return await crypto.subtle.verify(n,l,c,u)}catch(e){throw console.error("Error converting PEM to SPKI key:",e),e}};function base64ToBytes(e){if("function"==typeof Buffer)return new Uint8Array(Buffer.from(e,"base64"));{const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r}}function padOrTrim(e,t){if(e.length===t)return e;if(e.length>t)return e.slice(e.length-t);const r=new Uint8Array(t);return r.set(e,t-e.length),r}let Ph,Eh,Dh="",Oh="";const xh=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,Rh={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"};function quote(e){return xh.lastIndex=0,xh.test(e)?'"'+e.replace(xh,e=>Rh[e]||"\\u"+("0000"+e.charCodeAt(0).toString(16)).slice(-4))+'"':'"'+e+'"'}function str(e,t){let r=t[e];switch(r&&"object"==typeof r&&"function"==typeof r.toJSON&&(r=r.toJSON(e)),"function"==typeof Ph&&(r=Ph.call(t,e,r)),typeof r){case"string":return quote(r);case"number":return isFinite(r)?String(r):"null";case"boolean":case"undefined":case"object":if(null===r)return"null";const e=Dh;Dh+=Oh;const t=[];if(Array.isArray(r))for(let e=0;e<r.length;e++)t[e]=str(e,r)||"null";else{const e=Object.keys(r).sort(Eh);for(const s of e)if(Object.prototype.hasOwnProperty.call(r,s)){const e=str(s,r);e&&t.push(quote(s)+(Dh?": ":":")+e)}}let s;return s=Array.isArray(r)?0===t.length?"[]":Dh?"[\n"+Dh+t.join(",\n"+Dh)+"\n"+e+"]":"["+t.join(",")+"]":0===t.length?"{}":Dh?"{\n"+Dh+t.join(",\n"+Dh)+"\n"+e+"}":"{"+t.join(",")+"}",Dh=e,s;default:return String(r)}}function stringify(e,t,r,s){return Dh="",Oh="",Ph=t,Eh=void 0,str("",{"":e})}class TrustedIssuerRegistry{constructor(r={}){this._cacheEnabled=r.cacheEnabled??!0,this._cacheTTL=r.cacheTTL??864e5,this._urlBase=r.useTestIssuers?t:e,this._cache={}}async getIssuerFromX509AKI(e){if(this._cacheEnabled&&e in this._cache&&this._cache[e].expiresAt>Date.now())return this._cache[e].issuer;const t=await fetch(`${this._urlBase}/issuers/x509_aki/${e}.json`);if(t.ok){const r=await t.json();return await this._verifyIssuer(r)?(this._cacheEnabled&&(this._cache[e]={issuer:r,expiresAt:Date.now()+this._cacheTTL}),r):null}return this._cacheEnabled&&(this._cache[e]={issuer:null,expiresAt:Date.now()+this._cacheTTL}),null}async _verifyIssuer(e){const t={...e},r=t.signature;delete t.signature;const s=stringify(t);let a=!1;try{a=await verifySignatureWithPem("-----BEGIN CERTIFICATE-----\nMIIBnDCCAUGgAwIBAgIURT5mnI9WbENrqzrB0RYtXGuc0n8wCgYIKoZIzj0EAwIw\nIzEhMB8GA1UEAwwYVW5pdmVyc2FsIFZlcmlmeSBSb290IENBMB4XDTI1MDcwNDEz\nNTY0OVoXDTM1MDcwMjEzNTY0OVowIzEhMB8GA1UEAwwYVW5pdmVyc2FsIFZlcmlm\neSBSb290IENBMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsOasxJHsq+tmAy5L\nYz0KeT2UyGo1PqS0mr7Z5zn7Ai7vCEzea57QiQMQVYpiQGvkr3bS2T2l6xK7Oduj\nMhUWs6NTMFEwHQYDVR0OBBYEFPJpi7yR7+yf44xcCfHDypGmlDosMB8GA1UdIwQY\nMBaAFPJpi7yR7+yf44xcCfHDypGmlDosMA8GA1UdEwEB/wQFMAMBAf8wCgYIKoZI\nzj0EAwIDSQAwRgIhAJvh/bVs8EXtzYWZm4ijR9J0+BwtqzCXJE4dDML4JafpAiEA\n/7cvgi4SoK+Xn6WRfsgg9BNymAfJbejzDrQbLqHh4v8=\n-----END CERTIFICATE-----",r,s)}catch(e){console.error("Issuer signature verification failed",e)}return a}}export{TrustedIssuerRegistry as default};
