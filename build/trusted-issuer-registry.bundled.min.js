const e="0.0",t=`https://cdn.jsdelivr.net/npm/trusted-issuer-registry@${e}`,r=`${t}/test`;class BufferSourceConverter{static isArrayBuffer(e){return"[object ArrayBuffer]"===Object.prototype.toString.call(e)}static toArrayBuffer(e){return this.isArrayBuffer(e)?e:e.byteLength===e.buffer.byteLength||0===e.byteOffset&&e.byteLength===e.buffer.byteLength?e.buffer:this.toUint8Array(e.buffer).slice(e.byteOffset,e.byteOffset+e.byteLength).buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if(e.constructor===t)return e;if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}static isEqual(e,t){const r=BufferSourceConverter.toUint8Array(e),s=BufferSourceConverter.toUint8Array(t);if(r.length!==s.byteLength)return!1;for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}static concat(...e){let t;t=!Array.isArray(e[0])||e[1]instanceof Function?Array.isArray(e[0])&&e[1]instanceof Function?e[0]:e[e.length-1]instanceof Function?e.slice(0,e.length-1):e:e[0];let r=0;for(const e of t)r+=e.byteLength;const s=new Uint8Array(r);let a=0;for(const e of t){const t=this.toUint8Array(e);s.set(t,a),a+=t.length}return e[e.length-1]instanceof Function?this.toView(s,e[e.length-1]):s.buffer}}const s="string",a=/^[0-9a-f\s]+$/i,i=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,n=/^[a-zA-Z0-9-_]+$/;class Utf8Converter{static fromString(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r.buffer}static toString(e){const t=BufferSourceConverter.toUint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return decodeURIComponent(escape(r))}}class Utf16Converter{static toString(e,t=!1){const r=BufferSourceConverter.toArrayBuffer(e),s=new DataView(r);let a="";for(let e=0;e<r.byteLength;e+=2){const r=s.getUint16(e,t);a+=String.fromCharCode(r)}return a}static fromString(e,t=!1){const r=new ArrayBuffer(2*e.length),s=new DataView(r);for(let r=0;r<e.length;r++)s.setUint16(2*r,e.charCodeAt(r),t);return r}}class Convert{static isHex(e){return typeof e===s&&a.test(e)}static isBase64(e){return typeof e===s&&i.test(e)}static isBase64Url(e){return typeof e===s&&n.test(e)}static ToString(e,t="utf8"){const r=BufferSourceConverter.toUint8Array(e);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);case"utf16le":return Utf16Converter.toString(r,!0);case"utf16":case"utf16be":return Utf16Converter.toString(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);case"utf16le":return Utf16Converter.fromString(e,!0);case"utf16":case"utf16be":return Utf16Converter.fromString(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const t=BufferSourceConverter.toUint8Array(e);if("undefined"!=typeof btoa){const e=this.ToString(t,"binary");return btoa(e)}return Buffer.from(t).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!Convert.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!Convert.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e,t=Convert.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.FromBinary(e);case"utf8":return Utf8Converter.fromString(e);case"utf16":case"utf16be":return Utf16Converter.fromString(e);case"utf16le":case"usc2":return Utf16Converter.fromString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToUtf8String(e,t=Convert.DEFAULT_UTF8_ENCODING){switch(t){case"ascii":return this.ToBinary(e);case"utf8":return Utf8Converter.toString(e);case"utf16":case"utf16be":return Utf16Converter.toString(e);case"utf16le":case"usc2":return Utf16Converter.toString(e,!0);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);return r.buffer}static ToBinary(e){const t=BufferSourceConverter.toUint8Array(e);let r="";for(let e=0;e<t.length;e++)r+=String.fromCharCode(t[e]);return r}static ToHex(e){const t=BufferSourceConverter.toUint8Array(e);let r="";const s=t.length;for(let e=0;e<s;e++){const s=t[e];s<16&&(r+="0"),r+=s.toString(16)}return r}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!Convert.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t=`0${t}`);const r=new Uint8Array(t.length/2);for(let e=0;e<t.length;e+=2){const s=t.slice(e,e+2);r[e/2]=parseInt(s,16)}return r.buffer}static ToUtf16String(e,t=!1){return Utf16Converter.toString(e,t)}static FromUtf16String(e,t=!1){return Utf16Converter.fromString(e,t)}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}static formatString(e){return(null==e?void 0:e.replace(/[\n\r\t ]/g,""))||""}}
/*!
 Copyright (c) Peculiar Ventures, LLC
*/
function getParametersValue(e,t,r){var s;return e instanceof Object==!1?r:null!==(s=e[t])&&void 0!==s?s:r}function bufferToHexCodes(e,t=0,r=e.byteLength-t,s=!1){let a="";for(const i of new Uint8Array(e,t,r)){const e=i.toString(16).toUpperCase();1===e.length&&(a+="0"),a+=e,s&&(a+=" ")}return a.trim()}function utilFromBase(e,t){let r=0;if(1===e.length)return e[0];for(let s=e.length-1;s>=0;s--)r+=e[e.length-1-s]*Math.pow(2,t*s);return r}function utilToBase(e,t,r=-1){const s=r;let a=e,i=0,n=Math.pow(2,t);for(let r=1;r<8;r++){if(e<n){let e;if(s<0)e=new ArrayBuffer(r),i=r;else{if(s<r)return new ArrayBuffer(0);e=new ArrayBuffer(s),i=s}const n=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);n[i-e-1]=Math.floor(a/r),a-=n[i-e-1]*r}return e}n*=Math.pow(2,t)}return new ArrayBuffer(0)}function utilConcatBuf(...e){let t=0,r=0;for(const r of e)t+=r.byteLength;const s=new ArrayBuffer(t),a=new Uint8Array(s);for(const t of e)a.set(new Uint8Array(t),r),r+=t.byteLength;return s}function utilConcatView(...e){let t=0,r=0;for(const r of e)t+=r.length;const s=new ArrayBuffer(t),a=new Uint8Array(s);for(const t of e)a.set(t,r),r+=t.length;return a}function utilDecodeTC(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&!(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const s=utilFromBase(r,8),a=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(a);for(let t=0;t<this.valueHex.byteLength;t++)i[t]=e[t];i[0]&=127;return utilFromBase(i,8)-s}function isEqualBuffer(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),s=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}function padNumber(e,t){const r=e.toString(10);if(t<r.length)return"";const s=t-r.length,a=new Array(s);for(let e=0;e<s;e++)a[e]="0";return a.join("").concat(r)}Convert.DEFAULT_UTF8_ENCODING="utf8";const o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",l="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function toBase64(e,t=!1,r=!1,s=!1){let a=0,i=0,n=0,c="";const u=t?l:o;if(s){let t=0;for(let r=0;r<e.length;r++)if(0!==e.charCodeAt(r)){t=r;break}e=e.slice(t)}for(;a<e.length;){const t=e.charCodeAt(a++);a>=e.length&&(i=1);const s=e.charCodeAt(a++);a>=e.length&&(n=1);const o=e.charCodeAt(a++),l=t>>2,h=(3&t)<<4|s>>4;let m=(15&s)<<2|o>>6,f=63&o;1===i?m=f=64:1===n&&(f=64),c+=r?64===m?`${u.charAt(l)}${u.charAt(h)}`:64===f?`${u.charAt(l)}${u.charAt(h)}${u.charAt(m)}`:`${u.charAt(l)}${u.charAt(h)}${u.charAt(m)}${u.charAt(f)}`:`${u.charAt(l)}${u.charAt(h)}${u.charAt(m)}${u.charAt(f)}`}return c}function fromBase64(e,t=!1,r=!1){const s=t?l:o;function indexOf(e){for(let t=0;t<64;t++)if(s.charAt(t)===e)return t;return 64}function test(e){return 64===e?0:e}let a=0,i="";for(;a<e.length;){const t=indexOf(e.charAt(a++)),r=a>=e.length?0:indexOf(e.charAt(a++)),s=a>=e.length?0:indexOf(e.charAt(a++)),n=a>=e.length?0:indexOf(e.charAt(a++)),o=test(t)<<2|test(r)>>4,l=(15&test(r))<<4|test(s)>>2,c=(3&test(s))<<6|test(n);i+=String.fromCharCode(o),64!==s&&(i+=String.fromCharCode(l)),64!==n&&(i+=String.fromCharCode(c))}if(r){let e=-1;for(let t=i.length-1;t>=0;t--)if(0!==i.charCodeAt(t)){e=t;break}i=-1!==e?i.slice(0,e+1):""}return i}function arrayBufferToString(e){let t="";const r=new Uint8Array(e);for(const e of r)t+=String.fromCharCode(e);return t}function stringToArrayBuffer(e){const t=e.length,r=new ArrayBuffer(t),s=new Uint8Array(r);for(let r=0;r<t;r++)s[r]=e.charCodeAt(r);return r}const c=Math.log(2);function nearestPowerOf2(e){const t=Math.log(e)/c,r=Math.floor(t),s=Math.round(t);return r===s?r:s}function clearProps(e,t){for(const r of t)delete e[r]}
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */function assertBigInt(){if("undefined"==typeof BigInt)throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.")}function concat(e){let t=0,r=0;for(let r=0;r<e.length;r++){t+=e[r].byteLength}const s=new Uint8Array(t);for(let t=0;t<e.length;t++){const a=e[t];s.set(new Uint8Array(a),r),r+=a.byteLength}return s.buffer}function checkBufferParams(e,t,r,s){return t instanceof Uint8Array?t.byteLength?r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):s<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-s<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1):(e.error="Wrong parameter: inputBuffer has zero length",!1):(e.error="Wrong parameter: inputBuffer must be 'Uint8Array'",!1)}class ViewWriter{constructor(){this.items=[]}write(e){this.items.push(e)}final(){return concat(this.items)}}const u=[new Uint8Array([1])],h="0123456789",m="name",f="valueHexView",g="",d=new ArrayBuffer(0),p=new Uint8Array(0),S="EndOfContent",y="OCTET STRING",w="BIT STRING";function HexBlock(e){var t;return(t=class extends e{get valueHex(){return this.valueHexView.slice().buffer}set valueHex(e){this.valueHexView=new Uint8Array(e)}constructor(...e){var t;super(...e);const r=e[0]||{};this.isHexOnly=null!==(t=r.isHexOnly)&&void 0!==t&&t,this.valueHexView=r.valueHex?BufferSourceConverter.toUint8Array(r.valueHex):p}fromBER(e,t,r){const s=e instanceof ArrayBuffer?new Uint8Array(e):e;if(!checkBufferParams(this,s,t,r))return-1;const a=t+r;return this.valueHexView=s.subarray(t,a),this.valueHexView.length?(this.blockLength=r,a):(this.warnings.push("Zero buffer length"),t)}toBER(e=!1){return this.isHexOnly?e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.byteLength===this.valueHexView.buffer.byteLength?this.valueHexView.buffer:this.valueHexView.slice().buffer:(this.error="Flag 'isHexOnly' is not set, abort",d)}toJSON(){return{...super.toJSON(),isHexOnly:this.isHexOnly,valueHex:Convert.ToHex(this.valueHexView)}}}).NAME="hexBlock",t}class LocalBaseBlock{static blockName(){return this.NAME}get valueBeforeDecode(){return this.valueBeforeDecodeView.slice().buffer}set valueBeforeDecode(e){this.valueBeforeDecodeView=new Uint8Array(e)}constructor({blockLength:e=0,error:t="",warnings:r=[],valueBeforeDecode:s=p}={}){this.blockLength=e,this.error=t,this.warnings=r,this.valueBeforeDecodeView=BufferSourceConverter.toUint8Array(s)}toJSON(){return{blockName:this.constructor.NAME,blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:Convert.ToHex(this.valueBeforeDecodeView)}}}LocalBaseBlock.NAME="baseBlock";class ValueBlock extends LocalBaseBlock{fromBER(e,t,r){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}toBER(e,t){throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'")}}ValueBlock.NAME="valueBlock";class LocalIdentificationBlock extends(HexBlock(LocalBaseBlock)){constructor({idBlock:e={}}={}){var t,r,s,a;super(),e?(this.isHexOnly=null!==(t=e.isHexOnly)&&void 0!==t&&t,this.valueHexView=e.valueHex?BufferSourceConverter.toUint8Array(e.valueHex):p,this.tagClass=null!==(r=e.tagClass)&&void 0!==r?r:-1,this.tagNumber=null!==(s=e.tagNumber)&&void 0!==s?s:-1,this.isConstructed=null!==(a=e.isConstructed)&&void 0!==a&&a):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}toBER(e=!1){let t=0;switch(this.tagClass){case 1:t|=0;break;case 2:t|=64;break;case 3:t|=128;break;case 4:t|=192;break;default:return this.error="Unknown tag class",d}if(this.isConstructed&&(t|=32),this.tagNumber<31&&!this.isHexOnly){const r=new Uint8Array(1);if(!e){let e=this.tagNumber;e&=31,t|=e,r[0]=t}return r.buffer}if(!this.isHexOnly){const r=utilToBase(this.tagNumber,7),s=new Uint8Array(r),a=r.byteLength,i=new Uint8Array(a+1);if(i[0]=31|t,!e){for(let e=0;e<a-1;e++)i[e+1]=128|s[e];i[a]=s[a-1]}return i.buffer}const r=new Uint8Array(this.valueHexView.byteLength+1);if(r[0]=31|t,!e){const e=this.valueHexView;for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHexView.byteLength]=e[e.length-1]}return r.buffer}fromBER(e,t,r){const s=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,s,t,r))return-1;const a=s.subarray(t,t+r);if(0===a.length)return this.error="Zero buffer length",-1;switch(192&a[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=!(32&~a[0]),this.isHexOnly=!1;const i=31&a[0];if(31!==i)this.tagNumber=i,this.blockLength=1;else{let e=1,t=this.valueHexView=new Uint8Array(255),r=255;for(;128&a[e];){if(t[e-1]=127&a[e],e++,e>=a.length)return this.error="End of input reached before message was fully decoded",-1;if(e===r){r+=255;const e=new Uint8Array(r);for(let r=0;r<t.length;r++)e[r]=t[r];t=this.valueHexView=new Uint8Array(r)}}this.blockLength=e+1,t[e-1]=127&a[e];const s=new Uint8Array(e);for(let r=0;r<e;r++)s[r]=t[r];t=this.valueHexView=new Uint8Array(e),t.set(s),this.blockLength<=9?this.tagNumber=utilFromBase(t,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){return{...super.toJSON(),tagClass:this.tagClass,tagNumber:this.tagNumber,isConstructed:this.isConstructed}}}LocalIdentificationBlock.NAME="identificationBlock";class LocalLengthBlock extends LocalBaseBlock{constructor({lenBlock:e={}}={}){var t,r,s;super(),this.isIndefiniteForm=null!==(t=e.isIndefiniteForm)&&void 0!==t&&t,this.longFormUsed=null!==(r=e.longFormUsed)&&void 0!==r&&r,this.length=null!==(s=e.length)&&void 0!==s?s:0}fromBER(e,t,r){const s=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,s,t,r))return-1;const a=s.subarray(t,t+r);if(0===a.length)return this.error="Zero buffer length",-1;if(255===a[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===a[0],this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&a[0]),!1===this.longFormUsed)return this.length=a[0],this.blockLength=1,t+this.blockLength;const i=127&a[0];if(i>8)return this.error="Too big integer",-1;if(i+1>a.length)return this.error="End of input reached before message was fully decoded",-1;const n=t+1,o=s.subarray(n,n+i);return 0===o[i-1]&&this.warnings.push("Needlessly long encoded length"),this.length=utilFromBase(o,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=i+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=128),t;if(this.longFormUsed){const s=utilToBase(this.length,8);if(s.byteLength>127)return this.error="Too big length",d;if(t=new ArrayBuffer(s.byteLength+1),e)return t;const a=new Uint8Array(s);r=new Uint8Array(t),r[0]=128|s.byteLength;for(let e=0;e<s.byteLength;e++)r[e+1]=a[e];return t}return t=new ArrayBuffer(1),!1===e&&(r=new Uint8Array(t),r[0]=this.length),t}toJSON(){return{...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,longFormUsed:this.longFormUsed,length:this.length}}}LocalLengthBlock.NAME="lengthBlock";const v={};class BaseBlock extends LocalBaseBlock{constructor({name:e="",optional:t=!1,primitiveSchema:r,...s}={},a){super(s),this.name=e,this.optional=t,r&&(this.primitiveSchema=r),this.idBlock=new LocalIdentificationBlock(s),this.lenBlock=new LocalLengthBlock(s),this.valueBlock=a?new a(s):new ValueBlock(s)}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e,t){const r=t||new ViewWriter;t||prepareIndefiniteForm(this);const s=this.idBlock.toBER(e);if(r.write(s),this.lenBlock.isIndefiniteForm)r.write(new Uint8Array([128]).buffer),this.valueBlock.toBER(e,r),r.write(new ArrayBuffer(2));else{const t=this.valueBlock.toBER(e);this.lenBlock.length=t.byteLength;const s=this.lenBlock.toBER(e);r.write(s),r.write(t)}return t?d:r.final()}toJSON(){const e={...super.toJSON(),idBlock:this.idBlock.toJSON(),lenBlock:this.lenBlock.toJSON(),valueBlock:this.valueBlock.toJSON(),name:this.name,optional:this.optional};return this.primitiveSchema&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}toString(e="ascii"){return"ascii"===e?this.onAsciiEncoding():Convert.ToHex(this.toBER())}onAsciiEncoding(){return`${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`}isEqual(e){if(this===e)return!0;if(!(e instanceof this.constructor))return!1;return isEqualBuffer(this.toBER(),e.toBER())}}function prepareIndefiniteForm(e){var t;if(e instanceof v.Constructed)for(const t of e.valueBlock.value)prepareIndefiniteForm(t)&&(e.lenBlock.isIndefiniteForm=!0);return!!(null===(t=e.lenBlock)||void 0===t?void 0:t.isIndefiniteForm)}BaseBlock.NAME="BaseBlock";class BaseStringBlock extends BaseBlock{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor({value:e="",...t}={},r){super(t,r),e&&this.fromString(e)}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHexView),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){return`${this.constructor.NAME} : '${this.valueBlock.value}'`}}BaseStringBlock.NAME="BaseStringBlock";class LocalPrimitiveValueBlock extends(HexBlock(ValueBlock)){constructor({isHexOnly:e=!0,...t}={}){super(t),this.isHexOnly=e}}var b,A,k,C,V,B,I,N,P,E,D,O,x,R,K,U,T,L,H,q,j,M,J,_,F,$,W,G,z;LocalPrimitiveValueBlock.NAME="PrimitiveValueBlock";class Primitive extends BaseBlock{constructor(e={}){super(e,LocalPrimitiveValueBlock),this.idBlock.isConstructed=!1}}function localFromBER(e,t=0,r=e.length){const s=t;let a=new BaseBlock({},ValueBlock);const i=new LocalBaseBlock;if(!checkBufferParams(i,e,t,r))return a.error=i.error,{offset:-1,result:a};if(!e.subarray(t,t+r).length)return a.error="Zero buffer length",{offset:-1,result:a};let n=a.idBlock.fromBER(e,t,r);if(a.idBlock.warnings.length&&a.warnings.concat(a.idBlock.warnings),-1===n)return a.error=a.idBlock.error,{offset:-1,result:a};if(t=n,r-=a.idBlock.blockLength,n=a.lenBlock.fromBER(e,t,r),a.lenBlock.warnings.length&&a.warnings.concat(a.lenBlock.warnings),-1===n)return a.error=a.lenBlock.error,{offset:-1,result:a};if(t=n,r-=a.lenBlock.blockLength,!a.idBlock.isConstructed&&a.lenBlock.isIndefiniteForm)return a.error="Indefinite length form used for primitive encoding form",{offset:-1,result:a};let o=BaseBlock;if(1===a.idBlock.tagClass){if(a.idBlock.tagNumber>=37&&!1===a.idBlock.isHexOnly)return a.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:a};switch(a.idBlock.tagNumber){case 0:if(a.idBlock.isConstructed&&a.lenBlock.length>0)return a.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:a};o=v.EndOfContent;break;case 1:o=v.Boolean;break;case 2:o=v.Integer;break;case 3:o=v.BitString;break;case 4:o=v.OctetString;break;case 5:o=v.Null;break;case 6:o=v.ObjectIdentifier;break;case 10:o=v.Enumerated;break;case 12:o=v.Utf8String;break;case 13:o=v.RelativeObjectIdentifier;break;case 14:o=v.TIME;break;case 15:return a.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:a};case 16:o=v.Sequence;break;case 17:o=v.Set;break;case 18:o=v.NumericString;break;case 19:o=v.PrintableString;break;case 20:o=v.TeletexString;break;case 21:o=v.VideotexString;break;case 22:o=v.IA5String;break;case 23:o=v.UTCTime;break;case 24:o=v.GeneralizedTime;break;case 25:o=v.GraphicString;break;case 26:o=v.VisibleString;break;case 27:o=v.GeneralString;break;case 28:o=v.UniversalString;break;case 29:o=v.CharacterString;break;case 30:o=v.BmpString;break;case 31:o=v.DATE;break;case 32:o=v.TimeOfDay;break;case 33:o=v.DateTime;break;case 34:o=v.Duration;break;default:{const e=a.idBlock.isConstructed?new v.Constructed:new v.Primitive;e.idBlock=a.idBlock,e.lenBlock=a.lenBlock,e.warnings=a.warnings,a=e}}}else o=a.idBlock.isConstructed?v.Constructed:v.Primitive;return a=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecodeView=e.valueBeforeDecodeView,r}(a,o),n=a.fromBER(e,t,a.lenBlock.isIndefiniteForm?r:a.lenBlock.length),a.valueBeforeDecodeView=e.subarray(s,s+a.blockLength),{offset:n,result:a}}function fromBER(e){if(!e.byteLength){const e=new BaseBlock({},ValueBlock);return e.error="Input buffer has zero length",{offset:-1,result:e}}return localFromBER(BufferSourceConverter.toUint8Array(e).slice(),0,e.byteLength)}function checkLen(e,t){return e?1:t}b=Primitive,v.Primitive=b,Primitive.NAME="PRIMITIVE";class LocalConstructedValueBlock extends ValueBlock{constructor({value:e=[],isIndefiniteForm:t=!1,...r}={}){super(r),this.value=e,this.isIndefiniteForm=t}fromBER(e,t,r){const s=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,s,t,r))return-1;if(this.valueBeforeDecodeView=s.subarray(t,t+r),0===this.valueBeforeDecodeView.length)return this.warnings.push("Zero buffer length"),t;let a=t;for(;checkLen(this.isIndefiniteForm,r)>0;){const e=localFromBER(s,a,r);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(a=e.offset,this.blockLength+=e.result.blockLength,r-=e.result.blockLength,this.value.push(e.result),this.isIndefiniteForm&&e.result.constructor.NAME===S)break}return this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.NAME===S?this.value.pop():this.warnings.push("No EndOfContent block encoded")),a}toBER(e,t){const r=t||new ViewWriter;for(let t=0;t<this.value.length;t++)this.value[t].toBER(e,r);return t?d:r.final()}toJSON(){const e={...super.toJSON(),isIndefiniteForm:this.isIndefiniteForm,value:[]};for(const t of this.value)e.value.push(t.toJSON());return e}}LocalConstructedValueBlock.NAME="ConstructedValueBlock";class Constructed extends BaseBlock{constructor(e={}){super(e,LocalConstructedValueBlock),this.idBlock.isConstructed=!0}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.valueBlock.error.length||(this.blockLength+=this.valueBlock.blockLength),s)}onAsciiEncoding(){const e=[];for(const t of this.valueBlock.value)e.push(t.toString("ascii").split("\n").map(e=>`  ${e}`).join("\n"));const t=3===this.idBlock.tagClass?`[${this.idBlock.tagNumber}]`:this.constructor.NAME;return e.length?`${t} :\n${e.join("\n")}`:`${t} :`}}A=Constructed,v.Constructed=A,Constructed.NAME="CONSTRUCTED";class LocalEndOfContentValueBlock extends ValueBlock{fromBER(e,t,r){return t}toBER(e){return d}}LocalEndOfContentValueBlock.override="EndOfContentValueBlock";class EndOfContent extends BaseBlock{constructor(e={}){super(e,LocalEndOfContentValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}}k=EndOfContent,v.EndOfContent=k,EndOfContent.NAME=S;class Null extends BaseBlock{constructor(e={}){super(e,ValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),this.idBlock.error.length||(this.blockLength+=this.idBlock.blockLength),this.lenBlock.error.length||(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r>e.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):t+r}toBER(e,t){const r=new ArrayBuffer(2);if(!e){const e=new Uint8Array(r);e[0]=5,e[1]=0}return t&&t.write(r),r}onAsciiEncoding(){return`${this.constructor.NAME}`}}C=Null,v.Null=C,Null.NAME="NULL";class LocalBooleanValueBlock extends(HexBlock(ValueBlock)){get value(){for(const e of this.valueHexView)if(e>0)return!0;return!1}set value(e){this.valueHexView[0]=e?255:0}constructor({value:e,...t}={}){super(t),t.valueHex?this.valueHexView=BufferSourceConverter.toUint8Array(t.valueHex):this.valueHexView=new Uint8Array(1),e&&(this.value=e)}fromBER(e,t,r){const s=BufferSourceConverter.toUint8Array(e);return checkBufferParams(this,s,t,r)?(this.valueHexView=s.subarray(t,t+r),r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,utilDecodeTC.call(this),this.blockLength=r,t+r):-1}toBER(){return this.valueHexView.slice()}toJSON(){return{...super.toJSON(),value:this.value}}}LocalBooleanValueBlock.NAME="BooleanValueBlock";class Boolean extends BaseBlock{getValue(){return this.valueBlock.value}setValue(e){this.valueBlock.value=e}constructor(e={}){super(e,LocalBooleanValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.getValue}`}}V=Boolean,v.Boolean=V,Boolean.NAME="BOOLEAN";class LocalOctetStringValueBlock extends(HexBlock(LocalConstructedValueBlock)){constructor({isConstructed:e=!1,...t}={}){super(t),this.isConstructed=e}fromBER(e,t,r){let s=0;if(this.isConstructed){if(this.isHexOnly=!1,s=LocalConstructedValueBlock.prototype.fromBER.call(this,e,t,r),-1===s)return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.NAME;if(t===S){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==y)return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e,t){return this.isConstructed?LocalConstructedValueBlock.prototype.toBER.call(this,e,t):e?new ArrayBuffer(this.valueHexView.byteLength):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),isConstructed:this.isConstructed}}}LocalOctetStringValueBlock.NAME="OctetStringValueBlock";class OctetString extends BaseBlock{constructor({idBlock:e={},lenBlock:t={},...r}={}){var s,a;null!==(s=r.isConstructed)&&void 0!==s||(r.isConstructed=!!(null===(a=r.value)||void 0===a?void 0:a.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},LocalOctetStringValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r)return 0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t;if(!this.valueBlock.isConstructed){const s=(e instanceof ArrayBuffer?new Uint8Array(e):e).subarray(t,t+r);try{if(s.byteLength){const e=localFromBER(s,0,s.byteLength);-1!==e.offset&&e.offset===r&&(this.valueBlock.value=[e.result])}}catch{}}return super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return Constructed.prototype.onAsciiEncoding.call(this);return`${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueHexView)}`}getValue(){if(!this.idBlock.isConstructed)return this.valueBlock.valueHexView.slice().buffer;const e=[];for(const t of this.valueBlock.value)t instanceof B&&e.push(t.valueBlock.valueHexView);return BufferSourceConverter.concat(e)}}B=OctetString,v.OctetString=B,OctetString.NAME=y;class LocalBitStringValueBlock extends(HexBlock(LocalConstructedValueBlock)){constructor({unusedBits:e=0,isConstructed:t=!1,...r}={}){super(r),this.unusedBits=e,this.isConstructed=t,this.blockLength=this.valueHexView.byteLength}fromBER(e,t,r){if(!r)return t;let s=-1;if(this.isConstructed){if(s=LocalConstructedValueBlock.prototype.fromBER.call(this,e,t,r),-1===s)return s;for(const e of this.value){const t=e.constructor.NAME;if(t===S){if(this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==w)return this.error="BIT STRING may consists of BIT STRINGs only",-1;const r=e.valueBlock;if(this.unusedBits>0&&r.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;this.unusedBits=r.unusedBits}return s}const a=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,a,t,r))return-1;const i=a.subarray(t,t+r);if(this.unusedBits=i[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const e=i.subarray(1);try{if(e.byteLength){const t=localFromBER(e,0,e.byteLength);-1!==t.offset&&t.offset===r-1&&(this.value=[t.result])}}catch{}}return this.valueHexView=i.subarray(1),this.blockLength=i.length,t+r}toBER(e,t){if(this.isConstructed)return LocalConstructedValueBlock.prototype.toBER.call(this,e,t);if(e)return new ArrayBuffer(this.valueHexView.byteLength+1);if(!this.valueHexView.byteLength)return d;const r=new Uint8Array(this.valueHexView.length+1);return r[0]=this.unusedBits,r.set(this.valueHexView,1),r.buffer}toJSON(){return{...super.toJSON(),unusedBits:this.unusedBits,isConstructed:this.isConstructed}}}LocalBitStringValueBlock.NAME="BitStringValueBlock";class BitString extends BaseBlock{constructor({idBlock:e={},lenBlock:t={},...r}={}){var s,a;null!==(s=r.isConstructed)&&void 0!==s||(r.isConstructed=!!(null===(a=r.value)||void 0===a?void 0:a.length)),super({idBlock:{isConstructed:r.isConstructed,...e},lenBlock:{...t,isIndefiniteForm:!!r.isIndefiniteForm},...r},LocalBitStringValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r)}onAsciiEncoding(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return Constructed.prototype.onAsciiEncoding.call(this);{const e=[],t=this.valueBlock.valueHexView;for(const r of t)e.push(r.toString(2).padStart(8,"0"));const r=e.join("");return`${this.constructor.NAME} : ${r.substring(0,r.length-this.valueBlock.unusedBits)}`}}}function viewAdd(e,t){const r=new Uint8Array([0]),s=new Uint8Array(e),a=new Uint8Array(t);let i=s.slice(0);const n=i.length-1,o=a.slice(0),l=o.length-1;let c=0;let u=0;for(let e=l<n?n:l;e>=0;e--,u++){if(!0==u<o.length)c=i[n-u]+o[l-u]+r[0];else c=i[n-u]+r[0];if(r[0]=c/10,!0==u>=i.length)i=utilConcatView(new Uint8Array([c%10]),i);else i[n-u]=c%10}return r[0]>0&&(i=utilConcatView(r,i)),i}function power2(e){if(e>=u.length)for(let t=u.length;t<=e;t++){const e=new Uint8Array([0]);let r=u[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const s=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=s[0]/10,r[t]=s[0]%10}e[0]>0&&(r=utilConcatView(e,r)),u.push(r)}return u[e]}function viewSub(e,t){let r=0;const s=new Uint8Array(e),a=new Uint8Array(t),i=s.slice(0),n=i.length-1,o=a.slice(0),l=o.length-1;let c,u=0;for(let e=l;e>=0;e--,u++)if(c=i[n-u]-o[l-u]-r,!0==c<0)r=1,i[n-u]=c+10;else r=0,i[n-u]=c;if(r>0)for(let e=n-l+1;e>=0;e--,u++){if(c=i[n-u]-r,!(c<0)){r=0,i[n-u]=c;break}r=1,i[n-u]=c+10}return i.slice()}I=BitString,v.BitString=I,BitString.NAME=w;class LocalIntegerValueBlock extends(HexBlock(ValueBlock)){setValueHex(){this.valueHexView.length>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,this.valueHexView.length>0&&(this._valueDec=utilDecodeTC.call(this)))}constructor({value:e,...t}={}){super(t),this._valueDec=0,t.valueHex&&this.setValueHex(),void 0!==e&&(this.valueDec=e)}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this.valueHexView=new Uint8Array(function(e){const t=e<0?-1*e:e;let r=128;for(let s=1;s<8;s++){if(t<=r){if(e<0){const e=utilToBase(r-t,8,s);return new Uint8Array(e)[0]|=128,e}let a=utilToBase(t,8,s),i=new Uint8Array(a);if(128&i[0]){const e=a.slice(0),t=new Uint8Array(e);a=new ArrayBuffer(a.byteLength+1),i=new Uint8Array(a);for(let r=0;r<e.byteLength;r++)i[r+1]=t[r];i[0]=0}return a}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(e))}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const a=this.fromBER(e,t,r);if(-1===a)return a;const i=this.valueHexView;return 0===i[0]&&128&i[1]?this.valueHexView=i.subarray(1):0!==s&&i.length<s&&(s-i.length>1&&(s=i.length+1),this.valueHexView=i.subarray(s-i.length)),a}toDER(e=!1){const t=this.valueHexView;switch(!0){case!!(128&t[0]):{const e=new Uint8Array(this.valueHexView.length+1);e[0]=0,e.set(t,1),this.valueHexView=e}break;case 0===t[0]&&!(128&t[1]):this.valueHexView=this.valueHexView.subarray(1)}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return-1===s||this.setValueHex(),s}toBER(e){return e?new ArrayBuffer(this.valueHexView.length):this.valueHexView.slice().buffer}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}toString(){const e=8*this.valueHexView.length-1;let t,r=new Uint8Array(8*this.valueHexView.length/3),s=0;const a=this.valueHexView;let i="",n=!1;for(let n=a.byteLength-1;n>=0;n--){t=a[n];for(let a=0;a<8;a++){if(!(1&~t))if(s===e)r=viewSub(power2(s),r),i="-";else r=viewAdd(r,power2(s));s++,t>>=1}}for(let e=0;e<r.length;e++)r[e]&&(n=!0),n&&(i+=h.charAt(r[e]));return!1===n&&(i+=h.charAt(0)),i}}N=LocalIntegerValueBlock,LocalIntegerValueBlock.NAME="IntegerValueBlock",Object.defineProperty(N.prototype,"valueHex",{set:function(e){this.valueHexView=new Uint8Array(e),this.setValueHex()},get:function(){return this.valueHexView.slice().buffer}});class Integer extends BaseBlock{constructor(e={}){super(e,LocalIntegerValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}toBigInt(){return assertBigInt(),BigInt(this.valueBlock.toString())}static fromBigInt(e){assertBigInt();const t=BigInt(e),r=new ViewWriter,s=t.toString(16).replace(/^-/,""),a=new Uint8Array(Convert.FromHex(s));if(t<0){const e=new Uint8Array(a.length+(128&a[0]?1:0));e[0]|=128;const s=BigInt(`0x${Convert.ToHex(e)}`)+t,i=BufferSourceConverter.toUint8Array(Convert.FromHex(s.toString(16)));i[0]|=128,r.write(i)}else 128&a[0]&&r.write(new Uint8Array([0])),r.write(a);return new P({valueHex:r.final()})}convertToDER(){const e=new P({valueHex:this.valueBlock.valueHexView});return e.valueBlock.toDER(),e}convertFromDER(){return new P({valueHex:0===this.valueBlock.valueHexView[0]?this.valueBlock.valueHexView.subarray(1):this.valueBlock.valueHexView})}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()}`}}P=Integer,v.Integer=P,Integer.NAME="INTEGER";class Enumerated extends Integer{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}}E=Enumerated,v.Enumerated=E,Enumerated.NAME="ENUMERATED";class LocalSidValueBlock extends(HexBlock(ValueBlock)){constructor({valueDec:e=-1,isFirstSid:t=!1,...r}={}){super(r),this.valueDec=e,this.isFirstSid=t}fromBER(e,t,r){if(!r)return t;const s=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,s,t,r))return-1;const a=s.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let e=0;e<r&&(this.valueHexView[e]=127&a[e],this.blockLength++,128&a[e]);e++);const i=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)i[e]=this.valueHexView[e];return this.valueHexView=i,128&a[this.blockLength-1]?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=utilFromBase(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}set valueBigInt(e){assertBigInt();let t=BigInt(e).toString(2);for(;t.length%7;)t="0"+t;const r=new Uint8Array(t.length/7);for(let e=0;e<r.length;e++)r[e]=parseInt(t.slice(7*e,7*e+7),2)+(e+1<r.length?128:0);this.fromBER(r.buffer,0,r.length)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,r=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)r[e]=128|t[e];return r[this.blockLength-1]=t[this.blockLength-1],r.buffer}const t=utilToBase(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",d;const r=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),s=t.byteLength-1;for(let t=0;t<s;t++)r[t]=128|e[t];r[s]=e[s]}return r}toString(){let e="";if(this.isHexOnly)e=Convert.ToHex(this.valueHexView);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec,isFirstSid:this.isFirstSid}}}LocalSidValueBlock.NAME="sidBlock";class LocalObjectIdentifierValueBlock extends ValueBlock{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let s=t;for(;r>0;){const t=new LocalSidValueBlock;if(s=t.fromBER(e,s,r),-1===s)return this.blockLength=0,this.error=t.error,s;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e){const t=[];for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(0===s.byteLength)return this.error=this.value[r].error,d;t.push(s)}return concat(t)}fromString(e){this.value=[];let t=0,r=0,s="",a=!1;do{if(r=e.indexOf(".",t),s=-1===r?e.substring(t):e.substring(t,r),t=r+1,a){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return void(this.value=[])}const r=parseInt(s,10);if(isNaN(r))return;e.valueDec=r+t,a=!1}else{const e=new LocalSidValueBlock;if(s>Number.MAX_SAFE_INTEGER){assertBigInt();const t=BigInt(s);e.valueBigInt=t}else if(e.valueDec=parseInt(s,10),isNaN(e.valueDec))return;this.value.length||(e.isFirstSid=!0,a=!0),this.value.push(e)}}while(-1!==r)}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e=`${e}.`),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}LocalObjectIdentifierValueBlock.NAME="ObjectIdentifierValueBlock";class ObjectIdentifier extends BaseBlock{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,LocalObjectIdentifierValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}D=ObjectIdentifier,v.ObjectIdentifier=D,ObjectIdentifier.NAME="OBJECT IDENTIFIER";class LocalRelativeSidValueBlock extends(HexBlock(LocalBaseBlock)){constructor({valueDec:e=0,...t}={}){super(t),this.valueDec=e}fromBER(e,t,r){if(0===r)return t;const s=BufferSourceConverter.toUint8Array(e);if(!checkBufferParams(this,s,t,r))return-1;const a=s.subarray(t,t+r);this.valueHexView=new Uint8Array(r);for(let e=0;e<r&&(this.valueHexView[e]=127&a[e],this.blockLength++,128&a[e]);e++);const i=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength;e++)i[e]=this.valueHexView[e];return this.valueHexView=i,128&a[this.blockLength-1]?(this.error="End of input reached before message was fully decoded",-1):(0===this.valueHexView[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=utilFromBase(this.valueHexView,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e){if(this.isHexOnly){if(e)return new ArrayBuffer(this.valueHexView.byteLength);const t=this.valueHexView,r=new Uint8Array(this.blockLength);for(let e=0;e<this.blockLength-1;e++)r[e]=128|t[e];return r[this.blockLength-1]=t[this.blockLength-1],r.buffer}const t=utilToBase(this.valueDec,7);if(0===t.byteLength)return this.error="Error during encoding SID value",d;const r=new Uint8Array(t.byteLength);if(!e){const e=new Uint8Array(t),s=t.byteLength-1;for(let t=0;t<s;t++)r[t]=128|e[t];r[s]=e[s]}return r.buffer}toString(){let e="";return e=this.isHexOnly?Convert.ToHex(this.valueHexView):this.valueDec.toString(),e}toJSON(){return{...super.toJSON(),valueDec:this.valueDec}}}LocalRelativeSidValueBlock.NAME="relativeSidBlock";class LocalRelativeObjectIdentifierValueBlock extends ValueBlock{constructor({value:e="",...t}={}){super(t),this.value=[],e&&this.fromString(e)}fromBER(e,t,r){let s=t;for(;r>0;){const t=new LocalRelativeSidValueBlock;if(s=t.fromBER(e,s,r),-1===s)return this.blockLength=0,this.error=t.error,s;this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e,t){const r=[];for(let t=0;t<this.value.length;t++){const s=this.value[t].toBER(e);if(0===s.byteLength)return this.error=this.value[t].error,d;r.push(s)}return concat(r)}fromString(e){this.value=[];let t=0,r=0,s="";do{r=e.indexOf(".",t),s=-1===r?e.substring(t):e.substring(t,r),t=r+1;const a=new LocalRelativeSidValueBlock;if(a.valueDec=parseInt(s,10),isNaN(a.valueDec))return!0;this.value.push(a)}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e=`${e}.`),t?(s=`{${s}}`,e+=s):e+=s}return e}toJSON(){const e={...super.toJSON(),value:this.toString(),sidArray:[]};for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}LocalRelativeObjectIdentifierValueBlock.NAME="RelativeObjectIdentifierValueBlock";class RelativeObjectIdentifier extends BaseBlock{getValue(){return this.valueBlock.toString()}setValue(e){this.valueBlock.fromString(e)}constructor(e={}){super(e,LocalRelativeObjectIdentifierValueBlock),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.valueBlock.toString()||"empty"}`}toJSON(){return{...super.toJSON(),value:this.getValue()}}}O=RelativeObjectIdentifier,v.RelativeObjectIdentifier=O,RelativeObjectIdentifier.NAME="RelativeObjectIdentifier";class Sequence extends Constructed{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}}x=Sequence,v.Sequence=x,Sequence.NAME="SEQUENCE";class Set extends Constructed{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}}R=Set,v.Set=R,Set.NAME="SET";class LocalStringValueBlock extends(HexBlock(ValueBlock)){constructor({...e}={}){super(e),this.isHexOnly=!0,this.value=g}toJSON(){return{...super.toJSON(),value:this.value}}}LocalStringValueBlock.NAME="StringValueBlock";class LocalSimpleStringValueBlock extends LocalStringValueBlock{}LocalSimpleStringValueBlock.NAME="SimpleStringValueBlock";class LocalSimpleStringBlock extends BaseStringBlock{constructor({...e}={}){super(e,LocalSimpleStringValueBlock)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,BufferSourceConverter.toUint8Array(e))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}LocalSimpleStringBlock.NAME="SIMPLE STRING";class LocalUtf8StringValueBlock extends LocalSimpleStringBlock{fromBuffer(e){this.valueBlock.valueHexView=BufferSourceConverter.toUint8Array(e);try{this.valueBlock.value=Convert.ToUtf8String(e)}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`),this.valueBlock.value=Convert.ToBinary(e)}}fromString(e){this.valueBlock.valueHexView=new Uint8Array(Convert.FromUtf8String(e)),this.valueBlock.value=e}}LocalUtf8StringValueBlock.NAME="Utf8StringValueBlock";class Utf8String extends LocalUtf8StringValueBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}}K=Utf8String,v.Utf8String=K,Utf8String.NAME="UTF8String";class LocalBmpStringValueBlock extends LocalSimpleStringBlock{fromBuffer(e){this.valueBlock.value=Convert.ToUtf16String(e),this.valueBlock.valueHexView=BufferSourceConverter.toUint8Array(e)}fromString(e){this.valueBlock.value=e,this.valueBlock.valueHexView=new Uint8Array(Convert.FromUtf16String(e))}}LocalBmpStringValueBlock.NAME="BmpStringValueBlock";class BmpString extends LocalBmpStringValueBlock{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}}U=BmpString,v.BmpString=U,BmpString.NAME="BMPString";class LocalUniversalStringValueBlock extends LocalSimpleStringBlock{fromBuffer(e){const t=ArrayBuffer.isView(e)?e.slice().buffer:e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length,r=this.valueBlock.valueHexView=new Uint8Array(4*t);for(let s=0;s<t;s++){const t=utilToBase(e.charCodeAt(s),8),a=new Uint8Array(t);if(a.length>4)continue;const i=4-a.length;for(let e=a.length-1;e>=0;e--)r[4*s+e+i]=a[e]}this.valueBlock.value=e}}LocalUniversalStringValueBlock.NAME="UniversalStringValueBlock";class UniversalString extends LocalUniversalStringValueBlock{constructor({...e}={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}}T=UniversalString,v.UniversalString=T,UniversalString.NAME="UniversalString";class NumericString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}}L=NumericString,v.NumericString=L,NumericString.NAME="NumericString";class PrintableString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}}H=PrintableString,v.PrintableString=H,PrintableString.NAME="PrintableString";class TeletexString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}}q=TeletexString,v.TeletexString=q,TeletexString.NAME="TeletexString";class VideotexString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}}j=VideotexString,v.VideotexString=j,VideotexString.NAME="VideotexString";class IA5String extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}}M=IA5String,v.IA5String=M,IA5String.NAME="IA5String";class GraphicString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}}J=GraphicString,v.GraphicString=J,GraphicString.NAME="GraphicString";class VisibleString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}}_=VisibleString,v.VisibleString=_,VisibleString.NAME="VisibleString";class GeneralString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}}F=GeneralString,v.GeneralString=F,GeneralString.NAME="GeneralString";class CharacterString extends LocalSimpleStringBlock{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}}$=CharacterString,v.CharacterString=$,CharacterString.NAME="CharacterString";class UTCTime extends VisibleString{constructor({value:e,valueDate:t,...r}={}){if(super(r),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,e){this.fromString(e),this.valueBlock.valueHexView=new Uint8Array(e.length);for(let t=0;t<e.length;t++)this.valueBlock.valueHexView[t]=e.charCodeAt(t)}t&&(this.fromDate(t),this.valueBlock.valueHexView=new Uint8Array(this.toBuffer())),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,BufferSourceConverter.toUint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(e);if(null===t)return void(this.error="Wrong input string for conversion");const r=parseInt(t[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(t[2],10),this.day=parseInt(t[3],10),this.hour=parseInt(t[4],10),this.minute=parseInt(t[5],10),this.second=parseInt(t[6],10)}toString(e="iso"){if("iso"===e){const e=new Array(7);return e[0]=padNumber(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=padNumber(this.month,2),e[2]=padNumber(this.day,2),e[3]=padNumber(this.hour,2),e[4]=padNumber(this.minute,2),e[5]=padNumber(this.second,2),e[6]="Z",e.join("")}return super.toString(e)}onAsciiEncoding(){return`${this.constructor.NAME} : ${this.toDate().toISOString()}`}toJSON(){return{...super.toJSON(),year:this.year,month:this.month,day:this.day,hour:this.hour,minute:this.minute,second:this.second}}}W=UTCTime,v.UTCTime=W,UTCTime.NAME="UTCTime";class GeneralizedTime extends UTCTime{constructor(e={}){var t;super(e),null!==(t=this.millisecond)&&void 0!==t||(this.millisecond=0),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromDate(e){super.fromDate(e),this.millisecond=e.getUTCMilliseconds()}toDate(){const e=Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond);return new Date(e)}fromString(e){let t,r=!1,s="",a="",i=0,n=0,o=0;if("Z"===e[e.length-1])s=e.substring(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for conversion");s=e}if(r){if(-1!==s.indexOf("+"))throw new Error("Wrong input string for conversion");if(-1!==s.indexOf("-"))throw new Error("Wrong input string for conversion")}else{let e=1,t=s.indexOf("+"),r="";if(-1===t&&(t=s.indexOf("-"),e=-1),-1!==t){if(r=s.substring(t+1),s=s.substring(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for conversion");let a=parseInt(r.substring(0,2),10);if(isNaN(a.valueOf()))throw new Error("Wrong input string for conversion");if(n=e*a,4===r.length){if(a=parseInt(r.substring(2,4),10),isNaN(a.valueOf()))throw new Error("Wrong input string for conversion");o=e*a}}}let l=s.indexOf(".");if(-1===l&&(l=s.indexOf(",")),-1!==l){const e=new Number(`0${s.substring(l)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for conversion");i=e.valueOf(),a=s.substring(0,l)}else a=s;switch(!0){case 8===a.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==l)throw new Error("Wrong input string for conversion");break;case 10===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*i;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*i;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){const e=1e3*i;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for conversion")}const c=t.exec(a);if(null===c)throw new Error("Wrong input string for conversion");for(let e=1;e<c.length;e++)switch(e){case 1:this.year=parseInt(c[e],10);break;case 2:this.month=parseInt(c[e],10);break;case 3:this.day=parseInt(c[e],10);break;case 4:this.hour=parseInt(c[e],10)+n;break;case 5:this.minute=parseInt(c[e],10)+o;break;case 6:this.second=parseInt(c[e],10);break;default:throw new Error("Wrong input string for conversion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(e="iso"){if("iso"===e){const e=[];return e.push(padNumber(this.year,4)),e.push(padNumber(this.month,2)),e.push(padNumber(this.day,2)),e.push(padNumber(this.hour,2)),e.push(padNumber(this.minute,2)),e.push(padNumber(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(padNumber(this.millisecond,3))),e.push("Z"),e.join("")}return super.toString(e)}toJSON(){return{...super.toJSON(),millisecond:this.millisecond}}}G=GeneralizedTime,v.GeneralizedTime=G,GeneralizedTime.NAME="GeneralizedTime";let Q=class extends Utf8String{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}};var Z,Y,X,ee;z=Q,v.DATE=z,Q.NAME="DATE";class TimeOfDay extends Utf8String{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}}Z=TimeOfDay,v.TimeOfDay=Z,TimeOfDay.NAME="TimeOfDay";class DateTime extends Utf8String{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}}Y=DateTime,v.DateTime=Y,DateTime.NAME="DateTime";class Duration extends Utf8String{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}}X=Duration,v.Duration=X,Duration.NAME="Duration";class TIME extends Utf8String{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}}ee=TIME,v.TIME=ee,TIME.NAME="TIME";class Any{constructor({name:e="",optional:t=!1}={}){this.name=e,this.optional=t}}class Choice extends Any{constructor({value:e=[],...t}={}){super(t),this.value=e}}class Repeated extends Any{constructor({value:e=new Any,local:t=!1,...r}={}){super(r),this.value=e,this.local=t}}class RawData{get data(){return this.dataView.slice().buffer}set data(e){this.dataView=BufferSourceConverter.toUint8Array(e)}constructor({data:e=p}={}){this.dataView=BufferSourceConverter.toUint8Array(e)}fromBER(e,t,r){const s=t+r;return this.dataView=BufferSourceConverter.toUint8Array(e).subarray(t,s),s}toBER(e){return this.dataView.slice().buffer}}function compareSchema(e,t,r){if(r instanceof Choice){for(const s of r.value){if(compareSchema(e,t,s).verified)return{verified:!0,result:e}}{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty(m)&&(e.name=r.name),e}}if(r instanceof Any)return r.hasOwnProperty(m)&&(e[r.name]=t),{verified:!0,result:e};if(e instanceof Object==!1)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=r.idBlock.toBER(!1);if(0===s.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(s,0,s.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if(!("isHexOnly"in r.idBlock))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(r.idBlock.isHexOnly){if(f in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=r.idBlock.valueHexView,a=t.idBlock.valueHexView;if(s.length!==a.length)return{verified:!1,result:e};for(let t=0;t<s.length;t++)if(s[t]!==a[1])return{verified:!1,result:e}}if(r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,g),r.name&&(e[r.name]=t)),r instanceof v.Constructed){let s=0,a={verified:!1,result:{error:"Unknown error"}},i=r.valueBlock.value.length;if(i>0&&r.valueBlock.value[0]instanceof Repeated&&(i=t.valueBlock.value.length),0===i)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==r.valueBlock.value.length){let t=!0;for(let e=0;e<r.valueBlock.value.length;e++)t=t&&(r.valueBlock.value[e].optional||!1);return t?{verified:!0,result:e}:(r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,g),r.name&&delete e[r.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let n=0;n<i;n++)if(n-s>=t.valueBlock.value.length){if(!1===r.valueBlock.value[n].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,g),r.name&&(delete e[r.name],t.name=r.name)),t}}else if(r.valueBlock.value[0]instanceof Repeated){if(a=compareSchema(e,t.valueBlock.value[n],r.valueBlock.value[0].value),!1===a.verified){if(!r.valueBlock.value[0].optional)return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,g),r.name&&delete e[r.name]),a;s++}if(m in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let s={};s="local"in r.valueBlock.value[0]&&r.valueBlock.value[0].local?t:e,void 0===s[r.valueBlock.value[0].name]&&(s[r.valueBlock.value[0].name]=[]),s[r.valueBlock.value[0].name].push(t.valueBlock.value[n])}}else if(a=compareSchema(e,t.valueBlock.value[n-s],r.valueBlock.value[n]),!1===a.verified){if(!r.valueBlock.value[n].optional)return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,g),r.name&&delete e[r.name]),a;s++}if(!1===a.verified){const t={verified:!1,result:e};return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,g),r.name&&(delete e[r.name],t.name=r.name)),t}return{verified:!0,result:e}}if(r.primitiveSchema&&f in t.valueBlock){const s=localFromBER(t.valueBlock.valueHexView);if(-1===s.offset){const t={verified:!1,result:s.result};return r.name&&(r.name=r.name.replace(/^\s+|\s+$/g,g),r.name&&(delete e[r.name],t.name=r.name)),t}return compareSchema(e,s.result,r.primitiveSchema)}return{verified:!0,result:e}}class ByteStream{constructor(e={}){if("view"in e)this.fromUint8Array(e.view);else if("buffer"in e)this.fromArrayBuffer(e.buffer);else if("string"in e)this.fromString(e.string);else if("hexstring"in e)this.fromHexString(e.hexstring);else if("length"in e&&e.length>0){if(this.length=e.length,e.stub)for(let t=0;t<this._view.length;t++)this._view[t]=e.stub}else this.length=0}set buffer(e){this._buffer=e,this._view=new Uint8Array(this._buffer)}get buffer(){return this._buffer}set view(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}get view(){return this._view}get length(){return this.view.byteLength}set length(e){this._buffer=new ArrayBuffer(e),this._view=new Uint8Array(this._buffer)}clear(){this._buffer=new ArrayBuffer(0),this._view=new Uint8Array(this._buffer)}fromArrayBuffer(e){this._buffer=e,this._view=new Uint8Array(this._buffer)}fromUint8Array(e){this.fromArrayBuffer(new Uint8Array(e).buffer)}fromString(e){const t=e.length;this.length=t;for(let r=0;r<t;r++)this.view[r]=e.charCodeAt(r)}toString(e=0,t=this.view.length-e){let r="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let s=e;s<e+t;s++)r+=String.fromCharCode(this.view[s]);return r}fromHexString(e){const t=e.length;this.buffer=new ArrayBuffer(t>>1),this.view=new Uint8Array(this.buffer);const r=new Map;r.set("0",0),r.set("1",1),r.set("2",2),r.set("3",3),r.set("4",4),r.set("5",5),r.set("6",6),r.set("7",7),r.set("8",8),r.set("9",9),r.set("A",10),r.set("a",10),r.set("B",11),r.set("b",11),r.set("C",12),r.set("c",12),r.set("D",13),r.set("d",13),r.set("E",14),r.set("e",14),r.set("F",15),r.set("f",15);let s=0,a=0;for(let i=0;i<t;i++)i%2?(a|=r.get(e.charAt(i)),this.view[s]=a,s++):a=r.get(e.charAt(i))<<4}toHexString(e=0,t=this.view.length-e){let r="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let s=e;s<e+t;s++){const e=this.view[s].toString(16).toUpperCase();r=r+(1==e.length?"0":"")+e}return r}copy(e=0,t=this.length-e){if(!e&&!this.length)return new ByteStream;if(e<0||e>this.length-1)throw new Error(`Wrong start position: ${e}`);return new ByteStream({buffer:this._buffer.slice(e,e+t)})}slice(e=0,t=this.length){if(!e&&!this.length)return new ByteStream;if(e<0||e>this.length-1)throw new Error(`Wrong start position: ${e}`);return new ByteStream({buffer:this._buffer.slice(e,t)})}realloc(e){const t=new ArrayBuffer(e),r=new Uint8Array(t);e>this._view.length?r.set(this._view):r.set(new Uint8Array(this._buffer,0,e)),this._buffer=t,this._view=new Uint8Array(this._buffer)}append(e){const t=this.length,r=e.length,s=e._view.subarray();this.realloc(t+r),this._view.set(s,t)}insert(e,t=0,r=this.length-t){return!(t>this.length-1)&&(r>this.length-t&&(r=this.length-t),r>e.length&&(r=e.length),r==e.length?this._view.set(e._view,t):this._view.set(e._view.subarray(0,r),t),!0)}isEqual(e){if(this.length!=e.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e.view[t])return!1;return!0}isEqualView(e){if(e.length!=this.view.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e[t])return!1;return!0}findPattern(e,t,r,s){const{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s),o=e.length;if(o>i)return-1;const l=[];for(let t=0;t<o;t++)l.push(e.view[t]);for(let e=0;e<=i-o;e++){let t=!0;const r=n?a-o-e:a+e;for(let e=0;e<o;e++)if(this.view[e+r]!=l[e]){t=!1;break}if(t)return n?a-o-e:a+o+e}return-1}findFirstIn(e,t,r,s){const{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s),o={id:-1,position:n?0:a+i,length:0};for(let t=0;t<e.length;t++){const r=this.findPattern(e[t],a,i,n);if(-1!=r){let s=!1;const a=e[t].length;n?r-a>=o.position-o.length&&(s=!0):r-a<=o.position-o.length&&(s=!0),s&&(o.position=r,o.id=t,o.length=a)}}return o}findAllIn(e,t,r){let{start:s,length:a}=this.prepareFindParameters(t,r);const i=[];let n={id:-1,position:s};for(;;){const t=n.position;if(n=this.findFirstIn(e,n.position,a),-1==n.id)break;a-=n.position-t,i.push({id:n.id,position:n.position})}return i}findAllPatternIn(e,t,r){const{start:s,length:a}=this.prepareFindParameters(t,r),i=[],n=e.length;if(n>a)return-1;const o=Array.from(e.view);for(let e=0;e<=a-n;e++){let t=!0;const r=s+e;for(let e=0;e<n;e++)if(this.view[e+r]!=o[e]){t=!1;break}t&&(i.push(s+n+e),e+=n-1)}return i}findFirstNotIn(e,t,r,s){let{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s);const o={left:{id:-1,position:a},right:{id:-1,position:0},value:new ByteStream};let l=i;for(;l>0;){if(o.right=this.findFirstIn(e,n?a-i+l:a+i-l,l,n),-1==o.right.id){i=l,n?a-=i:a=o.left.position,o.value=new ByteStream({buffer:this._buffer.slice(a,a+i)});break}if(o.right.position!=(n?o.left.position-e[o.right.id].length:o.left.position+e[o.right.id].length)){n?(a=o.right.position+e[o.right.id].length,i=o.left.position-o.right.position-e[o.right.id].length):(a=o.left.position,i=o.right.position-o.left.position-e[o.right.id].length),o.value=new ByteStream({buffer:this._buffer.slice(a,a+i)});break}o.left=o.right,l-=e[o.right.id].length}if(n){const e=o.right;o.right=o.left,o.left=e}return o}findAllNotIn(e,t,r){let{start:s,length:a}=this.prepareFindParameters(t,r);const i=[];let n={left:{id:-1,position:s},right:{id:-1,position:s},value:new ByteStream};do{const t=n.right.position;n=this.findFirstNotIn(e,n.right.position,a),a-=n.right.position-t,i.push({left:{id:n.left.id,position:n.left.position},right:{id:n.right.id,position:n.right.position},value:n.value})}while(-1!=n.right.id);return i}findFirstSequence(e,t,r,s){let{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s);const o=this.skipNotPatterns(e,a,i,n);if(-1==o)return{position:-1,value:new ByteStream};const l=this.skipPatterns(e,o,i-(n?a-o:o-a),n);n?(a=l,i=o-l):(a=o,i=l-o);return{position:l,value:new ByteStream({buffer:this._buffer.slice(a,a+i)})}}findAllSequences(e,t,r){let{start:s,length:a}=this.prepareFindParameters(t,r);const i=[];let n={position:s,value:new ByteStream};do{const t=n.position;n=this.findFirstSequence(e,n.position,a),-1!=n.position&&(a-=n.position-t,i.push({position:n.position,value:n.value}))}while(-1!=n.position);return i}findPairedPatterns(e,t,r,s){const a=[];if(e.isEqual(t))return a;const{start:i,length:n}=this.prepareFindParameters(r,s);let o=0;const l=this.findAllPatternIn(e,i,n);if(!Array.isArray(l)||0==l.length)return a;const c=this.findAllPatternIn(t,i,n);if(!Array.isArray(c)||0==c.length)return a;for(;o<l.length&&0!=c.length;)if(l[0]!=c[0]){if(l[o]>c[0])break;for(;l[o]<c[0]&&(o++,!(o>=l.length)););a.push({left:l[o-1],right:c[0]}),l.splice(o-1,1),c.splice(0,1),o=0}else a.push({left:l[0],right:c[0]}),l.splice(0,1),c.splice(0,1);return a.sort((e,t)=>e.left-t.left),a}findPairedArrays(e,t,r,s){const{start:a,length:i}=this.prepareFindParameters(r,s),n=[];let o=0;const l=this.findAllIn(e,a,i);if(0==l.length)return n;const c=this.findAllIn(t,a,i);if(0==c.length)return n;for(;o<l.length&&0!=c.length;)if(l[0].position!=c[0].position){if(l[o].position>c[0].position)break;for(;l[o].position<c[0].position&&(o++,!(o>=l.length)););n.push({left:l[o-1],right:c[0]}),l.splice(o-1,1),c.splice(0,1),o=0}else n.push({left:l[0],right:c[0]}),l.splice(0,1),c.splice(0,1);return n.sort((e,t)=>e.left.position-t.left.position),n}replacePattern(e,t,r,s,a=null){let i,n=[];const o={status:-1,searchPatternPositions:[],replacePatternPositions:[]},{start:l,length:c}=this.prepareFindParameters(r,s);if(null==a){if(n=this.findAllIn([e],l,c),0==n.length)return o}else n=a;o.searchPatternPositions.push(...Array.from(n,e=>e.position));const u=e.length-t.length,h=new ArrayBuffer(this.view.length-n.length*u),m=new Uint8Array(h);for(m.set(new Uint8Array(this.buffer,0,l)),i=0;i<n.length;i++){const r=0==i?l:n[i-1].position;m.set(new Uint8Array(this.buffer,r,n[i].position-e.length-r),r-i*u),m.set(t.view,n[i].position-e.length-i*u),o.replacePatternPositions.push(n[i].position-e.length-i*u)}return i--,m.set(new Uint8Array(this.buffer,n[i].position,this.length-n[i].position),n[i].position-e.length+t.length-i*u),this.buffer=h,this.view=new Uint8Array(this.buffer),o.status=1,o}skipPatterns(e,t,r,s){const{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s);let o=a;for(let t=0;t<e.length;t++){const r=e[t].length,s=n?o-r:o;let l=!0;for(let a=0;a<r;a++)if(this.view[a+s]!=e[t].view[a]){l=!1;break}if(l)if(t=-1,n){if(o-=r,o<=0)return o}else if(o+=r,o>=a+i)return o}return o}skipNotPatterns(e,t,r,s){const{start:a,length:i,backward:n}=this.prepareFindParameters(t,r,s);let o=-1;for(let t=0;t<i;t++){for(let r=0;r<e.length;r++){const s=e[r].length,i=n?a-t-s:a+t;let l=!0;for(let t=0;t<s;t++)if(this.view[t+i]!=e[r].view[t]){l=!1;break}if(l){o=n?a-t:a+t;break}}if(-1!=o)break}return o}prepareFindParameters(e=null,t=null,r=!1){return null===e&&(e=r?this.length:0),e>this.length&&(e=this.length),r?(null===t&&(t=e),t>e&&(t=e)):(null===t&&(t=this.length-e),t>this.length-e&&(t=this.length-e)),{start:e,length:t,backward:r}}}class SeqStream{constructor(e={}){this._stream=new ByteStream,this._length=0,this._start=0,this.backward=!1,this.appendBlock=0,this.prevLength=0,this.prevStart=0,this.stream="view"in e?new ByteStream({view:e.view}):"buffer"in e?new ByteStream({buffer:e.buffer}):"string"in e?new ByteStream({string:e.string}):"hexstring"in e?new ByteStream({hexstring:e.hexstring}):"stream"in e?e.stream.slice():new ByteStream,"backward"in e&&e.backward&&(this.backward=e.backward,this._start=this.stream.length),"length"in e&&e.length>0&&(this._length=e.length),"start"in e&&e.start&&e.start>0&&(this._start=e.start),"appendBlock"in e&&e.appendBlock&&e.appendBlock>0&&(this.appendBlock=e.appendBlock)}set stream(e){this._stream=e,this.prevLength=this._length,this._length=e.length,this.prevStart=this._start,this._start=0}get stream(){return this._stream}set length(e){this.prevLength=this._length,this._length=e}get length(){return this.appendBlock?this.start:this._length}set start(e){e>this.stream.length||(this.prevStart=this._start,this.prevLength=this._length,this._length-=this.backward?this._start-e:e-this._start,this._start=e)}get start(){return this._start}get buffer(){return this._stream.buffer.slice(0,this._length)}resetPosition(){this._start=this.prevStart,this._length=this.prevLength}findPattern(e,t=null){(null==t||t>this.length)&&(t=this.length);const r=this.stream.findPattern(e,this.start,this.length,this.backward);if(-1==r)return r;if(this.backward){if(r<this.start-e.length-t)return-1}else if(r>this.start+e.length+t)return-1;return this.start=r,r}findFirstIn(e,t=null){(null==t||t>this.length)&&(t=this.length);const r=this.stream.findFirstIn(e,this.start,this.length,this.backward);if(-1==r.id)return r;if(this.backward){if(r.position<this.start-e[r.id].length-t)return{id:-1,position:this.backward?0:this.start+this.length}}else if(r.position>this.start+e[r.id].length+t)return{id:-1,position:this.backward?0:this.start+this.length};return this.start=r.position,r}findAllIn(e){const t=this.backward?this.start-this.length:this.start;return this.stream.findAllIn(e,t,this.length)}findFirstNotIn(e,t=null){(null==t||t>this._length)&&(t=this._length);const r=this._stream.findFirstNotIn(e,this._start,this._length,this.backward);if(-1==r.left.id&&-1==r.right.id)return r;if(this.backward){if(-1!=r.right.id&&r.right.position<this._start-e[r.right.id].length-t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new ByteStream}}else if(-1!=r.left.id&&r.left.position>this._start+e[r.left.id].length+t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new ByteStream};return this.backward?-1==r.left.id?this.start=0:this.start=r.left.position:-1==r.right.id?this.start=this._start+this._length:this.start=r.right.position,r}findAllNotIn(e){const t=this.backward?this._start-this._length:this._start;return this._stream.findAllNotIn(e,t,this._length)}findFirstSequence(e,t=null,r=null){(null==t||t>this._length)&&(t=this._length),(null==r||r>t)&&(r=t);const s=this._stream.findFirstSequence(e,this._start,t,this.backward);if(0==s.value.length)return s;if(this.backward){if(s.position<this._start-s.value.length-r)return{position:-1,value:new ByteStream}}else if(s.position>this._start+s.value.length+r)return{position:-1,value:new ByteStream};return this.start=s.position,s}findAllSequences(e){const t=this.backward?this.start-this.length:this.start;return this.stream.findAllSequences(e,t,this.length)}findPairedPatterns(e,t,r=null){(null==r||r>this.length)&&(r=this.length);const s=this.backward?this.start-this.length:this.start,a=this.stream.findPairedPatterns(e,t,s,this.length);if(a.length)if(this.backward){if(a[0].right<this.start-t.length-r)return[]}else if(a[0].left>this.start+e.length+r)return[];return a}findPairedArrays(e,t,r=null){(null==r||r>this.length)&&(r=this.length);const s=this.backward?this.start-this.length:this.start,a=this.stream.findPairedArrays(e,t,s,this.length);if(a.length)if(this.backward){if(a[0].right.position<this.start-t[a[0].right.id].length-r)return[]}else if(a[0].left.position>this.start+e[a[0].left.id].length+r)return[];return a}replacePattern(e,t){const r=this.backward?this.start-this.length:this.start;return this.stream.replacePattern(e,t,r,this.length)}skipPatterns(e){const t=this.stream.skipPatterns(e,this.start,this.length,this.backward);return this.start=t,t}skipNotPatterns(e){const t=this.stream.skipNotPatterns(e,this.start,this.length,this.backward);return-1==t?-1:(this.start=t,t)}append(e){this.beforeAppend(e.length),this._stream.view.set(e.view,this._start),this._length+=2*e.length,this.start=this._start+e.length,this.prevLength-=2*e.length}appendView(e){this.beforeAppend(e.length),this._stream.view.set(e,this._start),this._length+=2*e.length,this.start=this._start+e.length,this.prevLength-=2*e.length}appendChar(e){this.beforeAppend(1),this._stream.view[this._start]=e,this._length+=2,this.start=this._start+1,this.prevLength-=2}appendUint16(e){this.beforeAppend(2);const t=new Uint16Array([e]),r=new Uint8Array(t.buffer);this.stream.view[this._start]=r[1],this._stream.view[this._start+1]=r[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendUint24(e){this.beforeAppend(3);const t=new Uint32Array([e]),r=new Uint8Array(t.buffer);this._stream.view[this._start]=r[2],this._stream.view[this._start+1]=r[1],this._stream.view[this._start+2]=r[0],this._length+=6,this.start=this._start+3,this.prevLength-=6}appendUint32(e){this.beforeAppend(4);const t=new Uint32Array([e]),r=new Uint8Array(t.buffer);this._stream.view[this._start]=r[3],this._stream.view[this._start+1]=r[2],this._stream.view[this._start+2]=r[1],this._stream.view[this._start+3]=r[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}appendInt16(e){this.beforeAppend(2);const t=new Int16Array([e]),r=new Uint8Array(t.buffer);this._stream.view[this._start]=r[1],this._stream.view[this._start+1]=r[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendInt32(e){this.beforeAppend(4);const t=new Int32Array([e]),r=new Uint8Array(t.buffer);this._stream.view[this._start]=r[3],this._stream.view[this._start+1]=r[2],this._stream.view[this._start+2]=r[1],this._stream.view[this._start+3]=r[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}getBlock(e,t=!0){if(this._length<=0)return new Uint8Array(0);let r;if(this._length<e&&(e=this._length),this.backward){const t=this._stream.view.subarray(this._length-e,this._length);r=new Uint8Array(e);for(let s=0;s<e;s++)r[e-1-s]=t[s]}else r=this._stream.view.subarray(this._start,this._start+e);return t&&(this.start+=this.backward?-1*e:e),r}getUint16(e=!0){const t=this.getBlock(2,e);return t.length<2?0:t[0]<<8|t[1]}getInt16(e=!0){const t=this.getUint16(e),r=32768;return t&r?-(r-(t^r)):t}getUint24(e=!0){const t=this.getBlock(4,e);return t.length<3?0:t[0]<<16|t[1]<<8|t[2]}getUint32(e=!0){const t=this.getBlock(4,e);return t.length<4?0:16777216*t[0]+(t[1]<<16)+(t[2]<<8)+t[3]}getInt32(e=!0){const t=this.getUint32(e),r=2147483648;return t&r?-(r-(t^r)):t}beforeAppend(e){this._start+e>this._stream.length&&(e>this.appendBlock&&(this.appendBlock=e+SeqStream.APPEND_BLOCK),this._stream.realloc(this._stream.length+this.appendBlock))}}function abytes(e,...t){if(!((r=e)instanceof Uint8Array||ArrayBuffer.isView(r)&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var r;if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function aexists(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function clean(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function createView(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function rotr(e,t){return e<<32-t|e>>>t}function rotl(e,t){return e<<t|e>>>32-t>>>0}function toBytes(e){return"string"==typeof e&&(e=function(e){if("string"!=typeof e)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(e))}(e)),abytes(e),e}SeqStream.APPEND_BLOCK=1e3;class Hash{}function createHasher(e){const hashC=t=>e().update(toBytes(t)).digest(),t=e();return hashC.outputLen=t.outputLen,hashC.blockLen=t.blockLen,hashC.create=()=>e(),hashC}function Chi(e,t,r){return e&t^~e&r}function Maj(e,t,r){return e&t^e&r^t&r}class HashMD extends Hash{constructor(e,t,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(e),this.view=createView(this.buffer)}update(e){aexists(this),abytes(e=toBytes(e));const{view:t,buffer:r,blockLen:s}=this,a=e.length;for(let i=0;i<a;){const n=Math.min(s-this.pos,a-i);if(n===s){const t=createView(e);for(;s<=a-i;i+=s)this.process(t,i);continue}r.set(e.subarray(i,i+n),this.pos),this.pos+=n,i+=n,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){aexists(this),function(e,t){abytes(e);const r=t.outputLen;if(e.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:a}=this;let{pos:i}=this;t[i++]=128,clean(this.buffer.subarray(i)),this.padOffset>s-i&&(this.process(r,0),i=0);for(let e=i;e<s;e++)t[e]=0;!function(e,t,r,s){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,s);const a=BigInt(32),i=BigInt(4294967295),n=Number(r>>a&i),o=Number(r&i),l=s?4:0,c=s?0:4;e.setUint32(t+l,n,s),e.setUint32(t+c,o,s)}(r,s-8,BigInt(8*this.length),a),this.process(r,0);const n=createView(e),o=this.outputLen;if(o%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=o/4,c=this.get();if(l>c.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<l;e++)n.setUint32(4*e,c[e],a)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:a,destroyed:i,pos:n}=this;return e.destroyed=i,e.finished=a,e.length=s,e.pos=n,s%t&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const te=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),re=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),se=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),ae=Uint32Array.from([1732584193,4023233417,2562383102,271733878,3285377520]),ie=new Uint32Array(80);let ne=class extends HashMD{constructor(){super(64,20,8,!1),this.A=0|ae[0],this.B=0|ae[1],this.C=0|ae[2],this.D=0|ae[3],this.E=0|ae[4]}get(){const{A:e,B:t,C:r,D:s,E:a}=this;return[e,t,r,s,a]}set(e,t,r,s,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|s,this.E=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)ie[r]=e.getUint32(t,!1);for(let e=16;e<80;e++)ie[e]=rotl(ie[e-3]^ie[e-8]^ie[e-14]^ie[e-16],1);let{A:r,B:s,C:a,D:i,E:n}=this;for(let e=0;e<80;e++){let t,o;e<20?(t=Chi(s,a,i),o=1518500249):e<40?(t=s^a^i,o=1859775393):e<60?(t=Maj(s,a,i),o=2400959708):(t=s^a^i,o=3395469782);const l=rotl(r,5)+t+n+o+ie[e]|0;n=i,i=a,a=rotl(s,30),s=r,r=l}r=r+this.A|0,s=s+this.B|0,a=a+this.C|0,i=i+this.D|0,n=n+this.E|0,this.set(r,s,a,i,n)}roundClean(){clean(ie)}destroy(){this.set(0,0,0,0,0),clean(this.buffer)}};const oe=createHasher(()=>new ne),le=BigInt(2**32-1),ce=BigInt(32);function fromBig(e,t=!1){return t?{h:Number(e&le),l:Number(e>>ce&le)}:{h:0|Number(e>>ce&le),l:0|Number(e&le)}}const shrSH=(e,t,r)=>e>>>r,shrSL=(e,t,r)=>e<<32-r|t>>>r,rotrSH=(e,t,r)=>e>>>r|t<<32-r,rotrSL=(e,t,r)=>e<<32-r|t>>>r,rotrBH=(e,t,r)=>e<<64-r|t>>>r-32,rotrBL=(e,t,r)=>e>>>r-32|t<<64-r;function add(e,t,r,s){const a=(t>>>0)+(s>>>0);return{h:e+r+(a/2**32|0)|0,l:0|a}}const add3L=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),add3H=(e,t,r,s)=>t+r+s+(e/2**32|0)|0,add4L=(e,t,r,s)=>(e>>>0)+(t>>>0)+(r>>>0)+(s>>>0),add4H=(e,t,r,s,a)=>t+r+s+a+(e/2**32|0)|0,add5L=(e,t,r,s,a)=>(e>>>0)+(t>>>0)+(r>>>0)+(s>>>0)+(a>>>0),add5H=(e,t,r,s,a,i)=>t+r+s+a+i+(e/2**32|0)|0,ue=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),he=new Uint32Array(64);let me=class extends HashMD{constructor(e=32){super(64,e,8,!1),this.A=0|te[0],this.B=0|te[1],this.C=0|te[2],this.D=0|te[3],this.E=0|te[4],this.F=0|te[5],this.G=0|te[6],this.H=0|te[7]}get(){const{A:e,B:t,C:r,D:s,E:a,F:i,G:n,H:o}=this;return[e,t,r,s,a,i,n,o]}set(e,t,r,s,a,i,n,o){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|s,this.E=0|a,this.F=0|i,this.G=0|n,this.H=0|o}process(e,t){for(let r=0;r<16;r++,t+=4)he[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=he[e-15],r=he[e-2],s=rotr(t,7)^rotr(t,18)^t>>>3,a=rotr(r,17)^rotr(r,19)^r>>>10;he[e]=a+he[e-7]+s+he[e-16]|0}let{A:r,B:s,C:a,D:i,E:n,F:o,G:l,H:c}=this;for(let e=0;e<64;e++){const t=c+(rotr(n,6)^rotr(n,11)^rotr(n,25))+Chi(n,o,l)+ue[e]+he[e]|0,u=(rotr(r,2)^rotr(r,13)^rotr(r,22))+Maj(r,s,a)|0;c=l,l=o,o=n,n=i+t|0,i=a,a=s,s=r,r=t+u|0}r=r+this.A|0,s=s+this.B|0,a=a+this.C|0,i=i+this.D|0,n=n+this.E|0,o=o+this.F|0,l=l+this.G|0,c=c+this.H|0,this.set(r,s,a,i,n,o,l,c)}roundClean(){clean(he)}destroy(){this.set(0,0,0,0,0,0,0,0),clean(this.buffer)}};const fe=(()=>function(e,t=!1){const r=e.length;let s=new Uint32Array(r),a=new Uint32Array(r);for(let i=0;i<r;i++){const{h:r,l:n}=fromBig(e[i],t);[s[i],a[i]]=[r,n]}return[s,a]}(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))))(),ge=(()=>fe[0])(),de=(()=>fe[1])(),pe=new Uint32Array(80),Se=new Uint32Array(80);let ye=class extends HashMD{constructor(e=64){super(128,e,16,!1),this.Ah=0|se[0],this.Al=0|se[1],this.Bh=0|se[2],this.Bl=0|se[3],this.Ch=0|se[4],this.Cl=0|se[5],this.Dh=0|se[6],this.Dl=0|se[7],this.Eh=0|se[8],this.El=0|se[9],this.Fh=0|se[10],this.Fl=0|se[11],this.Gh=0|se[12],this.Gl=0|se[13],this.Hh=0|se[14],this.Hl=0|se[15]}get(){const{Ah:e,Al:t,Bh:r,Bl:s,Ch:a,Cl:i,Dh:n,Dl:o,Eh:l,El:c,Fh:u,Fl:h,Gh:m,Gl:f,Hh:g,Hl:d}=this;return[e,t,r,s,a,i,n,o,l,c,u,h,m,f,g,d]}set(e,t,r,s,a,i,n,o,l,c,u,h,m,f,g,d){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|s,this.Ch=0|a,this.Cl=0|i,this.Dh=0|n,this.Dl=0|o,this.Eh=0|l,this.El=0|c,this.Fh=0|u,this.Fl=0|h,this.Gh=0|m,this.Gl=0|f,this.Hh=0|g,this.Hl=0|d}process(e,t){for(let r=0;r<16;r++,t+=4)pe[r]=e.getUint32(t),Se[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|pe[e-15],r=0|Se[e-15],s=rotrSH(t,r,1)^rotrSH(t,r,8)^shrSH(t,0,7),a=rotrSL(t,r,1)^rotrSL(t,r,8)^shrSL(t,r,7),i=0|pe[e-2],n=0|Se[e-2],o=rotrSH(i,n,19)^rotrBH(i,n,61)^shrSH(i,0,6),l=rotrSL(i,n,19)^rotrBL(i,n,61)^shrSL(i,n,6),c=add4L(a,l,Se[e-7],Se[e-16]),u=add4H(c,s,o,pe[e-7],pe[e-16]);pe[e]=0|u,Se[e]=0|c}let{Ah:r,Al:s,Bh:a,Bl:i,Ch:n,Cl:o,Dh:l,Dl:c,Eh:u,El:h,Fh:m,Fl:f,Gh:g,Gl:d,Hh:p,Hl:S}=this;for(let e=0;e<80;e++){const t=rotrSH(u,h,14)^rotrSH(u,h,18)^rotrBH(u,h,41),y=rotrSL(u,h,14)^rotrSL(u,h,18)^rotrBL(u,h,41),w=u&m^~u&g,v=add5L(S,y,h&f^~h&d,de[e],Se[e]),b=add5H(v,p,t,w,ge[e],pe[e]),A=0|v,k=rotrSH(r,s,28)^rotrBH(r,s,34)^rotrBH(r,s,39),C=rotrSL(r,s,28)^rotrBL(r,s,34)^rotrBL(r,s,39),V=r&a^r&n^a&n,B=s&i^s&o^i&o;p=0|g,S=0|d,g=0|m,d=0|f,m=0|u,f=0|h,({h:u,l:h}=add(0|l,0|c,0|b,0|A)),l=0|n,c=0|o,n=0|a,o=0|i,a=0|r,i=0|s;const I=add3L(A,C,B);r=add3H(I,b,k,V),s=0|I}({h:r,l:s}=add(0|this.Ah,0|this.Al,0|r,0|s)),({h:a,l:i}=add(0|this.Bh,0|this.Bl,0|a,0|i)),({h:n,l:o}=add(0|this.Ch,0|this.Cl,0|n,0|o)),({h:l,l:c}=add(0|this.Dh,0|this.Dl,0|l,0|c)),({h:u,l:h}=add(0|this.Eh,0|this.El,0|u,0|h)),({h:m,l:f}=add(0|this.Fh,0|this.Fl,0|m,0|f)),({h:g,l:d}=add(0|this.Gh,0|this.Gl,0|g,0|d)),({h:p,l:S}=add(0|this.Hh,0|this.Hl,0|p,0|S)),this.set(r,s,a,i,n,o,l,c,u,h,m,f,g,d,p,S)}roundClean(){clean(pe,Se)}destroy(){clean(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}},we=class extends ye{constructor(){super(48),this.Ah=0|re[0],this.Al=0|re[1],this.Bh=0|re[2],this.Bl=0|re[3],this.Ch=0|re[4],this.Cl=0|re[5],this.Dh=0|re[6],this.Dl=0|re[7],this.Eh=0|re[8],this.El=0|re[9],this.Fh=0|re[10],this.Fl=0|re[11],this.Gh=0|re[12],this.Gl=0|re[13],this.Hh=0|re[14],this.Hl=0|re[15]}};const ve=createHasher(()=>new me),be=createHasher(()=>new ye),Ae=createHasher(()=>new we),ke=new ArrayBuffer(0),Ce="";class ArgumentError extends TypeError{constructor(){super(...arguments),this.name=ArgumentError.NAME}static isType(e,t){if("string"==typeof t){if("Array"===t&&Array.isArray(e))return!0;if("ArrayBuffer"===t&&e instanceof ArrayBuffer)return!0;if("ArrayBufferView"===t&&ArrayBuffer.isView(e))return!0;if(typeof e===t)return!0}else if(e instanceof t)return!0;return!1}static assert(e,t,...r){for(const t of r)if(this.isType(e,t))return;const s=r.map(e=>e instanceof Function&&"name"in e?e.name:`${e}`);throw new ArgumentError(`Parameter '${t}' is not of type ${s.length>1?`(${s.join(" or ")})`:s[0]}`)}}ArgumentError.NAME="ArgumentError";class ParameterError extends TypeError{static assert(...e){let t,r,s=null;"string"==typeof e[0]?(s=e[0],t=e[1],r=e.slice(2)):(t=e[0],r=e.slice(1)),ArgumentError.assert(t,"parameters","object");for(const e of r){const r=t[e];if(null==r)throw new ParameterError(e,s)}}static assertEmpty(e,t,r){if(null==e)throw new ParameterError(t,r)}constructor(e,t=null,r){super(),this.name=ParameterError.NAME,this.field=e,t&&(this.target=t),this.message=r||`Absent mandatory parameter '${e}' ${t?` in '${t}'`:Ce}`}}ParameterError.NAME="ParameterError";class AsnError extends Error{static assertSchema(e,t){if(!e.verified)throw new Error(`Object's schema was not verified against input data for ${t}`)}static assert(e,t){if(-1===e.offset)throw new AsnError(`Error during parsing of ASN.1 data. Data is not correct for '${t}'.`)}constructor(e){super(e),this.name="AsnError"}}class PkiObject{static blockName(){return this.CLASS_NAME}static fromBER(e){const t=fromBER(e);AsnError.assert(t,this.name);try{return new this({schema:t.result})}catch(e){throw new AsnError(`Cannot create '${this.CLASS_NAME}' from ASN.1 object`)}}static defaultValues(e){throw new Error(`Invalid member name for ${this.CLASS_NAME} class: ${e}`)}static schema(e={}){throw new Error(`Method '${this.CLASS_NAME}.schema' should be overridden`)}get className(){return this.constructor.CLASS_NAME}toString(e="hex"){let t;try{t=this.toSchema()}catch{t=this.toSchema(!0)}return Convert.ToString(t.toBER(),e)}}function stringPrep(e){let t=!1,r=Ce;const s=e.trim();for(let e=0;e<s.length;e++)32===s.charCodeAt(e)?!1===t&&(t=!0):(t&&(r+=" ",t=!1),r+=s[e]);return r.toLowerCase()}PkiObject.CLASS_NAME="PkiObject";const Ve="type",Be="value";class AttributeTypeAndValue extends PkiObject{constructor(e={}){super(),this.type=getParametersValue(e,Ve,AttributeTypeAndValue.defaultValues(Ve)),this.value=getParametersValue(e,Be,AttributeTypeAndValue.defaultValues(Be)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ve:return Ce;case Be:return{};default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.type||Ce}),new Any({name:t.value||Ce})]})}fromSchema(e){clearProps(e,[Ve,"typeValue"]);const t=compareSchema(e,e,AttributeTypeAndValue.schema({names:{type:Ve,value:"typeValue"}}));AsnError.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.type}),this.value]})}toJSON(){const e={type:this.type};return 0!==Object.keys(this.value).length?e.value=this.value.toJSON():e.value=this.value,e}isEqual(e){const t=[Utf8String.blockName(),BmpString.blockName(),UniversalString.blockName(),NumericString.blockName(),PrintableString.blockName(),TeletexString.blockName(),VideotexString.blockName(),IA5String.blockName(),GraphicString.blockName(),VisibleString.blockName(),GeneralString.blockName(),CharacterString.blockName()];if(e instanceof ArrayBuffer)return BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView,e);if(e.constructor.blockName()===AttributeTypeAndValue.blockName()){if(this.type!==e.type)return!1;const r=[!1,!1],s=this.value.constructor.blockName();for(const a of t)s===a&&(r[0]=!0),e.value.constructor.blockName()===a&&(r[1]=!0);if(r[0]!==r[1])return!1;if(r[0]&&r[1]){const t=stringPrep(this.value.valueBlock.value),r=stringPrep(e.value.valueBlock.value);if(0!==t.localeCompare(r))return!1}else if(!BufferSourceConverter.isEqual(this.value.valueBeforeDecodeView,e.value.valueBeforeDecodeView))return!1;return!0}return!1}}AttributeTypeAndValue.CLASS_NAME="AttributeTypeAndValue";const Ie="typesAndValues",Ne="valueBeforeDecode";class RelativeDistinguishedNames extends PkiObject{constructor(e={}){super(),this.typesAndValues=getParametersValue(e,Ie,RelativeDistinguishedNames.defaultValues(Ie)),this.valueBeforeDecode=getParametersValue(e,Ne,RelativeDistinguishedNames.defaultValues(Ne)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ie:return[];case Ne:return ke;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ie:return 0===t.length;case Ne:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.repeatedSequence||Ce,value:new Set({value:[new Repeated({name:t.repeatedSet||Ce,value:AttributeTypeAndValue.schema(t.typeAndValue||{})})]})})]})}fromSchema(e){clearProps(e,["RDN",Ie]);const t=compareSchema(e,e,RelativeDistinguishedNames.schema({names:{blockName:"RDN",repeatedSet:Ie}}));AsnError.assertSchema(t,this.className),Ie in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,e=>new AttributeTypeAndValue({schema:e}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecodeView.slice().buffer}toSchema(){if(0===this.valueBeforeDecode.byteLength)return new Sequence({value:[new Set({value:Array.from(this.typesAndValues,e=>e.toSchema())})]});const e=fromBER(this.valueBeforeDecode);if(AsnError.assert(e,"RelativeDistinguishedNames"),!(e.result instanceof Sequence))throw new Error("ASN.1 result should be SEQUENCE");return e.result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof RelativeDistinguishedNames){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(const[t,r]of this.typesAndValues.entries())if(!1===r.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&isEqualBuffer(this.valueBeforeDecode,e)}}RelativeDistinguishedNames.CLASS_NAME="RelativeDistinguishedNames";const Pe="type",Ee="value";function builtInStandardAttributes(e={},t=!1){const r=getParametersValue(e,"names",{});return new Sequence({optional:t,value:[new Constructed({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:r.country_name||Ce,value:[new Choice({value:[new NumericString,new PrintableString]})]}),new Constructed({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:r.administration_domain_name||Ce,value:[new Choice({value:[new NumericString,new PrintableString]})]}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:r.network_address||Ce,isHexOnly:!0}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:r.terminal_identifier||Ce,isHexOnly:!0}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:r.private_domain_name||Ce,value:[new Choice({value:[new NumericString,new PrintableString]})]}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:r.organization_name||Ce,isHexOnly:!0}),new Primitive({optional:!0,name:r.numeric_user_identifier||Ce,idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new Constructed({optional:!0,name:r.personal_name||Ce,idBlock:{tagClass:3,tagNumber:5},value:[new Primitive({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new Constructed({optional:!0,name:r.organizational_unit_names||Ce,idBlock:{tagClass:3,tagNumber:6},value:[new Repeated({value:new PrintableString})]})]})}function builtInDomainDefinedAttributes(e=!1){return new Sequence({optional:e,value:[new PrintableString,new PrintableString]})}function extensionAttributes(e=!1){return new Set({optional:e,value:[new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Any]})]})}class GeneralName extends PkiObject{constructor(e={}){super(),this.type=getParametersValue(e,Pe,GeneralName.defaultValues(Pe)),this.value=getParametersValue(e,Ee,GeneralName.defaultValues(Ee)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Pe:return 9;case Ee:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Pe:return t===GeneralName.defaultValues(e);case Ee:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Choice({value:[new Constructed({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||Ce,value:[new ObjectIdentifier,new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any]})]}),new Primitive({name:t.blockName||Ce,idBlock:{tagClass:3,tagNumber:1}}),new Primitive({name:t.blockName||Ce,idBlock:{tagClass:3,tagNumber:2}}),new Constructed({idBlock:{tagClass:3,tagNumber:3},name:t.blockName||Ce,value:[builtInStandardAttributes(t.builtInStandardAttributes||{},!1),builtInDomainDefinedAttributes(!0),extensionAttributes(!0)]}),new Constructed({idBlock:{tagClass:3,tagNumber:4},name:t.blockName||Ce,value:[RelativeDistinguishedNames.schema(t.directoryName||{})]}),new Constructed({idBlock:{tagClass:3,tagNumber:5},name:t.blockName||Ce,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Choice({value:[new TeletexString,new PrintableString,new UniversalString,new Utf8String,new BmpString]})]}),new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new Choice({value:[new TeletexString,new PrintableString,new UniversalString,new Utf8String,new BmpString]})]})]}),new Primitive({name:t.blockName||Ce,idBlock:{tagClass:3,tagNumber:6}}),new Primitive({name:t.blockName||Ce,idBlock:{tagClass:3,tagNumber:7}}),new Primitive({name:t.blockName||Ce,idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){clearProps(e,["blockName","otherName","rfc822Name","dNSName","x400Address","directoryName","ediPartyName","uniformResourceIdentifier","iPAddress","registeredID"]);const t=compareSchema(e,e,GeneralName.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));switch(AsnError.assertSchema(t,this.className),this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:case 3:this.value=t.result.blockName;break;case 1:case 2:case 6:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;const r=fromBER(e.toBER(!1));AsnError.assert(r,"GeneralName value"),this.value=r.result.valueBlock.value}break;case 4:this.value=new RelativeDistinguishedNames({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new OctetString({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;const r=fromBER(e.toBER(!1));AsnError.assert(r,"GeneralName registeredID"),this.value=r.result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new Constructed({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{const e=new IA5String({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new Constructed({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{const e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{const e=new ObjectIdentifier({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return GeneralName.schema()}}toJSON(){const e={type:this.type,value:Ce};if("string"==typeof this.value)e.value=this.value;else try{e.value=this.value.toJSON()}catch(e){}return e}}GeneralName.CLASS_NAME="GeneralName";const De="accessMethod",Oe="accessLocation",xe=[De,Oe];class AccessDescription extends PkiObject{constructor(e={}){super(),this.accessMethod=getParametersValue(e,De,AccessDescription.defaultValues(De)),this.accessLocation=getParametersValue(e,Oe,AccessDescription.defaultValues(Oe)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case De:return Ce;case Oe:return new GeneralName;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.accessMethod||Ce}),GeneralName.schema(t.accessLocation||{})]})}fromSchema(e){clearProps(e,xe);const t=compareSchema(e,e,AccessDescription.schema({names:{accessMethod:De,accessLocation:{names:{blockName:Oe}}}}));AsnError.assertSchema(t,this.className),this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new GeneralName({schema:t.result.accessLocation})}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}AccessDescription.CLASS_NAME="AccessDescription";const Re="seconds",Ke="millis",Ue="micros";class Accuracy extends PkiObject{constructor(e={}){super(),Re in e&&(this.seconds=getParametersValue(e,Re,Accuracy.defaultValues(Re))),Ke in e&&(this.millis=getParametersValue(e,Ke,Accuracy.defaultValues(Ke))),Ue in e&&(this.micros=getParametersValue(e,Ue,Accuracy.defaultValues(Ue))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Re:case Ke:case Ue:return 0;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Re:case Ke:case Ue:return t===Accuracy.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,optional:!0,value:[new Integer({optional:!0,name:t.seconds||Ce}),new Primitive({name:t.millis||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new Primitive({name:t.micros||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){clearProps(e,[Re,Ke,Ue]);const t=compareSchema(e,e,Accuracy.schema({names:{seconds:Re,millis:Ke,micros:Ue}}));if(AsnError.assertSchema(t,this.className),"seconds"in t.result&&(this.seconds=t.result.seconds.valueBlock.valueDec),"millis"in t.result){const e=new Integer({valueHex:t.result.millis.valueBlock.valueHex});this.millis=e.valueBlock.valueDec}if("micros"in t.result){const e=new Integer({valueHex:t.result.micros.valueBlock.valueHex});this.micros=e.valueBlock.valueDec}}toSchema(){const e=[];if(void 0!==this.seconds&&e.push(new Integer({value:this.seconds})),void 0!==this.millis){const t=new Integer({value:this.millis});e.push(new Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:t.valueBlock.valueHexView}))}if(void 0!==this.micros){const t=new Integer({value:this.micros});e.push(new Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:t.valueBlock.valueHexView}))}return new Sequence({value:e})}toJSON(){const e={};return void 0!==this.seconds&&(e.seconds=this.seconds),void 0!==this.millis&&(e.millis=this.millis),void 0!==this.micros&&(e.micros=this.micros),e}}Accuracy.CLASS_NAME="Accuracy";const Te="algorithmId",Le="algorithmParams",He="algorithm",qe="params",je=[He,qe];class AlgorithmIdentifier extends PkiObject{constructor(e={}){super(),this.algorithmId=getParametersValue(e,Te,AlgorithmIdentifier.defaultValues(Te)),Le in e&&(this.algorithmParams=getParametersValue(e,Le,AlgorithmIdentifier.defaultValues(Le))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Te:return Ce;case Le:return new Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Te:return t===Ce;case Le:return t instanceof Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,optional:t.optional||!1,value:[new ObjectIdentifier({name:t.algorithmIdentifier||Ce}),new Any({name:t.algorithmParams||Ce,optional:!0})]})}fromSchema(e){clearProps(e,je);const t=compareSchema(e,e,AlgorithmIdentifier.schema({names:{algorithmIdentifier:He,algorithmParams:qe}}));AsnError.assertSchema(t,this.className),this.algorithmId=t.result.algorithm.valueBlock.toString(),qe in t.result&&(this.algorithmParams=t.result.params)}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.algorithmId})),!this.algorithmParams||this.algorithmParams instanceof Any||e.push(this.algorithmParams),new Sequence({value:e})}toJSON(){const e={algorithmId:this.algorithmId};return!this.algorithmParams||this.algorithmParams instanceof Any||(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof AlgorithmIdentifier&&(this.algorithmId===e.algorithmId&&(this.algorithmParams?!!e.algorithmParams&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!e.algorithmParams))}}AlgorithmIdentifier.CLASS_NAME="AlgorithmIdentifier";const Me="altNames",Je=[Me];class AltName extends PkiObject{constructor(e={}){super(),this.altNames=getParametersValue(e,Me,AltName.defaultValues(Me)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Me?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.altNames||Ce,value:GeneralName.schema()})]})}fromSchema(e){clearProps(e,Je);const t=compareSchema(e,e,AltName.schema({names:{altNames:Me}}));AsnError.assertSchema(t,this.className),Me in t.result&&(this.altNames=Array.from(t.result.altNames,e=>new GeneralName({schema:e})))}toSchema(){return new Sequence({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}}AltName.CLASS_NAME="AltName";const _e="type",Fe="values",$e=[_e,Fe];class Attribute extends PkiObject{constructor(e={}){super(),this.type=getParametersValue(e,_e,Attribute.defaultValues(_e)),this.values=getParametersValue(e,Fe,Attribute.defaultValues(Fe)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case _e:return Ce;case Fe:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case _e:return t===Ce;case Fe:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.type||Ce}),new Set({name:t.setName||Ce,value:[new Repeated({name:t.values||Ce,value:new Any})]})]})}fromSchema(e){clearProps(e,$e);const t=compareSchema(e,e,Attribute.schema({names:{type:_e,values:Fe}}));AsnError.assertSchema(t,this.className),this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.type}),new Set({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}}Attribute.CLASS_NAME="Attribute";const We="notBeforeTime",Ge="notAfterTime",ze=[We,Ge];class AttCertValidityPeriod extends PkiObject{constructor(e={}){super(),this.notBeforeTime=getParametersValue(e,We,AttCertValidityPeriod.defaultValues(We)),this.notAfterTime=getParametersValue(e,Ge,AttCertValidityPeriod.defaultValues(Ge)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case We:case Ge:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new GeneralizedTime({name:t.notBeforeTime||Ce}),new GeneralizedTime({name:t.notAfterTime||Ce})]})}fromSchema(e){clearProps(e,ze);const t=compareSchema(e,e,AttCertValidityPeriod.schema({names:{notBeforeTime:We,notAfterTime:Ge}}));AsnError.assertSchema(t,this.className),this.notBeforeTime=t.result.notBeforeTime.toDate(),this.notAfterTime=t.result.notAfterTime.toDate()}toSchema(){return new Sequence({value:[new GeneralizedTime({valueDate:this.notBeforeTime}),new GeneralizedTime({valueDate:this.notAfterTime})]})}toJSON(){return{notBeforeTime:this.notBeforeTime,notAfterTime:this.notAfterTime}}}AttCertValidityPeriod.CLASS_NAME="AttCertValidityPeriod";const Qe="names",Ze="generalNames";class GeneralNames extends PkiObject{constructor(e={}){super(),this.names=getParametersValue(e,Qe,GeneralNames.defaultValues(Qe)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return"names"===e?[]:super.defaultValues(e)}static schema(e={},t=!1){const r=getParametersValue(e,Qe,{});return new Sequence({optional:t,name:r.blockName||Ce,value:[new Repeated({name:r.generalNames||Ce,value:GeneralName.schema()})]})}fromSchema(e){clearProps(e,[Qe,Ze]);const t=compareSchema(e,e,GeneralNames.schema({names:{blockName:Qe,generalNames:Ze}}));AsnError.assertSchema(t,this.className),this.names=Array.from(t.result.generalNames,e=>new GeneralName({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}}GeneralNames.CLASS_NAME="GeneralNames";const Ye="2.5.29.17",Xe="2.5.29.18",et="2.5.29.19",tt="2.5.29.28",rt="2.5.29.29",st="2.5.29.30",at="2.5.29.31",it="2.5.29.46",nt="2.5.29.32",ot="2.5.29.32.0",lt="2.5.29.33",ct="2.5.29.35",ut="2.5.29.36",ht="1.3.6.1.5.5.7.1.1",mt="1.2.840.113549.1.7.1",ft="1.2.840.113549.1.7.2",gt="1.2.840.113549.1.7.3",dt="1.2.840.113549.1.7.6",pt="1.2.840.113549.1.9.22.1",St="1.2.840.113549.1.9.22.3",yt="1.2.840.113549.1.9.23.1",wt="1.3.6.1.5.5.7.48.1.1",vt="keyIdentifier",bt="authorityCertIssuer",At="authorityCertSerialNumber",kt=[vt,bt,At];class AuthorityKeyIdentifier extends PkiObject{constructor(e={}){super(),vt in e&&(this.keyIdentifier=getParametersValue(e,vt,AuthorityKeyIdentifier.defaultValues(vt))),bt in e&&(this.authorityCertIssuer=getParametersValue(e,bt,AuthorityKeyIdentifier.defaultValues(bt))),At in e&&(this.authorityCertSerialNumber=getParametersValue(e,At,AuthorityKeyIdentifier.defaultValues(At))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case vt:return new OctetString;case bt:return[];case At:return new Integer;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Primitive({name:t.keyIdentifier||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Repeated({name:t.authorityCertIssuer||Ce,value:GeneralName.schema()})]}),new Primitive({name:t.authorityCertSerialNumber||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){clearProps(e,kt);const t=compareSchema(e,e,AuthorityKeyIdentifier.schema({names:{keyIdentifier:vt,authorityCertIssuer:bt,authorityCertSerialNumber:At}}));AsnError.assertSchema(t,this.className),vt in t.result&&(this.keyIdentifier=new OctetString({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),bt in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,e=>new GeneralName({schema:e}))),At in t.result&&(this.authorityCertSerialNumber=new Integer({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){const e=[];return this.keyIdentifier&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.keyIdentifier.valueBlock.valueHexView})),this.authorityCertIssuer&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,e=>e.toSchema())})),this.authorityCertSerialNumber&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:2},valueHex:this.authorityCertSerialNumber.valueBlock.valueHexView})),new Sequence({value:e})}toJSON(){const e={};return this.keyIdentifier&&(e.keyIdentifier=this.keyIdentifier.toJSON()),this.authorityCertIssuer&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,e=>e.toJSON())),this.authorityCertSerialNumber&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}AuthorityKeyIdentifier.CLASS_NAME="AuthorityKeyIdentifier";const Ct="pathLenConstraint",Vt="cA";class BasicConstraints extends PkiObject{constructor(e={}){super(),this.cA=getParametersValue(e,Vt,!1),Ct in e&&(this.pathLenConstraint=getParametersValue(e,Ct,0)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e!==Vt&&super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Boolean({optional:!0,name:t.cA||Ce}),new Integer({optional:!0,name:t.pathLenConstraint||Ce})]})}fromSchema(e){clearProps(e,[Vt,Ct]);const t=compareSchema(e,e,BasicConstraints.schema({names:{cA:Vt,pathLenConstraint:Ct}}));AsnError.assertSchema(t,this.className),Vt in t.result&&(this.cA=t.result.cA.valueBlock.value),Ct in t.result&&(t.result.pathLenConstraint.valueBlock.isHexOnly?this.pathLenConstraint=t.result.pathLenConstraint:this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){const e=[];return this.cA!==BasicConstraints.defaultValues(Vt)&&e.push(new Boolean({value:this.cA})),Ct in this&&(this.pathLenConstraint instanceof Integer?e.push(this.pathLenConstraint):e.push(new Integer({value:this.pathLenConstraint}))),new Sequence({value:e})}toJSON(){const e={};return this.cA!==BasicConstraints.defaultValues(Vt)&&(e.cA=this.cA),Ct in this&&(this.pathLenConstraint instanceof Integer?e.pathLenConstraint=this.pathLenConstraint.toJSON():e.pathLenConstraint=this.pathLenConstraint),e}}BasicConstraints.CLASS_NAME="BasicConstraints";const Bt="certificateIndex",It="keyIndex";class CAVersion extends PkiObject{constructor(e={}){super(),this.certificateIndex=getParametersValue(e,Bt,CAVersion.defaultValues(Bt)),this.keyIndex=getParametersValue(e,It,CAVersion.defaultValues(It)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Bt:case It:return 0;default:return super.defaultValues(e)}}static schema(){return new Integer}fromSchema(e){if(e.constructor.blockName()!==Integer.blockName())throw new Error("Object's schema was not verified against input data for CAVersion");let t=e.valueBlock.valueHex.slice(0);const r=new Uint8Array(t);switch(!0){case t.byteLength<4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(r,4-t.byteLength),t=e.slice(0)}break;case t.byteLength>4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(r.slice(0,4)),t=e.slice(0)}}const s=t.slice(0,2),a=new Uint8Array(s);let i=a[0];a[0]=a[1],a[1]=i;const n=new Uint16Array(s);this.keyIndex=n[0];const o=t.slice(2),l=new Uint8Array(o);i=l[0],l[0]=l[1],l[1]=i;const c=new Uint16Array(o);this.certificateIndex=c[0]}toSchema(){const e=new ArrayBuffer(2);new Uint16Array(e)[0]=this.certificateIndex;const t=new Uint8Array(e);let r=t[0];t[0]=t[1],t[1]=r;const s=new ArrayBuffer(2);new Uint16Array(s)[0]=this.keyIndex;const a=new Uint8Array(s);return r=a[0],a[0]=a[1],a[1]=r,new Integer({valueHex:utilConcatBuf(s,e)})}toJSON(){return{certificateIndex:this.certificateIndex,keyIndex:this.keyIndex}}}CAVersion.CLASS_NAME="CAVersion";const Nt="policyQualifierId",Pt="qualifier",Et=[Nt,Pt];class PolicyQualifierInfo extends PkiObject{constructor(e={}){super(),this.policyQualifierId=getParametersValue(e,Nt,PolicyQualifierInfo.defaultValues(Nt)),this.qualifier=getParametersValue(e,Pt,PolicyQualifierInfo.defaultValues(Pt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Nt:return Ce;case Pt:return new Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.policyQualifierId||Ce}),new Any({name:t.qualifier||Ce})]})}fromSchema(e){clearProps(e,Et);const t=compareSchema(e,e,PolicyQualifierInfo.schema({names:{policyQualifierId:Nt,qualifier:Pt}}));AsnError.assertSchema(t,this.className),this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}PolicyQualifierInfo.CLASS_NAME="PolicyQualifierInfo";const Dt="policyIdentifier",Ot="policyQualifiers",xt=[Dt,Ot];class PolicyInformation extends PkiObject{constructor(e={}){super(),this.policyIdentifier=getParametersValue(e,Dt,PolicyInformation.defaultValues(Dt)),Ot in e&&(this.policyQualifiers=getParametersValue(e,Ot,PolicyInformation.defaultValues(Ot))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Dt:return Ce;case Ot:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.policyIdentifier||Ce}),new Sequence({optional:!0,value:[new Repeated({name:t.policyQualifiers||Ce,value:PolicyQualifierInfo.schema()})]})]})}fromSchema(e){clearProps(e,xt);const t=compareSchema(e,e,PolicyInformation.schema({names:{policyIdentifier:Dt,policyQualifiers:Ot}}));AsnError.assertSchema(t,this.className),this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),Ot in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,e=>new PolicyQualifierInfo({schema:e})))}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.policyIdentifier})),this.policyQualifiers&&e.push(new Sequence({value:Array.from(this.policyQualifiers,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={policyIdentifier:this.policyIdentifier};return this.policyQualifiers&&(e.policyQualifiers=Array.from(this.policyQualifiers,e=>e.toJSON())),e}}PolicyInformation.CLASS_NAME="PolicyInformation";const Rt="certificatePolicies",Kt=[Rt];class CertificatePolicies extends PkiObject{constructor(e={}){super(),this.certificatePolicies=getParametersValue(e,Rt,CertificatePolicies.defaultValues(Rt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Rt?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.certificatePolicies||Ce,value:PolicyInformation.schema()})]})}fromSchema(e){clearProps(e,Kt);const t=compareSchema(e,e,CertificatePolicies.schema({names:{certificatePolicies:Rt}}));AsnError.assertSchema(t,this.className),this.certificatePolicies=Array.from(t.result.certificatePolicies,e=>new PolicyInformation({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}}CertificatePolicies.CLASS_NAME="CertificatePolicies";const Ut="templateID",Tt="templateMajorVersion",Lt="templateMinorVersion",Ht=[Ut,Tt,Lt];class CertificateTemplate extends PkiObject{constructor(e={}){super(),this.templateID=getParametersValue(e,Ut,CertificateTemplate.defaultValues(Ut)),Tt in e&&(this.templateMajorVersion=getParametersValue(e,Tt,CertificateTemplate.defaultValues(Tt))),Lt in e&&(this.templateMinorVersion=getParametersValue(e,Lt,CertificateTemplate.defaultValues(Lt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ut:return Ce;case Tt:case Lt:return 0;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.templateID||Ce}),new Integer({name:t.templateMajorVersion||Ce,optional:!0}),new Integer({name:t.templateMinorVersion||Ce,optional:!0})]})}fromSchema(e){clearProps(e,Ht);const t=compareSchema(e,e,CertificateTemplate.schema({names:{templateID:Ut,templateMajorVersion:Tt,templateMinorVersion:Lt}}));AsnError.assertSchema(t,this.className),this.templateID=t.result.templateID.valueBlock.toString(),Tt in t.result&&(this.templateMajorVersion=t.result.templateMajorVersion.valueBlock.valueDec),Lt in t.result&&(this.templateMinorVersion=t.result.templateMinorVersion.valueBlock.valueDec)}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.templateID})),Tt in this&&e.push(new Integer({value:this.templateMajorVersion})),Lt in this&&e.push(new Integer({value:this.templateMinorVersion})),new Sequence({value:e})}toJSON(){const e={templateID:this.templateID};return Tt in this&&(e.templateMajorVersion=this.templateMajorVersion),Lt in this&&(e.templateMinorVersion=this.templateMinorVersion),e}}const qt="distributionPoint",jt="distributionPointNames",Mt="reasons",Jt="cRLIssuer",_t="cRLIssuerNames",Ft=[qt,jt,Mt,Jt,_t];class DistributionPoint extends PkiObject{constructor(e={}){super(),qt in e&&(this.distributionPoint=getParametersValue(e,qt,DistributionPoint.defaultValues(qt))),Mt in e&&(this.reasons=getParametersValue(e,Mt,DistributionPoint.defaultValues(Mt))),Jt in e&&(this.cRLIssuer=getParametersValue(e,Jt,DistributionPoint.defaultValues(Jt))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case qt:return[];case Mt:return new BitString;case Jt:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Choice({value:[new Constructed({name:t.distributionPoint||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({name:t.distributionPointNames||Ce,value:GeneralName.schema()})]}),new Constructed({name:t.distributionPoint||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:1},value:RelativeDistinguishedNames.schema().valueBlock.value})]})]}),new Primitive({name:t.reasons||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new Constructed({name:t.cRLIssuer||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new Repeated({name:t.cRLIssuerNames||Ce,value:GeneralName.schema()})]})]})}fromSchema(e){clearProps(e,Ft);const t=compareSchema(e,e,DistributionPoint.schema({names:{distributionPoint:qt,distributionPointNames:jt,reasons:Mt,cRLIssuer:Jt,cRLIssuerNames:_t}}));AsnError.assertSchema(t,this.className),qt in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new GeneralName({schema:e}))),1===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=new RelativeDistinguishedNames({schema:new Sequence({value:t.result.distributionPoint.valueBlock.value})}))),Mt in t.result&&(this.reasons=new BitString({valueHex:t.result.reasons.valueBlock.valueHex})),Jt in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,e=>new GeneralName({schema:e})))}toSchema(){const e=[];if(this.distributionPoint){let t;t=this.distributionPoint instanceof Array?new Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return this.reasons&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHexView})),this.cRLIssuer&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.reasons&&(e.reasons=this.reasons.toJSON()),this.cRLIssuer&&(e.cRLIssuer=Array.from(this.cRLIssuer,e=>e.toJSON())),e}}DistributionPoint.CLASS_NAME="DistributionPoint";const $t="distributionPoints",Wt=[$t];class CRLDistributionPoints extends PkiObject{constructor(e={}){super(),this.distributionPoints=getParametersValue(e,$t,CRLDistributionPoints.defaultValues($t)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===$t?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.distributionPoints||Ce,value:DistributionPoint.schema()})]})}fromSchema(e){clearProps(e,Wt);const t=compareSchema(e,e,CRLDistributionPoints.schema({names:{distributionPoints:$t}}));AsnError.assertSchema(t,this.className),this.distributionPoints=Array.from(t.result.distributionPoints,e=>new DistributionPoint({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}}CRLDistributionPoints.CLASS_NAME="CRLDistributionPoints";const Gt="keyPurposes",zt=[Gt];class ExtKeyUsage extends PkiObject{constructor(e={}){super(),this.keyPurposes=getParametersValue(e,Gt,ExtKeyUsage.defaultValues(Gt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Gt?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.keyPurposes||Ce,value:new ObjectIdentifier})]})}fromSchema(e){clearProps(e,zt);const t=compareSchema(e,e,ExtKeyUsage.schema({names:{keyPurposes:Gt}}));AsnError.assertSchema(t,this.className),this.keyPurposes=Array.from(t.result.keyPurposes,e=>e.valueBlock.toString())}toSchema(){return new Sequence({value:Array.from(this.keyPurposes,e=>new ObjectIdentifier({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}ExtKeyUsage.CLASS_NAME="ExtKeyUsage";const Qt="accessDescriptions";class InfoAccess extends PkiObject{constructor(e={}){super(),this.accessDescriptions=getParametersValue(e,Qt,InfoAccess.defaultValues(Qt)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Qt?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.accessDescriptions||Ce,value:AccessDescription.schema()})]})}fromSchema(e){clearProps(e,[Qt]);const t=compareSchema(e,e,InfoAccess.schema({names:{accessDescriptions:Qt}}));AsnError.assertSchema(t,this.className),this.accessDescriptions=Array.from(t.result.accessDescriptions,e=>new AccessDescription({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}}InfoAccess.CLASS_NAME="InfoAccess";const Zt="distributionPoint",Yt="distributionPointNames",Xt="onlyContainsUserCerts",er="onlyContainsCACerts",tr="onlySomeReasons",rr="indirectCRL",sr="onlyContainsAttributeCerts",ar=[Zt,Yt,Xt,er,tr,rr,sr];class IssuingDistributionPoint extends PkiObject{constructor(e={}){super(),Zt in e&&(this.distributionPoint=getParametersValue(e,Zt,IssuingDistributionPoint.defaultValues(Zt))),this.onlyContainsUserCerts=getParametersValue(e,Xt,IssuingDistributionPoint.defaultValues(Xt)),this.onlyContainsCACerts=getParametersValue(e,er,IssuingDistributionPoint.defaultValues(er)),tr in e&&(this.onlySomeReasons=getParametersValue(e,tr,IssuingDistributionPoint.defaultValues(tr))),this.indirectCRL=getParametersValue(e,rr,IssuingDistributionPoint.defaultValues(rr)),this.onlyContainsAttributeCerts=getParametersValue(e,sr,IssuingDistributionPoint.defaultValues(sr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Zt:return[];case Xt:case er:return!1;case tr:return 0;case rr:case sr:return!1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Choice({value:[new Constructed({name:t.distributionPoint||Ce,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({name:t.distributionPointNames||Ce,value:GeneralName.schema()})]}),new Constructed({name:t.distributionPoint||Ce,idBlock:{tagClass:3,tagNumber:1},value:RelativeDistinguishedNames.schema().valueBlock.value})]})]}),new Primitive({name:t.onlyContainsUserCerts||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new Primitive({name:t.onlyContainsCACerts||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new Primitive({name:t.onlySomeReasons||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new Primitive({name:t.indirectCRL||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new Primitive({name:t.onlyContainsAttributeCerts||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){clearProps(e,ar);const t=compareSchema(e,e,IssuingDistributionPoint.schema({names:{distributionPoint:Zt,distributionPointNames:Yt,onlyContainsUserCerts:Xt,onlyContainsCACerts:er,onlySomeReasons:tr,indirectCRL:rr,onlyContainsAttributeCerts:sr}}));if(AsnError.assertSchema(t,this.className),Zt in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new GeneralName({schema:e}));break;case 1===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=new RelativeDistinguishedNames({schema:new Sequence({value:t.result.distributionPoint.valueBlock.value})});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if(Xt in t.result){const e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if(er in t.result){const e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if(tr in t.result){const e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if(rr in t.result){const e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if(sr in t.result){const e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){const e=[];if(this.distributionPoint){let t;this.distributionPoint instanceof Array?t=new Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):(t=this.distributionPoint.toSchema(),t.idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(this.onlyContainsUserCerts!==IssuingDistributionPoint.defaultValues(Xt)&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==IssuingDistributionPoint.defaultValues(er)&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),void 0!==this.onlySomeReasons){const t=new ArrayBuffer(1);new Uint8Array(t)[0]=this.onlySomeReasons,e.push(new Primitive({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==IssuingDistributionPoint.defaultValues(rr)&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==IssuingDistributionPoint.defaultValues(sr)&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new Sequence({value:e})}toJSON(){const e={};return this.distributionPoint&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==IssuingDistributionPoint.defaultValues(Xt)&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==IssuingDistributionPoint.defaultValues(er)&&(e.onlyContainsCACerts=this.onlyContainsCACerts),tr in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==IssuingDistributionPoint.defaultValues(rr)&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==IssuingDistributionPoint.defaultValues(sr)&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}IssuingDistributionPoint.CLASS_NAME="IssuingDistributionPoint";const ir="base",nr="minimum",or="maximum",lr=[ir,nr,or];class GeneralSubtree extends PkiObject{constructor(e={}){super(),this.base=getParametersValue(e,ir,GeneralSubtree.defaultValues(ir)),this.minimum=getParametersValue(e,nr,GeneralSubtree.defaultValues(nr)),or in e&&(this.maximum=getParametersValue(e,or,GeneralSubtree.defaultValues(or))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ir:return new GeneralName;case nr:case or:return 0;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[GeneralName.schema(t.base||{}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Integer({name:t.minimum||Ce})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Integer({name:t.maximum||Ce})]})]})}fromSchema(e){clearProps(e,lr);const t=compareSchema(e,e,GeneralSubtree.schema({names:{base:{names:{blockName:ir}},minimum:nr,maximum:or}}));AsnError.assertSchema(t,this.className),this.base=new GeneralName({schema:t.result.base}),nr in t.result&&(t.result.minimum.valueBlock.isHexOnly?this.minimum=t.result.minimum:this.minimum=t.result.minimum.valueBlock.valueDec),or in t.result&&(t.result.maximum.valueBlock.isHexOnly?this.maximum=t.result.maximum:this.maximum=t.result.maximum.valueBlock.valueDec)}toSchema(){const e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof Integer?this.minimum:new Integer({value:this.minimum}),e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(or in this){let t=0;t=this.maximum instanceof Integer?this.maximum:new Integer({value:this.maximum}),e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new Sequence({value:e})}toJSON(){const e={base:this.base.toJSON()};return 0!==this.minimum&&("number"==typeof this.minimum?e.minimum=this.minimum:e.minimum=this.minimum.toJSON()),void 0!==this.maximum&&("number"==typeof this.maximum?e.maximum=this.maximum:e.maximum=this.maximum.toJSON()),e}}GeneralSubtree.CLASS_NAME="GeneralSubtree";const cr="permittedSubtrees",ur="excludedSubtrees",hr=[cr,ur];class NameConstraints extends PkiObject{constructor(e={}){super(),cr in e&&(this.permittedSubtrees=getParametersValue(e,cr,NameConstraints.defaultValues(cr))),ur in e&&(this.excludedSubtrees=getParametersValue(e,ur,NameConstraints.defaultValues(ur))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case cr:case ur:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({name:t.permittedSubtrees||Ce,value:GeneralSubtree.schema()})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Repeated({name:t.excludedSubtrees||Ce,value:GeneralSubtree.schema()})]})]})}fromSchema(e){clearProps(e,hr);const t=compareSchema(e,e,NameConstraints.schema({names:{permittedSubtrees:cr,excludedSubtrees:ur}}));AsnError.assertSchema(t,this.className),cr in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,e=>new GeneralSubtree({schema:e}))),ur in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,e=>new GeneralSubtree({schema:e})))}toSchema(){const e=[];return this.permittedSubtrees&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.permittedSubtrees,e=>e.toSchema())})),this.excludedSubtrees&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.excludedSubtrees,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={};return this.permittedSubtrees&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,e=>e.toJSON())),this.excludedSubtrees&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,e=>e.toJSON())),e}}NameConstraints.CLASS_NAME="NameConstraints";const mr="requireExplicitPolicy",fr="inhibitPolicyMapping",gr=[mr,fr];class PolicyConstraints extends PkiObject{constructor(e={}){super(),mr in e&&(this.requireExplicitPolicy=getParametersValue(e,mr,PolicyConstraints.defaultValues(mr))),fr in e&&(this.inhibitPolicyMapping=getParametersValue(e,fr,PolicyConstraints.defaultValues(fr))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case mr:case fr:return 0;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Primitive({name:t.requireExplicitPolicy||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new Primitive({name:t.inhibitPolicyMapping||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){clearProps(e,gr);const t=compareSchema(e,e,PolicyConstraints.schema({names:{requireExplicitPolicy:mr,inhibitPolicyMapping:fr}}));if(AsnError.assertSchema(t,this.className),mr in t.result){const e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=fromBER(e.toBER(!1));AsnError.assert(r,"Integer"),this.requireExplicitPolicy=r.result.valueBlock.valueDec}if(fr in t.result){const e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=fromBER(e.toBER(!1));AsnError.assert(r,"Integer"),this.inhibitPolicyMapping=r.result.valueBlock.valueDec}}toSchema(){const e=[];if(mr in this){const t=new Integer({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if(fr in this){const t=new Integer({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new Sequence({value:e})}toJSON(){const e={};return mr in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),fr in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}PolicyConstraints.CLASS_NAME="PolicyConstraints";const dr="issuerDomainPolicy",pr="subjectDomainPolicy",Sr=[dr,pr];class PolicyMapping extends PkiObject{constructor(e={}){super(),this.issuerDomainPolicy=getParametersValue(e,dr,PolicyMapping.defaultValues(dr)),this.subjectDomainPolicy=getParametersValue(e,pr,PolicyMapping.defaultValues(pr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case dr:case pr:return Ce;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.issuerDomainPolicy||Ce}),new ObjectIdentifier({name:t.subjectDomainPolicy||Ce})]})}fromSchema(e){clearProps(e,Sr);const t=compareSchema(e,e,PolicyMapping.schema({names:{issuerDomainPolicy:dr,subjectDomainPolicy:pr}}));AsnError.assertSchema(t,this.className),this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.issuerDomainPolicy}),new ObjectIdentifier({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}PolicyMapping.CLASS_NAME="PolicyMapping";const yr="mappings",wr=[yr];class PolicyMappings extends PkiObject{constructor(e={}){super(),this.mappings=getParametersValue(e,yr,PolicyMappings.defaultValues(yr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===yr?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.mappings||Ce,value:PolicyMapping.schema()})]})}fromSchema(e){clearProps(e,wr);const t=compareSchema(e,e,PolicyMappings.schema({names:{mappings:yr}}));AsnError.assertSchema(t,this.className),this.mappings=Array.from(t.result.mappings,e=>new PolicyMapping({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}}PolicyMappings.CLASS_NAME="PolicyMappings";const vr="notBefore",br="notAfter",Ar=[vr,br];class PrivateKeyUsagePeriod extends PkiObject{constructor(e={}){super(),vr in e&&(this.notBefore=getParametersValue(e,vr,PrivateKeyUsagePeriod.defaultValues(vr))),br in e&&(this.notAfter=getParametersValue(e,br,PrivateKeyUsagePeriod.defaultValues(br))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case vr:case br:return new Date;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Primitive({name:t.notBefore||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new Primitive({name:t.notAfter||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){clearProps(e,Ar);const t=compareSchema(e,e,PrivateKeyUsagePeriod.schema({names:{notBefore:vr,notAfter:br}}));if(AsnError.assertSchema(t,this.className),vr in t.result){const e=new GeneralizedTime;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if(br in t.result){const e=new GeneralizedTime({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){const e=[];return vr in this&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:new GeneralizedTime({valueDate:this.notBefore}).valueBlock.valueHexView})),br in this&&e.push(new Primitive({idBlock:{tagClass:3,tagNumber:1},valueHex:new GeneralizedTime({valueDate:this.notAfter}).valueBlock.valueHexView})),new Sequence({value:e})}toJSON(){const e={};return this.notBefore&&(e.notBefore=this.notBefore),this.notAfter&&(e.notAfter=this.notAfter),e}}PrivateKeyUsagePeriod.CLASS_NAME="PrivateKeyUsagePeriod";const kr="id",Cr="type",Vr="values",Br=[kr,Cr],Ir=[Vr];class QCStatement extends PkiObject{constructor(e={}){super(),this.id=getParametersValue(e,kr,QCStatement.defaultValues(kr)),Cr in e&&(this.type=getParametersValue(e,Cr,QCStatement.defaultValues(Cr))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case kr:return Ce;case Cr:return new Null;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case kr:return t===Ce;case Cr:return t instanceof Null;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.id||Ce}),new Any({name:t.type||Ce,optional:!0})]})}fromSchema(e){clearProps(e,Br);const t=compareSchema(e,e,QCStatement.schema({names:{id:kr,type:Cr}}));AsnError.assertSchema(t,this.className),this.id=t.result.id.valueBlock.toString(),Cr in t.result&&(this.type=t.result.type)}toSchema(){const e=[new ObjectIdentifier({value:this.id})];return Cr in this&&e.push(this.type),new Sequence({value:e})}toJSON(){const e={id:this.id};return this.type&&(e.type=this.type.toJSON()),e}}QCStatement.CLASS_NAME="QCStatement";class QCStatements extends PkiObject{constructor(e={}){super(),this.values=getParametersValue(e,Vr,QCStatements.defaultValues(Vr)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Vr?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===Vr?0===t.length:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.values||Ce,value:QCStatement.schema(t.value||{})})]})}fromSchema(e){clearProps(e,Ir);const t=compareSchema(e,e,QCStatements.schema({names:{values:Vr}}));AsnError.assertSchema(t,this.className),this.values=Array.from(t.result.values,e=>new QCStatement({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.values,e=>e.toSchema())})}toJSON(){return{values:Array.from(this.values,e=>e.toJSON())}}}var Nr;QCStatements.CLASS_NAME="QCStatements";class ECNamedCurves{static register(e,t,r){this.namedCurves[e.toLowerCase()]=this.namedCurves[t]={name:e,id:t,size:r}}static find(e){return this.namedCurves[e.toLowerCase()]||null}}Nr=ECNamedCurves,ECNamedCurves.namedCurves={},Nr.register("P-256","1.2.840.10045.3.1.7",32),Nr.register("P-384","1.3.132.0.34",48),Nr.register("P-521","1.3.132.0.35",66),Nr.register("brainpoolP256r1","1.3.36.3.3.2.8.1.1.7",32),Nr.register("brainpoolP384r1","1.3.36.3.3.2.8.1.1.11",48),Nr.register("brainpoolP512r1","1.3.36.3.3.2.8.1.1.13",64);const Pr="x",Er="y",Dr="namedCurve";class ECPublicKey extends PkiObject{constructor(e={}){super(),this.x=getParametersValue(e,Pr,ECPublicKey.defaultValues(Pr)),this.y=getParametersValue(e,Er,ECPublicKey.defaultValues(Er)),this.namedCurve=getParametersValue(e,Dr,ECPublicKey.defaultValues(Dr)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Pr:case Er:return ke;case Dr:return Ce;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Pr:case Er:return t instanceof ArrayBuffer&&isEqualBuffer(t,ECPublicKey.defaultValues(e));case Dr:return"string"==typeof t&&t===ECPublicKey.defaultValues(e);default:return super.defaultValues(e)}}static schema(){return new RawData}fromSchema(e){const t=BufferSourceConverter.toUint8Array(e);if(4!==t[0])throw new Error("Object's schema was not verified against input data for ECPublicKey");const r=ECNamedCurves.find(this.namedCurve);if(!r)throw new Error(`Incorrect curve OID: ${this.namedCurve}`);const s=r.size;if(t.byteLength!==2*s+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.namedCurve=r.name,this.x=t.slice(1,s+1).buffer,this.y=t.slice(1+s,2*s+1).buffer}toSchema(){return new RawData({data:utilConcatBuf(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){const e=ECNamedCurves.find(this.namedCurve);return{crv:e?e.name:this.namedCurve,x:toBase64(arrayBufferToString(this.x),!0,!0,!1),y:toBase64(arrayBufferToString(this.y),!0,!0,!1)}}fromJSON(e){ParameterError.assert("json",e,"crv","x","y");let t=0;const r=ECNamedCurves.find(e.crv);r&&(this.namedCurve=r.id,t=r.size);const s=stringToArrayBuffer(fromBase64(e.x,!0));if(s.byteLength<t){this.x=new ArrayBuffer(t);const e=new Uint8Array(this.x),r=new Uint8Array(s);e.set(r,1)}else this.x=s.slice(0,t);const a=stringToArrayBuffer(fromBase64(e.y,!0));if(a.byteLength<t){this.y=new ArrayBuffer(t);const e=new Uint8Array(this.y),r=new Uint8Array(a);e.set(r,1)}else this.y=a.slice(0,t)}}ECPublicKey.CLASS_NAME="ECPublicKey";const Or="modulus",xr="publicExponent",Rr=[Or,xr];class RSAPublicKey extends PkiObject{constructor(e={}){super(),this.modulus=getParametersValue(e,Or,RSAPublicKey.defaultValues(Or)),this.publicExponent=getParametersValue(e,xr,RSAPublicKey.defaultValues(xr)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Or:case xr:return new Integer;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.modulus||Ce}),new Integer({name:t.publicExponent||Ce})]})}fromSchema(e){clearProps(e,Rr);const t=compareSchema(e,e,RSAPublicKey.schema({names:{modulus:Or,publicExponent:xr}}));AsnError.assertSchema(t,this.className),this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new Sequence({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),e:Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView)}}fromJSON(e){ParameterError.assert("json",e,"n","e");const t=stringToArrayBuffer(fromBase64(e.n,!0));this.modulus=new Integer({valueHex:t.slice(0,Math.pow(2,nearestPowerOf2(t.byteLength)))}),this.publicExponent=new Integer({valueHex:stringToArrayBuffer(fromBase64(e.e,!0)).slice(0,3)})}}RSAPublicKey.CLASS_NAME="RSAPublicKey";const Kr="algorithm",Ur="subjectPublicKey",Tr=[Kr,Ur];class PublicKeyInfo extends PkiObject{get parsedKey(){if(void 0===this._parsedKey){switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams.constructor.blockName()===ObjectIdentifier.blockName())try{this._parsedKey=new ECPublicKey({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHexView})}catch(e){}break;case"1.2.840.113549.1.1.1":{const e=fromBER(this.subjectPublicKey.valueBlock.valueHexView);if(-1!==e.offset)try{this._parsedKey=new RSAPublicKey({schema:e.result})}catch(e){}}}this._parsedKey||(this._parsedKey=null)}return this._parsedKey||void 0}set parsedKey(e){this._parsedKey=e}constructor(e={}){super(),this.algorithm=getParametersValue(e,Kr,PublicKeyInfo.defaultValues(Kr)),this.subjectPublicKey=getParametersValue(e,Ur,PublicKeyInfo.defaultValues(Ur));const t=getParametersValue(e,"parsedKey",null);t&&(this.parsedKey=t),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Kr:return new AlgorithmIdentifier;case Ur:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[AlgorithmIdentifier.schema(t.algorithm||{}),new BitString({name:t.subjectPublicKey||Ce})]})}fromSchema(e){clearProps(e,Tr);const t=compareSchema(e,e,PublicKeyInfo.schema({names:{algorithm:{names:{blockName:Kr}},subjectPublicKey:Ur}}));AsnError.assertSchema(t,this.className),this.algorithm=new AlgorithmIdentifier({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey}toSchema(){return new Sequence({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if(!this.parsedKey)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};const e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new ECPublicKey({json:e}),this.algorithm=new AlgorithmIdentifier({algorithmId:"1.2.840.10045.2.1",algorithmParams:new ObjectIdentifier({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new RSAPublicKey({json:e}),this.algorithm=new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new Null});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.subjectPublicKey=new BitString({valueHex:this.parsedKey.toSchema().toBER(!1)})}}async importKey(e,t=getCrypto(!0)){try{if(!e)throw new Error("Need to provide publicKey input parameter");const r=fromBER(await t.exportKey("spki",e));try{this.fromSchema(r.result)}catch(e){throw new Error("Error during initializing object from schema")}}catch(e){const t=e instanceof Error?e.message:`${e}`;throw new Error(`Error during exporting public key: ${t}`)}}}PublicKeyInfo.CLASS_NAME="PublicKeyInfo";const Lr="version",Hr="privateKey",qr="namedCurve",jr="publicKey",Mr=[Lr,Hr,qr,jr];class ECPrivateKey extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Lr,ECPrivateKey.defaultValues(Lr)),this.privateKey=getParametersValue(e,Hr,ECPrivateKey.defaultValues(Hr)),qr in e&&(this.namedCurve=getParametersValue(e,qr,ECPrivateKey.defaultValues(qr))),jr in e&&(this.publicKey=getParametersValue(e,jr,ECPrivateKey.defaultValues(jr))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Lr:return 1;case Hr:return new OctetString;case qr:return Ce;case jr:return new ECPublicKey;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Lr:return t===ECPrivateKey.defaultValues(e);case Hr:return t.isEqual(ECPrivateKey.defaultValues(e));case qr:return t===Ce;case jr:return ECPublicKey.compareWithDefault(qr,t.namedCurve)&&ECPublicKey.compareWithDefault("x",t.x)&&ECPublicKey.compareWithDefault("y",t.y);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||Ce}),new OctetString({name:t.privateKey||Ce}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ObjectIdentifier({name:t.namedCurve||Ce})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new BitString({name:t.publicKey||Ce})]})]})}fromSchema(e){clearProps(e,Mr);const t=compareSchema(e,e,ECPrivateKey.schema({names:{version:Lr,privateKey:Hr,namedCurve:qr,publicKey:jr}}));if(AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,qr in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),jr in t.result){const e={schema:t.result.publicKey.valueBlock.valueHex};qr in this&&(e.namedCurve=this.namedCurve),this.publicKey=new ECPublicKey(e)}}toSchema(){const e=[new Integer({value:this.version}),this.privateKey];return this.namedCurve&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new ObjectIdentifier({value:this.namedCurve})]})),this.publicKey&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new BitString({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new Sequence({value:e})}toJSON(){if(!this.namedCurve||ECPrivateKey.compareWithDefault(qr,this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');const e=ECNamedCurves.find(this.namedCurve),t={crv:e?e.name:this.namedCurve,d:Convert.ToBase64Url(this.privateKey.valueBlock.valueHexView)};if(this.publicKey){const e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){ParameterError.assert("json",e,"crv","d");let t=0;const r=ECNamedCurves.find(e.crv);r&&(this.namedCurve=r.id,t=r.size);const s=Convert.FromBase64Url(e.d);if(s.byteLength<t){const e=new ArrayBuffer(t),r=new Uint8Array(e),a=new Uint8Array(s);r.set(a,1),this.privateKey=new OctetString({valueHex:e})}else this.privateKey=new OctetString({valueHex:s.slice(0,t)});e.x&&e.y&&(this.publicKey=new ECPublicKey({json:e}))}}ECPrivateKey.CLASS_NAME="ECPrivateKey";const Jr="prime",_r="exponent",Fr="coefficient",$r=[Jr,_r,Fr];class OtherPrimeInfo extends PkiObject{constructor(e={}){super(),this.prime=getParametersValue(e,Jr,OtherPrimeInfo.defaultValues(Jr)),this.exponent=getParametersValue(e,_r,OtherPrimeInfo.defaultValues(_r)),this.coefficient=getParametersValue(e,Fr,OtherPrimeInfo.defaultValues(Fr)),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Jr:case _r:case Fr:return new Integer;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.prime||Ce}),new Integer({name:t.exponent||Ce}),new Integer({name:t.coefficient||Ce})]})}fromSchema(e){clearProps(e,$r);const t=compareSchema(e,e,OtherPrimeInfo.schema({names:{prime:Jr,exponent:_r,coefficient:Fr}}));AsnError.assertSchema(t,this.className),this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new Sequence({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:Convert.ToBase64Url(this.prime.valueBlock.valueHexView),d:Convert.ToBase64Url(this.exponent.valueBlock.valueHexView),t:Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)}}fromJSON(e){ParameterError.assert("json",e,"r","d","r"),this.prime=new Integer({valueHex:Convert.FromBase64Url(e.r)}),this.exponent=new Integer({valueHex:Convert.FromBase64Url(e.d)}),this.coefficient=new Integer({valueHex:Convert.FromBase64Url(e.t)})}}OtherPrimeInfo.CLASS_NAME="OtherPrimeInfo";const Wr="version",Gr="modulus",zr="publicExponent",Qr="privateExponent",Zr="prime1",Yr="prime2",Xr="exponent1",es="exponent2",ts="coefficient",rs="otherPrimeInfos",ss=[Wr,Gr,zr,Qr,Zr,Yr,Xr,es,ts,rs];class RSAPrivateKey extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Wr,RSAPrivateKey.defaultValues(Wr)),this.modulus=getParametersValue(e,Gr,RSAPrivateKey.defaultValues(Gr)),this.publicExponent=getParametersValue(e,zr,RSAPrivateKey.defaultValues(zr)),this.privateExponent=getParametersValue(e,Qr,RSAPrivateKey.defaultValues(Qr)),this.prime1=getParametersValue(e,Zr,RSAPrivateKey.defaultValues(Zr)),this.prime2=getParametersValue(e,Yr,RSAPrivateKey.defaultValues(Yr)),this.exponent1=getParametersValue(e,Xr,RSAPrivateKey.defaultValues(Xr)),this.exponent2=getParametersValue(e,es,RSAPrivateKey.defaultValues(es)),this.coefficient=getParametersValue(e,ts,RSAPrivateKey.defaultValues(ts)),rs in e&&(this.otherPrimeInfos=getParametersValue(e,rs,RSAPrivateKey.defaultValues(rs))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Wr:return 0;case Gr:case zr:case Qr:case Zr:case Yr:case Xr:case es:case ts:return new Integer;case rs:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||Ce}),new Integer({name:t.modulus||Ce}),new Integer({name:t.publicExponent||Ce}),new Integer({name:t.privateExponent||Ce}),new Integer({name:t.prime1||Ce}),new Integer({name:t.prime2||Ce}),new Integer({name:t.exponent1||Ce}),new Integer({name:t.exponent2||Ce}),new Integer({name:t.coefficient||Ce}),new Sequence({optional:!0,value:[new Repeated({name:t.otherPrimeInfosName||Ce,value:OtherPrimeInfo.schema(t.otherPrimeInfo||{})})]})]})}fromSchema(e){clearProps(e,ss);const t=compareSchema(e,e,RSAPrivateKey.schema({names:{version:Wr,modulus:Gr,publicExponent:zr,privateExponent:Qr,prime1:Zr,prime2:Yr,exponent1:Xr,exponent2:es,coefficient:ts,otherPrimeInfo:{names:{blockName:rs}}}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),rs in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,e=>new OtherPrimeInfo({schema:e})))}toSchema(){const e=[];return e.push(new Integer({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),this.otherPrimeInfos&&e.push(new Sequence({value:Array.from(this.otherPrimeInfos,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={n:Convert.ToBase64Url(this.modulus.valueBlock.valueHexView),e:Convert.ToBase64Url(this.publicExponent.valueBlock.valueHexView),d:Convert.ToBase64Url(this.privateExponent.valueBlock.valueHexView),p:Convert.ToBase64Url(this.prime1.valueBlock.valueHexView),q:Convert.ToBase64Url(this.prime2.valueBlock.valueHexView),dp:Convert.ToBase64Url(this.exponent1.valueBlock.valueHexView),dq:Convert.ToBase64Url(this.exponent2.valueBlock.valueHexView),qi:Convert.ToBase64Url(this.coefficient.valueBlock.valueHexView)};return this.otherPrimeInfos&&(e.oth=Array.from(this.otherPrimeInfos,e=>e.toJSON())),e}fromJSON(e){ParameterError.assert("json",e,"n","e","d","p","q","dp","dq","qi"),this.modulus=new Integer({valueHex:Convert.FromBase64Url(e.n)}),this.publicExponent=new Integer({valueHex:Convert.FromBase64Url(e.e)}),this.privateExponent=new Integer({valueHex:Convert.FromBase64Url(e.d)}),this.prime1=new Integer({valueHex:Convert.FromBase64Url(e.p)}),this.prime2=new Integer({valueHex:Convert.FromBase64Url(e.q)}),this.exponent1=new Integer({valueHex:Convert.FromBase64Url(e.dp)}),this.exponent2=new Integer({valueHex:Convert.FromBase64Url(e.dq)}),this.coefficient=new Integer({valueHex:Convert.FromBase64Url(e.qi)}),e.oth&&(this.otherPrimeInfos=Array.from(e.oth,e=>new OtherPrimeInfo({json:e})))}}RSAPrivateKey.CLASS_NAME="RSAPrivateKey";const as="version",is="privateKeyAlgorithm",ns="privateKey",os="attributes",ls="parsedKey",cs=[as,is,ns,os];class PrivateKeyInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,as,PrivateKeyInfo.defaultValues(as)),this.privateKeyAlgorithm=getParametersValue(e,is,PrivateKeyInfo.defaultValues(is)),this.privateKey=getParametersValue(e,ns,PrivateKeyInfo.defaultValues(ns)),os in e&&(this.attributes=getParametersValue(e,os,PrivateKeyInfo.defaultValues(os))),ls in e&&(this.parsedKey=getParametersValue(e,ls,PrivateKeyInfo.defaultValues(ls))),e.json&&this.fromJSON(e.json),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case as:return 0;case is:return new AlgorithmIdentifier;case ns:return new OctetString;case os:return[];case ls:return{};default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||Ce}),AlgorithmIdentifier.schema(t.privateKeyAlgorithm||{}),new OctetString({name:t.privateKey||Ce}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({name:t.attributes||Ce,value:Attribute.schema()})]})]})}fromSchema(e){clearProps(e,cs);const t=compareSchema(e,e,PrivateKeyInfo.schema({names:{version:as,privateKeyAlgorithm:{names:{blockName:is}},privateKey:ns,attributes:os}}));switch(AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new AlgorithmIdentifier({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,os in t.result&&(this.attributes=Array.from(t.result.attributes,e=>new Attribute({schema:e}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{const e=fromBER(this.privateKey.valueBlock.valueHexView);-1!==e.offset&&(this.parsedKey=new RSAPrivateKey({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof ObjectIdentifier){const e=fromBER(this.privateKey.valueBlock.valueHexView);-1!==e.offset&&(this.parsedKey=new ECPrivateKey({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){const e=[new Integer({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return this.attributes&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){if(!this.parsedKey){const e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return this.attributes&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}const e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();return Object.assign(e,t),e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new ECPrivateKey({json:e}),this.privateKeyAlgorithm=new AlgorithmIdentifier({algorithmId:"1.2.840.10045.2.1",algorithmParams:new ObjectIdentifier({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new RSAPrivateKey({json:e}),this.privateKeyAlgorithm=new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new Null});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.privateKey=new OctetString({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}PrivateKeyInfo.CLASS_NAME="PrivateKeyInfo";const us="contentType",hs="contentEncryptionAlgorithm",ms="encryptedContent",fs=[us,hs,ms];class EncryptedContentInfo extends PkiObject{constructor(e={}){if(super(),this.contentType=getParametersValue(e,us,EncryptedContentInfo.defaultValues(us)),this.contentEncryptionAlgorithm=getParametersValue(e,hs,EncryptedContentInfo.defaultValues(hs)),ms in e&&e.encryptedContent&&(this.encryptedContent=e.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed&&!e.disableSplit)){const e=new OctetString({idBlock:{isConstructed:!0},isConstructed:!0});let t=0;const r=this.encryptedContent.valueBlock.valueHexView.slice().buffer;let s=r.byteLength;for(;s>0;){const a=new Uint8Array(r,t,t+1024>r.byteLength?r.byteLength-t:1024),i=new ArrayBuffer(a.length),n=new Uint8Array(i);for(let e=0;e<n.length;e++)n[e]=a[e];e.valueBlock.value.push(new OctetString({valueHex:i})),s-=a.length,t+=a.length}this.encryptedContent=e}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case us:return Ce;case hs:return new AlgorithmIdentifier;case ms:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case us:return t===Ce;case hs:return t.algorithmId===Ce&&"algorithmParams"in t==!1;case ms:return t.isEqual(EncryptedContentInfo.defaultValues(ms));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.contentType||Ce}),AlgorithmIdentifier.schema(t.contentEncryptionAlgorithm||{}),new Choice({value:[new Constructed({name:t.encryptedContent||Ce,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({value:new OctetString})]}),new Primitive({name:t.encryptedContent||Ce,idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){clearProps(e,fs);const t=compareSchema(e,e,EncryptedContentInfo.schema({names:{contentType:us,contentEncryptionAlgorithm:{names:{blockName:hs}},encryptedContent:ms}}));AsnError.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.contentEncryptionAlgorithm}),ms in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){const e={isIndefiniteForm:!1},t=[];if(t.push(new ObjectIdentifier({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),this.encryptedContent){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;const r=this.encryptedContent;r.idBlock.tagClass=3,r.idBlock.tagNumber=0,r.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(r)}return new Sequence({lenBlock:e,value:t})}toJSON(){const e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return this.encryptedContent&&(e.encryptedContent=this.encryptedContent.toJSON()),e}getEncryptedContent(){if(!this.encryptedContent)throw new Error("Parameter 'encryptedContent' is undefined");return OctetString.prototype.getValue.call(this.encryptedContent)}}EncryptedContentInfo.CLASS_NAME="EncryptedContentInfo";const gs="hashAlgorithm",ds="maskGenAlgorithm",ps="saltLength",Ss="trailerField",ys=[gs,ds,ps,Ss];class RSASSAPSSParams extends PkiObject{constructor(e={}){super(),this.hashAlgorithm=getParametersValue(e,gs,RSASSAPSSParams.defaultValues(gs)),this.maskGenAlgorithm=getParametersValue(e,ds,RSASSAPSSParams.defaultValues(ds)),this.saltLength=getParametersValue(e,ps,RSASSAPSSParams.defaultValues(ps)),this.trailerField=getParametersValue(e,Ss,RSASSAPSSParams.defaultValues(Ss)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case gs:return new AlgorithmIdentifier({algorithmId:"1.3.14.3.2.26",algorithmParams:new Null});case ds:return new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new AlgorithmIdentifier({algorithmId:"1.3.14.3.2.26",algorithmParams:new Null}).toSchema()});case ps:return 20;case Ss:return 1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Constructed({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[AlgorithmIdentifier.schema(t.hashAlgorithm||{})]}),new Constructed({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[AlgorithmIdentifier.schema(t.maskGenAlgorithm||{})]}),new Constructed({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new Integer({name:t.saltLength||Ce})]}),new Constructed({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new Integer({name:t.trailerField||Ce})]})]})}fromSchema(e){clearProps(e,ys);const t=compareSchema(e,e,RSASSAPSSParams.schema({names:{hashAlgorithm:{names:{blockName:gs}},maskGenAlgorithm:{names:{blockName:ds}},saltLength:ps,trailerField:Ss}}));AsnError.assertSchema(t,this.className),gs in t.result&&(this.hashAlgorithm=new AlgorithmIdentifier({schema:t.result.hashAlgorithm})),ds in t.result&&(this.maskGenAlgorithm=new AlgorithmIdentifier({schema:t.result.maskGenAlgorithm})),ps in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),Ss in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){const e=[];return this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(gs))||e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(ds))||e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==RSASSAPSSParams.defaultValues(ps)&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:[new Integer({value:this.saltLength})]})),this.trailerField!==RSASSAPSSParams.defaultValues(Ss)&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:3},value:[new Integer({value:this.trailerField})]})),new Sequence({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(RSASSAPSSParams.defaultValues(gs))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(RSASSAPSSParams.defaultValues(ds))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==RSASSAPSSParams.defaultValues(ps)&&(e.saltLength=this.saltLength),this.trailerField!==RSASSAPSSParams.defaultValues(Ss)&&(e.trailerField=this.trailerField),e}}RSASSAPSSParams.CLASS_NAME="RSASSAPSSParams";const ws="salt",vs="iterationCount",bs="keyLength",As="prf",ks=[ws,vs,bs,As];class PBKDF2Params extends PkiObject{constructor(e={}){super(),this.salt=getParametersValue(e,ws,PBKDF2Params.defaultValues(ws)),this.iterationCount=getParametersValue(e,vs,PBKDF2Params.defaultValues(vs)),bs in e&&(this.keyLength=getParametersValue(e,bs,PBKDF2Params.defaultValues(bs))),As in e&&(this.prf=getParametersValue(e,As,PBKDF2Params.defaultValues(As))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ws:return{};case vs:return-1;case bs:return 0;case As:return new AlgorithmIdentifier({algorithmId:"1.3.14.3.2.26",algorithmParams:new Null});default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Choice({value:[new OctetString({name:t.saltPrimitive||Ce}),AlgorithmIdentifier.schema(t.saltConstructed||{})]}),new Integer({name:t.iterationCount||Ce}),new Integer({name:t.keyLength||Ce,optional:!0}),AlgorithmIdentifier.schema(t.prf||{names:{optional:!0}})]})}fromSchema(e){clearProps(e,ks);const t=compareSchema(e,e,PBKDF2Params.schema({names:{saltPrimitive:ws,saltConstructed:{names:{blockName:ws}},iterationCount:vs,keyLength:bs,prf:{names:{blockName:As,optional:!0}}}}));AsnError.assertSchema(t,this.className),this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,bs in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),As in t.result&&(this.prf=new AlgorithmIdentifier({schema:t.result.prf}))}toSchema(){const e=[];return e.push(this.salt),e.push(new Integer({value:this.iterationCount})),bs in this&&PBKDF2Params.defaultValues(bs)!==this.keyLength&&e.push(new Integer({value:this.keyLength})),this.prf&&!1===PBKDF2Params.defaultValues(As).isEqual(this.prf)&&e.push(this.prf.toSchema()),new Sequence({value:e})}toJSON(){const e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return bs in this&&PBKDF2Params.defaultValues(bs)!==this.keyLength&&(e.keyLength=this.keyLength),this.prf&&!1===PBKDF2Params.defaultValues(As).isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}PBKDF2Params.CLASS_NAME="PBKDF2Params";const Cs="keyDerivationFunc",Vs="encryptionScheme",Bs=[Cs,Vs];class PBES2Params extends PkiObject{constructor(e={}){super(),this.keyDerivationFunc=getParametersValue(e,Cs,PBES2Params.defaultValues(Cs)),this.encryptionScheme=getParametersValue(e,Vs,PBES2Params.defaultValues(Vs)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Cs:case Vs:return new AlgorithmIdentifier;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[AlgorithmIdentifier.schema(t.keyDerivationFunc||{}),AlgorithmIdentifier.schema(t.encryptionScheme||{})]})}fromSchema(e){clearProps(e,Bs);const t=compareSchema(e,e,PBES2Params.schema({names:{keyDerivationFunc:{names:{blockName:Cs}},encryptionScheme:{names:{blockName:Vs}}}}));AsnError.assertSchema(t,this.className),this.keyDerivationFunc=new AlgorithmIdentifier({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new AlgorithmIdentifier({schema:t.result.encryptionScheme})}toSchema(){return new Sequence({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}PBES2Params.CLASS_NAME="PBES2Params";class AbstractCryptoEngine{constructor(e){this.crypto=e.crypto,this.subtle="webkitSubtle"in e.crypto?e.crypto.webkitSubtle:e.crypto.subtle,this.name=getParametersValue(e,"name",Ce)}async encrypt(...e){return this.subtle.encrypt(...e)}async decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}async verify(...e){return this.subtle.verify(...e)}async digest(...e){return this.subtle.digest(...e)}async generateKey(...e){return this.subtle.generateKey(...e)}async deriveKey(...e){return this.subtle.deriveKey(...e)}async deriveBits(...e){return this.subtle.deriveBits(...e)}async wrapKey(...e){return this.subtle.wrapKey(...e)}async unwrapKey(...e){return this.subtle.unwrapKey(...e)}exportKey(...e){return this.subtle.exportKey(...e)}importKey(...e){return this.subtle.importKey(...e)}getRandomValues(e){return this.crypto.getRandomValues(e)}}async function makePKCS12B2Key(e,t,r,s,a){let i,n,o;switch(e.toUpperCase()){case"SHA-1":i=20,n=64,o=oe;break;case"SHA-256":i=32,n=64,o=ve;break;case"SHA-384":i=48,n=128,o=Ae;break;case"SHA-512":i=64,n=128,o=be;break;default:throw new Error("Unsupported hashing algorithm")}const l=new Uint8Array(r);let c=(new TextDecoder).decode(r);(new TextEncoder).encode(c).some((e,t)=>e!==l[t])&&(c=String.fromCharCode(...l));const u=new Uint8Array(2*c.length+2),h=new DataView(u.buffer);for(let e=0;e<c.length;e++)h.setUint16(2*e,c.charCodeAt(e),!1);h.setUint16(2*c.length,0,!1);const m=new Uint8Array(n).fill(3),f=new Uint8Array(s),g=new Uint8Array(n*Math.ceil(f.length/n)).map((e,t)=>f[t%f.length]),d=new Uint8Array(n*Math.ceil(u.length/n)).map((e,t)=>u[t%u.length]);let p=new Uint8Array(g.length+d.length);p.set(g),p.set(d,g.length);const S=Math.ceil((t>>3)/i),y=[];for(let e=0;e<S;e++){let e=new Uint8Array(m.length+p.length);e.set(m),e.set(p,m.length);for(let t=0;t<a;t++)e=o(e);const t=new Uint8Array(n).map((t,r)=>e[r%e.length]),r=Math.ceil(f.length/n)+Math.ceil(u.length/n),s=[];for(let e=0;e<r;e++){const r=Array.from(p.slice(e*n,(e+1)*n));let a=511;for(let e=t.length-1;e>=0;e--)a>>=8,a+=t[e]+(r[e]||0),r[e]=255&a;s.push(...r)}p=new Uint8Array(s),y.push(...e)}return new Uint8Array(y.slice(0,t>>3)).buffer}function prepareAlgorithm(e){const t="string"==typeof e?{name:e}:e;return"hash"in t?{...t,hash:prepareAlgorithm(t.hash)}:t}class CryptoEngine extends AbstractCryptoEngine{async importKey(e,t,r,s,a){var i,n,o,l,c,u;let h={};const m=prepareAlgorithm(r);switch(e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,r,s,a);case"spki":{const e=fromBER(BufferSourceConverter.toArrayBuffer(t));AsnError.assert(e,"keyData");const r=new PublicKeyInfo;try{r.fromSchema(e.result)}catch{throw new ArgumentError("Incorrect keyData")}switch(m.name.toUpperCase()){case"RSA-PSS":if(!m.hash)throw new ParameterError("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(m.hash.name.toUpperCase()){case"SHA-1":h.alg="PS1";break;case"SHA-256":h.alg="PS256";break;case"SHA-384":h.alg="PS384";break;case"SHA-512":h.alg="PS512";break;default:throw new Error(`Incorrect hash algorithm: ${m.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(a=["verify"],h.kty="RSA",h.ext=s,h.key_ops=a,"1.2.840.113549.1.1.1"!==r.algorithm.algorithmId)throw new Error(`Incorrect public key algorithm: ${r.algorithm.algorithmId}`);if(!h.alg){if(!m.hash)throw new ParameterError("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(m.hash.name.toUpperCase()){case"SHA-1":h.alg="RS1";break;case"SHA-256":h.alg="RS256";break;case"SHA-384":h.alg="RS384";break;case"SHA-512":h.alg="RS512";break;default:throw new Error(`Incorrect hash algorithm: ${m.hash.name.toUpperCase()}`)}}const e=r.toJSON();Object.assign(h,e)}break;case"ECDSA":a=["verify"];case"ECDH":{if(h={kty:"EC",ext:s,key_ops:a},"1.2.840.10045.2.1"!==r.algorithm.algorithmId)throw new Error(`Incorrect public key algorithm: ${r.algorithm.algorithmId}`);const e=r.toJSON();Object.assign(h,e)}break;case"RSA-OAEP":{if(h.kty="RSA",h.ext=s,h.key_ops=a,"safari"===this.name.toLowerCase())h.alg="RSA-OAEP";else{if(!m.hash)throw new ParameterError("hash","algorithm.hash","Incorrect hash algorithm: Hash algorithm is missed");switch(m.hash.name.toUpperCase()){case"SHA-1":h.alg="RSA-OAEP";break;case"SHA-256":h.alg="RSA-OAEP-256";break;case"SHA-384":h.alg="RSA-OAEP-384";break;case"SHA-512":h.alg="RSA-OAEP-512";break;default:throw new Error(`Incorrect hash algorithm: ${m.hash.name.toUpperCase()}`)}}const e=r.toJSON();Object.assign(h,e)}break;case"RSAES-PKCS1-V1_5":{h.kty="RSA",h.ext=s,h.key_ops=a,h.alg="PS1";const e=r.toJSON();Object.assign(h,e)}break;default:throw new Error(`Incorrect algorithm name: ${m.name.toUpperCase()}`)}}break;case"pkcs8":{const e=new PrivateKeyInfo,r=fromBER(BufferSourceConverter.toArrayBuffer(t));AsnError.assert(r,"keyData");try{e.fromSchema(r.result)}catch(e){throw new Error("Incorrect keyData")}if(!e.parsedKey)throw new Error("Incorrect keyData");switch(m.name.toUpperCase()){case"RSA-PSS":switch(null===(i=m.hash)||void 0===i?void 0:i.name.toUpperCase()){case"SHA-1":h.alg="PS1";break;case"SHA-256":h.alg="PS256";break;case"SHA-384":h.alg="PS384";break;case"SHA-512":h.alg="PS512";break;default:throw new Error(`Incorrect hash algorithm: ${null===(n=m.hash)||void 0===n?void 0:n.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(a=["sign"],h.kty="RSA",h.ext=s,h.key_ops=a,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)throw new Error(`Incorrect private key algorithm: ${e.privateKeyAlgorithm.algorithmId}`);if("alg"in h==!1)switch(null===(o=m.hash)||void 0===o?void 0:o.name.toUpperCase()){case"SHA-1":h.alg="RS1";break;case"SHA-256":h.alg="RS256";break;case"SHA-384":h.alg="RS384";break;case"SHA-512":h.alg="RS512";break;default:throw new Error(`Incorrect hash algorithm: ${null===(l=m.hash)||void 0===l?void 0:l.name.toUpperCase()}`)}const t=e.toJSON();Object.assign(h,t)}break;case"ECDSA":a=["sign"];case"ECDH":{if(h={kty:"EC",ext:s,key_ops:a},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)throw new Error(`Incorrect algorithm: ${e.privateKeyAlgorithm.algorithmId}`);const t=e.toJSON();Object.assign(h,t)}break;case"RSA-OAEP":{if(h.kty="RSA",h.ext=s,h.key_ops=a,"safari"===this.name.toLowerCase())h.alg="RSA-OAEP";else switch(null===(c=m.hash)||void 0===c?void 0:c.name.toUpperCase()){case"SHA-1":h.alg="RSA-OAEP";break;case"SHA-256":h.alg="RSA-OAEP-256";break;case"SHA-384":h.alg="RSA-OAEP-384";break;case"SHA-512":h.alg="RSA-OAEP-512";break;default:throw new Error(`Incorrect hash algorithm: ${null===(u=m.hash)||void 0===u?void 0:u.name.toUpperCase()}`)}const t=e.toJSON();Object.assign(h,t)}break;case"RSAES-PKCS1-V1_5":{a=["decrypt"],h.kty="RSA",h.ext=s,h.key_ops=a,h.alg="PS1";const t=e.toJSON();Object.assign(h,t)}break;default:throw new Error(`Incorrect algorithm name: ${m.name.toUpperCase()}`)}}break;case"jwk":h=t;break;default:throw new Error(`Incorrect format: ${e}`)}if("safari"===this.name.toLowerCase())try{return this.subtle.importKey("jwk",stringToArrayBuffer(JSON.stringify(h)),r,s,a)}catch{return this.subtle.importKey("jwk",h,r,s,a)}return this.subtle.importKey("jwk",h,r,s,a)}async exportKey(e,t){let r=await this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&r instanceof ArrayBuffer&&(r=JSON.parse(arrayBufferToString(r))),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":{const e=new PublicKeyInfo;try{e.fromJSON(r)}catch(e){throw new Error("Incorrect key data")}return e.toSchema().toBER(!1)}case"pkcs8":{const e=new PrivateKeyInfo;try{e.fromJSON(r)}catch(e){throw new Error("Incorrect key data")}return e.toSchema().toBER(!1)}case"jwk":return r;default:throw new Error(`Incorrect format: ${e}`)}}async convert(e,t,r,s,a,i){if(e.toLowerCase()===t.toLowerCase())return r;const n=await this.importKey(e,r,s,a,i);return this.exportKey(t,n)}getAlgorithmByOID(e,t=!1,r){switch(e){case"1.2.840.113549.1.1.1":return{name:"RSAES-PKCS1-v1_5"};case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}if(t)throw new Error(`Unsupported algorithm identifier ${r?`for ${r} `:Ce}: ${e}`);return{}}getOIDByAlgorithm(e,t=!1,r){let s=Ce;switch(e.name.toUpperCase()){case"RSAES-PKCS1-V1_5":s="1.2.840.113549.1.1.1";break;case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.113549.1.1.5";break;case"SHA-256":s="1.2.840.113549.1.1.11";break;case"SHA-384":s="1.2.840.113549.1.1.12";break;case"SHA-512":s="1.2.840.113549.1.1.13"}break;case"RSA-PSS":s="1.2.840.113549.1.1.10";break;case"RSA-OAEP":s="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.10045.4.1";break;case"SHA-256":s="1.2.840.10045.4.3.2";break;case"SHA-384":s="1.2.840.10045.4.3.3";break;case"SHA-512":s="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":s="1.3.133.16.840.63.0.2";break;case"SHA-256":s="1.3.132.1.11.1";break;case"SHA-384":s="1.3.132.1.11.2";break;case"SHA-512":s="1.3.132.1.11.3"}break;case"AES-CTR":case"AES-CMAC":case"CONCAT":case"HKDF":break;case"AES-CBC":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.2";break;case 192:s="2.16.840.1.101.3.4.1.22";break;case 256:s="2.16.840.1.101.3.4.1.42"}break;case"AES-GCM":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.6";break;case 192:s="2.16.840.1.101.3.4.1.26";break;case 256:s="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.4";break;case 192:s="2.16.840.1.101.3.4.1.24";break;case 256:s="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:s="2.16.840.1.101.3.4.1.5";break;case 192:s="2.16.840.1.101.3.4.1.25";break;case 256:s="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":s="1.2.840.113549.2.7";break;case"SHA-256":s="1.2.840.113549.2.9";break;case"SHA-384":s="1.2.840.113549.2.10";break;case"SHA-512":s="1.2.840.113549.2.11"}break;case"DH":s="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":s="1.3.14.3.2.26";break;case"SHA-256":s="2.16.840.1.101.3.4.2.1";break;case"SHA-384":s="2.16.840.1.101.3.4.2.2";break;case"SHA-512":s="2.16.840.1.101.3.4.2.3";break;case"PBKDF2":s="1.2.840.113549.1.5.12";break;case"P-256":s="1.2.840.10045.3.1.7";break;case"P-384":s="1.3.132.0.34";break;case"P-521":s="1.3.132.0.35"}if(!s&&t)throw new Error(`Unsupported algorithm ${r?`for ${r} `:Ce}: ${e.name}`);return s}getAlgorithmParameters(e,t){let r={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSAES-PKCS1-V1_5":case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":r={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":r={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":r={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":r={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":r={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":r={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":r={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":r={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":if("derivekey"!==t.toLowerCase())return{algorithm:{name:"HKDF"},usages:[]};r={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;case"PBKDF2":if("derivekey"!==t.toLowerCase())return{algorithm:{name:"PBKDF2"},usages:[]};r={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]}}return r}getHashAlgorithm(e){let t=Ce;switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{const r=new RSASSAPSSParams({schema:e.algorithmParams});if(r.hashAlgorithm){const e=this.getAlgorithmByOID(r.hashAlgorithm.algorithmId);if(!("name"in e))return Ce;t=e.name}else t="SHA-1"}catch{}}return t}async encryptEncryptedContentInfo(e){ParameterError.assert(e,"password","contentEncryptionAlgorithm","hmacHashAlgorithm","iterationCount","contentToEncrypt","contentToEncrypt","contentType");const t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm,!0,"contentEncryptionAlgorithm"),r=this.getOIDByAlgorithm({name:"PBKDF2"},!0,"PBKDF2"),s=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),a=new ArrayBuffer(16),i=new Uint8Array(a);this.getRandomValues(i);const n=new ArrayBuffer(64),o=new Uint8Array(n);this.getRandomValues(o);const l=new Uint8Array(e.contentToEncrypt),c=new PBKDF2Params({salt:new OctetString({valueHex:n}),iterationCount:e.iterationCount,prf:new AlgorithmIdentifier({algorithmId:s,algorithmParams:new Null})}),u=new Uint8Array(e.password),h=await this.importKey("raw",u,"PBKDF2",!1,["deriveKey"]),m=await this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:o,iterations:e.iterationCount},h,e.contentEncryptionAlgorithm,!1,["encrypt"]),f=await this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:i},m,l),g=new PBES2Params({keyDerivationFunc:new AlgorithmIdentifier({algorithmId:r,algorithmParams:c.toSchema()}),encryptionScheme:new AlgorithmIdentifier({algorithmId:t,algorithmParams:new OctetString({valueHex:a})})});return new EncryptedContentInfo({contentType:e.contentType,contentEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:g.toSchema()}),encryptedContent:new OctetString({valueHex:f})})}async decryptEncryptedContentInfo(e){if(ParameterError.assert(e,"password","encryptedContentInfo"),"1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)throw new Error(`Unknown "contentEncryptionAlgorithm": ${e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);let t,r;try{t=new PBES2Params({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "pbes2Parameters"')}try{r=new PBKDF2Params({schema:t.keyDerivationFunc.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "pbkdf2Params"')}const s=this.getAlgorithmByOID(t.encryptionScheme.algorithmId,!0),a=t.encryptionScheme.algorithmParams.valueBlock.valueHex,i=new Uint8Array(a),n=r.salt.valueBlock.valueHex,o=new Uint8Array(n),l=r.iterationCount;let c="SHA-1";if(r.prf){c=this.getAlgorithmByOID(r.prf.algorithmId,!0).hash.name}const u=await this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),h=await this.deriveKey({name:"PBKDF2",hash:{name:c},salt:o,iterations:l},u,s,!1,["decrypt"]),m=e.encryptedContentInfo.getEncryptedContent();return this.decrypt({name:s.name,iv:i},h,m)}async stampDataWithPassword(e){if(e instanceof Object==!1)throw new Error('Parameters must have type "Object"');let t;switch(ParameterError.assert(e,"password","hashAlgorithm","iterationCount","salt","contentToStamp"),e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}const r={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},s=await makePKCS12B2Key(e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),a=await this.importKey("raw",new Uint8Array(s),r,!1,["sign"]);return this.sign(r,a,new Uint8Array(e.contentToStamp))}async verifyDataStampedWithPassword(e){ParameterError.assert(e,"password","hashAlgorithm","salt","iterationCount","contentToVerify","signatureToVerify");let t=0;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:throw new Error(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}const r={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}},s=await makePKCS12B2Key(e.hashAlgorithm,t,e.password,e.salt,e.iterationCount),a=await this.importKey("raw",new Uint8Array(s),r,!1,["verify"]);return this.verify(r,a,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify))}async getSignatureParameters(e,t="SHA-1"){this.getOIDByAlgorithm({name:t},!0,"hashAlgorithm");const r=new AlgorithmIdentifier,s=this.getAlgorithmParameters(e.algorithm.name,"sign");if(!Object.keys(s.algorithm).length)throw new Error("Parameter 'algorithm' is empty");const a=s.algorithm;switch("hash"in e.algorithm&&e.algorithm.hash&&e.algorithm.hash.name?a.hash.name=e.algorithm.hash.name:a.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":r.algorithmId=this.getOIDByAlgorithm(a,!0);break;case"RSA-PSS":{switch(a.hash.name.toUpperCase()){case"SHA-256":a.saltLength=32;break;case"SHA-384":a.saltLength=48;break;case"SHA-512":a.saltLength=64}const e={};if("SHA-1"!==a.hash.name.toUpperCase()){const t=this.getOIDByAlgorithm({name:a.hash.name},!0,"hashAlgorithm");e.hashAlgorithm=new AlgorithmIdentifier({algorithmId:t,algorithmParams:new Null}),e.maskGenAlgorithm=new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==a.saltLength&&(e.saltLength=a.saltLength);const t=new RSASSAPSSParams(e);r.algorithmId="1.2.840.113549.1.1.10",r.algorithmParams=t.toSchema()}break;default:throw new Error(`Unsupported signature algorithm: ${e.algorithm.name}`)}return{signatureAlgorithm:r,parameters:s}}async signWithPrivateKey(e,t,r){const s=await this.sign(r.algorithm,t,e);return"ECDSA"===r.algorithm.name?function(e){if(e.byteLength%2!=0)return ke;const t=e.byteLength/2,r=new ArrayBuffer(t);new Uint8Array(r).set(new Uint8Array(e,0,t));const s=new Integer({valueHex:r}),a=new ArrayBuffer(t);new Uint8Array(a).set(new Uint8Array(e,t,t));const i=new Integer({valueHex:a});return new Sequence({value:[s.convertToDER(),i.convertToDER()]}).toBER(!1)}(s):s}fillPublicKeyParameters(e,t){const r={},s=this.getHashAlgorithm(t);if(s===Ce)throw new Error(`Unsupported signature algorithm: ${t.algorithmId}`);let a;a="1.2.840.113549.1.1.10"===t.algorithmId?t.algorithmId:e.algorithm.algorithmId;const i=this.getAlgorithmByOID(a,!0);if(r.algorithm=this.getAlgorithmParameters(i.name,"importKey"),"hash"in r.algorithm.algorithm&&(r.algorithm.algorithm.hash.name=s),"ECDSA"===i.name){const t=e.algorithm;if(!t.algorithmParams)throw new Error("Algorithm parameters for ECDSA public key are missed");const s=t.algorithmParams;if("idBlock"in t.algorithmParams&&(1!==s.idBlock.tagClass||6!==s.idBlock.tagNumber))throw new Error("Incorrect type for ECDSA public key parameters");const a=this.getAlgorithmByOID(s.valueBlock.toString(),!0);r.algorithm.algorithm.namedCurve=a.name}return r}async getPublicKey(e,t,r){r||(r=this.fillPublicKeyParameters(e,t));const s=e.toSchema().toBER(!1);return this.importKey("spki",s,r.algorithm.algorithm,!0,r.algorithm.usages)}async verifyWithPublicKey(e,t,r,s,a){let i;if(a){const e={};let t;t="1.2.840.113549.1.1.10"===s.algorithmId?s.algorithmId:r.algorithm.algorithmId;const n=this.getAlgorithmByOID(t,!0);if(e.algorithm=this.getAlgorithmParameters(n.name,"importKey"),"hash"in e.algorithm.algorithm&&(e.algorithm.algorithm.hash.name=a),"ECDSA"===n.name){let t=!1;if("algorithmParams"in r.algorithm==!0&&"idBlock"in r.algorithm.algorithmParams&&1===r.algorithm.algorithmParams.idBlock.tagClass&&6===r.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)throw new Error("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(r.algorithm.algorithmParams.valueBlock.toString(),!0);e.algorithm.algorithm.namedCurve=s.name}i=await this.getPublicKey(r,null,e)}else{if(!(a=this.getHashAlgorithm(s)))throw new Error(`Unsupported signature algorithm: ${s.algorithmId}`);i=await this.getPublicKey(r,s)}const n=this.getAlgorithmParameters(i.algorithm.name,"verify");"hash"in n.algorithm&&(n.algorithm.hash.name=a);let o=t.valueBlock.valueHexView;if("ECDSA"===i.algorithm.name){const e=ECNamedCurves.find(i.algorithm.namedCurve);if(!e)throw new Error("Unsupported named curve in use");const t=fromBER(o);AsnError.assert(t,"Signature value"),o=function(e,t){if(!(e instanceof Sequence&&2===e.valueBlock.value.length&&e.valueBlock.value[0]instanceof Integer&&e.valueBlock.value[1]instanceof Integer))return ke;const r=e.valueBlock.value[0].convertFromDER().valueBlock.valueHexView,s=e.valueBlock.value[1].convertFromDER().valueBlock.valueHexView,a=new Uint8Array(2*t);return a.set(r,t-r.byteLength),a.set(s,2*t-s.byteLength),a.buffer}(t.result,e.size)}if("RSA-PSS"===i.algorithm.name){const e=new RSASSAPSSParams({schema:s.algorithmParams});n.algorithm.saltLength="saltLength"in e?e.saltLength:20;let t="SHA-1";if("hashAlgorithm"in e){t=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId,!0).name}n.algorithm.hash.name=t}return this.verify(n.algorithm,i,o,e)}}let Is={name:"none",crypto:null};function isCryptoEngine(e){return!(!e||"object"!=typeof e||!("crypto"in e))}function setEngine(e,...t){let r=null;if(t.length<2)r=t.length?t[0]:"undefined"!=typeof self&&self.crypto?new CryptoEngine({name:"browser",crypto:self.crypto}):null;else{const e=t[0],s=t[1];isCryptoEngine(s)?r=s:isCryptoEngine(e)?r=e:"subtle"in e&&"getRandomValues"in e&&(r=new CryptoEngine({crypto:e}))}if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){if(void 0===global[process.pid])global[process.pid]={};else if("object"!=typeof global[process.pid])throw new Error(`Name global.${process.pid} already exists and it is not an object`);if(void 0===global[process.pid].pkijs)global[process.pid].pkijs={};else if("object"!=typeof global[process.pid].pkijs)throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);global[process.pid].pkijs.engine={name:e,crypto:r}}else Is={name:e,crypto:r}}function getCrypto(e=!1){const t=function(){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){let e;try{e=global[process.pid].pkijs.engine}catch(e){throw new Error("Please call 'setEngine' before call to 'getEngine'")}return e}return Is}();if(!t.crypto&&e)throw new Error("Unable to create WebCrypto object");return t.crypto}async function kdfWithCounter(e,t,r,s,a){switch(e.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":break;default:throw new ArgumentError(`Unknown hash function: ${e}`)}if(ArgumentError.assert(t,"zBuffer","ArrayBuffer"),0===t.byteLength)throw new ArgumentError("'zBuffer' has zero length, error");if(ArgumentError.assert(s,"SharedInfo","ArrayBuffer"),r>255)throw new ArgumentError("Please set 'Counter' argument to value less or equal to 255");const i=new ArrayBuffer(4),n=new Uint8Array(i);n[0]=0,n[1]=0,n[2]=0,n[3]=r;let o=ke;o=utilConcatBuf(o,t),o=utilConcatBuf(o,i),o=utilConcatBuf(o,s);return{counter:r,result:await a.digest({name:e},o)}}async function kdf(e,t,r,s,a=getCrypto(!0)){let i=0,n=1;switch(e.toUpperCase()){case"SHA-1":i=160;break;case"SHA-256":i=256;break;case"SHA-384":i=384;break;case"SHA-512":i=512;break;default:throw new ArgumentError(`Unknown hash function: ${e}`)}if(ArgumentError.assert(t,"Zbuffer","ArrayBuffer"),0===t.byteLength)throw new ArgumentError("'Zbuffer' has zero length, error");ArgumentError.assert(s,"SharedInfo","ArrayBuffer");const o=r/i;Math.floor(o)>0&&(n=Math.floor(o),o-n>0&&n++);const l=[];for(let r=1;r<=n;r++)l.push(await kdfWithCounter(e,t,r,s,a));let c=ke,u=1,h=!0;for(;h;){h=!1;for(const e of l)if(e.counter===u){c=utilConcatBuf(c,e.result),h=!0;break}u++}if(r>>=3,c.byteLength>r){const e=new ArrayBuffer(r),t=new Uint8Array(e),s=new Uint8Array(c);for(let e=0;e<r;e++)t[e]=s[e];return e}return c}const Ns="version",Ps="logID",Es="extensions",Ds="timestamp",Os="hashAlgorithm",xs="signatureAlgorithm",Rs="signature",Ks="none",Us="sha1",Ts="sha224",Ls="sha256",Hs="sha384",qs="sha512",js="anonymous",Ms="ecdsa";class SignedCertificateTimestamp extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Ns,SignedCertificateTimestamp.defaultValues(Ns)),this.logID=getParametersValue(e,Ps,SignedCertificateTimestamp.defaultValues(Ps)),this.timestamp=getParametersValue(e,Ds,SignedCertificateTimestamp.defaultValues(Ds)),this.extensions=getParametersValue(e,Es,SignedCertificateTimestamp.defaultValues(Es)),this.hashAlgorithm=getParametersValue(e,Os,SignedCertificateTimestamp.defaultValues(Os)),this.signatureAlgorithm=getParametersValue(e,xs,SignedCertificateTimestamp.defaultValues(xs)),this.signature=getParametersValue(e,Rs,SignedCertificateTimestamp.defaultValues(Rs)),"stream"in e&&e.stream&&this.fromStream(e.stream),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ns:return 0;case Ps:case Es:return ke;case Ds:return new Date(0);case Os:case xs:return Ce;case Rs:return new Any;default:return super.defaultValues(e)}}fromSchema(e){if(e instanceof RawData==!1)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");const t=new SeqStream({stream:new ByteStream({buffer:e.data})});this.fromStream(t)}fromStream(e){const t=e.getUint16();if(this.version=e.getBlock(1)[0],0===this.version){this.logID=new Uint8Array(e.getBlock(32)).buffer.slice(0),this.timestamp=new Date(utilFromBase(new Uint8Array(e.getBlock(8)),8));const r=e.getUint16();switch(this.extensions=new Uint8Array(e.getBlock(r)).buffer.slice(0),e.getBlock(1)[0]){case 0:this.hashAlgorithm=Ks;break;case 1:this.hashAlgorithm="md5";break;case 2:this.hashAlgorithm=Us;break;case 3:this.hashAlgorithm=Ts;break;case 4:this.hashAlgorithm=Ls;break;case 5:this.hashAlgorithm=Hs;break;case 6:this.hashAlgorithm=qs;break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}switch(e.getBlock(1)[0]){case 0:this.signatureAlgorithm=js;break;case 1:this.signatureAlgorithm="rsa";break;case 2:this.signatureAlgorithm="dsa";break;case 3:this.signatureAlgorithm=Ms;break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}const s=e.getUint16(),a=fromBER(new Uint8Array(e.getBlock(s)).buffer.slice(0));if(AsnError.assert(a,"SignedCertificateTimestamp"),this.signature=a.result,t!==47+r+s)throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}}toSchema(){const e=this.toStream();return new RawData({data:e.stream.buffer})}toStream(){const e=new SeqStream;e.appendUint16(47+this.extensions.byteLength+this.signature.valueBeforeDecodeView.byteLength),e.appendChar(this.version),e.appendView(new Uint8Array(this.logID));const t=new ArrayBuffer(8),r=new Uint8Array(t),s=utilToBase(this.timestamp.valueOf(),8);let a,i;switch(r.set(new Uint8Array(s),8-s.byteLength),e.appendView(r),e.appendUint16(this.extensions.byteLength),this.extensions.byteLength&&e.appendView(new Uint8Array(this.extensions)),this.hashAlgorithm.toLowerCase()){case Ks:a=0;break;case"md5":a=1;break;case Us:a=2;break;case Ts:a=3;break;case Ls:a=4;break;case Hs:a=5;break;case qs:a=6;break;default:throw new Error(`Incorrect data for hashAlgorithm: ${this.hashAlgorithm}`)}switch(e.appendChar(a),this.signatureAlgorithm.toLowerCase()){case js:i=0;break;case"rsa":i=1;break;case"dsa":i=2;break;case Ms:i=3;break;default:throw new Error(`Incorrect data for signatureAlgorithm: ${this.signatureAlgorithm}`)}e.appendChar(i);const n=this.signature.toBER(!1);return e.appendUint16(n.byteLength),e.appendView(new Uint8Array(n)),e}toJSON(){return{version:this.version,logID:bufferToHexCodes(this.logID),timestamp:this.timestamp,extensions:bufferToHexCodes(this.extensions),hashAlgorithm:this.hashAlgorithm,signatureAlgorithm:this.signatureAlgorithm,signature:this.signature.toJSON()}}async verify(e,t,r=0,s=getCrypto(!0)){const a=toBase64(arrayBufferToString(this.logID));let i=null;const n=new SeqStream;for(const t of e)if(t.log_id===a){i=t.key;break}if(!i)throw new Error(`Public key not found for CT with logId: ${a}`);const o=stringToArrayBuffer(fromBase64(i)),l=PublicKeyInfo.fromBER(o);n.appendChar(0),n.appendChar(0);const c=new ArrayBuffer(8),u=new Uint8Array(c),h=utilToBase(this.timestamp.valueOf(),8);return u.set(new Uint8Array(h),8-h.byteLength),n.appendView(u),n.appendUint16(r),0===r&&n.appendUint24(t.byteLength),n.appendView(new Uint8Array(t)),n.appendUint16(this.extensions.byteLength),0!==this.extensions.byteLength&&n.appendView(new Uint8Array(this.extensions)),s.verifyWithPublicKey(n.buffer.slice(0,n.length),new OctetString({valueHex:this.signature.toBER(!1)}),l,{algorithmId:Ce},"SHA-256")}}SignedCertificateTimestamp.CLASS_NAME="SignedCertificateTimestamp";const Js="timestamps";class SignedCertificateTimestampList extends PkiObject{constructor(e={}){super(),this.timestamps=getParametersValue(e,Js,SignedCertificateTimestampList.defaultValues(Js)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Js?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===Js?0===t.length:super.defaultValues(e)}static schema(e={}){var t;const r=getParametersValue(e,"names",{});return null!==(t=r.optional)&&void 0!==t||(r.optional=!1),new OctetString({name:r.blockName||"SignedCertificateTimestampList",optional:r.optional})}fromSchema(e){if(e instanceof OctetString==!1)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");const t=new SeqStream({stream:new ByteStream({buffer:e.valueBlock.valueHex})});if(t.getUint16()!==t.length)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");for(;t.length;)this.timestamps.push(new SignedCertificateTimestamp({stream:t}))}toSchema(){const e=new SeqStream;let t=0;const r=[];for(const e of this.timestamps){const s=e.toStream();r.push(s),t+=s.stream.buffer.byteLength}e.appendUint16(t);for(const t of r)e.appendView(t.stream.view);return new OctetString({valueHex:e.stream.buffer.slice(0)})}toJSON(){return{timestamps:Array.from(this.timestamps,e=>e.toJSON())}}}SignedCertificateTimestampList.CLASS_NAME="SignedCertificateTimestampList";const _s="attributes",Fs=[_s];class SubjectDirectoryAttributes extends PkiObject{constructor(e={}){super(),this.attributes=getParametersValue(e,_s,SubjectDirectoryAttributes.defaultValues(_s)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===_s?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.attributes||Ce,value:Attribute.schema()})]})}fromSchema(e){clearProps(e,Fs);const t=compareSchema(e,e,SubjectDirectoryAttributes.schema({names:{attributes:_s}}));AsnError.assertSchema(t,this.className),this.attributes=Array.from(t.result.attributes,e=>new Attribute({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}}SubjectDirectoryAttributes.CLASS_NAME="SubjectDirectoryAttributes";class ExtensionValueFactory{static getItems(){return this.types||(this.types={},ExtensionValueFactory.register(Ye,"SubjectAltName",AltName),ExtensionValueFactory.register(Xe,"IssuerAltName",AltName),ExtensionValueFactory.register(ct,"AuthorityKeyIdentifier",AuthorityKeyIdentifier),ExtensionValueFactory.register(et,"BasicConstraints",BasicConstraints),ExtensionValueFactory.register("1.3.6.1.4.1.311.21.1","MicrosoftCaVersion",CAVersion),ExtensionValueFactory.register(nt,"CertificatePolicies",CertificatePolicies),ExtensionValueFactory.register("1.3.6.1.4.1.311.21.10","CertificatePoliciesMicrosoft",CertificatePolicies),ExtensionValueFactory.register("1.3.6.1.4.1.311.21.7","MicrosoftCertTemplateV2",CertificateTemplate),ExtensionValueFactory.register(at,"CRLDistributionPoints",CRLDistributionPoints),ExtensionValueFactory.register(it,"FreshestCRL",CRLDistributionPoints),ExtensionValueFactory.register("2.5.29.37","ExtKeyUsage",ExtKeyUsage),ExtensionValueFactory.register(rt,"CertificateIssuer",GeneralNames),ExtensionValueFactory.register(ht,"AuthorityInfoAccess",InfoAccess),ExtensionValueFactory.register("1.3.6.1.5.5.7.1.11","SubjectInfoAccess",InfoAccess),ExtensionValueFactory.register(tt,"IssuingDistributionPoint",IssuingDistributionPoint),ExtensionValueFactory.register(st,"NameConstraints",NameConstraints),ExtensionValueFactory.register(ut,"PolicyConstraints",PolicyConstraints),ExtensionValueFactory.register(lt,"PolicyMappings",PolicyMappings),ExtensionValueFactory.register("2.5.29.16","PrivateKeyUsagePeriod",PrivateKeyUsagePeriod),ExtensionValueFactory.register("1.3.6.1.5.5.7.1.3","QCStatements",QCStatements),ExtensionValueFactory.register("1.3.6.1.4.1.11129.2.4.2","SignedCertificateTimestampList",SignedCertificateTimestampList),ExtensionValueFactory.register("2.5.29.9","SubjectDirectoryAttributes",SubjectDirectoryAttributes)),this.types}static fromBER(e,t){const r=fromBER(t);if(-1===r.offset)return null;const s=this.find(e);if(s)try{return new s.type({schema:r.result})}catch(t){const r=new s.type;return r.parsingError=`Incorrectly formatted value of extension ${s.name} (${e})`,r}return r.result}static find(e){return this.getItems()[e]||null}static register(e,t,r){this.getItems()[e]={name:t,type:r}}}const $s="extnID",Ws="critical",Gs="extnValue",zs="parsedValue",Qs=[$s,Ws,Gs];class Extension extends PkiObject{get parsedValue(){if(void 0===this._parsedValue){const e=ExtensionValueFactory.fromBER(this.extnID,this.extnValue.valueBlock.valueHexView);this._parsedValue=e}return this._parsedValue||void 0}set parsedValue(e){this._parsedValue=e}constructor(e={}){super(),this.extnID=getParametersValue(e,$s,Extension.defaultValues($s)),this.critical=getParametersValue(e,Ws,Extension.defaultValues(Ws)),this.extnValue=Gs in e?new OctetString({valueHex:e.extnValue}):Extension.defaultValues(Gs),zs in e&&(this.parsedValue=getParametersValue(e,zs,Extension.defaultValues(zs))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case $s:return Ce;case Ws:return!1;case Gs:return new OctetString;case zs:return{};default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.extnID||Ce}),new Boolean({name:t.critical||Ce,optional:!0}),new OctetString({name:t.extnValue||Ce})]})}fromSchema(e){clearProps(e,Qs);const t=compareSchema(e,e,Extension.schema({names:{extnID:$s,critical:Ws,extnValue:Gs}}));AsnError.assertSchema(t,this.className),this.extnID=t.result.extnID.valueBlock.toString(),Ws in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.extnID})),this.critical!==Extension.defaultValues(Ws)&&e.push(new Boolean({value:this.critical})),e.push(this.extnValue),new Sequence({value:e})}toJSON(){const e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==Extension.defaultValues(Ws)&&(e.critical=this.critical),this.parsedValue&&this.parsedValue.toJSON&&(e.parsedValue=this.parsedValue.toJSON()),e}}Extension.CLASS_NAME="Extension";const Zs="extensions",Ys=[Zs];class Extensions extends PkiObject{constructor(e={}){super(),this.extensions=getParametersValue(e,Zs,Extensions.defaultValues(Zs)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Zs?[]:super.defaultValues(e)}static schema(e={},t=!1){const r=getParametersValue(e,"names",{});return new Sequence({optional:t,name:r.blockName||Ce,value:[new Repeated({name:r.extensions||Ce,value:Extension.schema(r.extension||{})})]})}fromSchema(e){clearProps(e,Ys);const t=compareSchema(e,e,Extensions.schema({names:{extensions:Zs}}));AsnError.assertSchema(t,this.className),this.extensions=Array.from(t.result.extensions,e=>new Extension({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:this.extensions.map(e=>e.toJSON())}}}Extensions.CLASS_NAME="Extensions";const Xs="issuer",ea="serialNumber",ta="issuerUID",ra=[Xs,ea,ta];class IssuerSerial extends PkiObject{constructor(e={}){super(),this.issuer=getParametersValue(e,Xs,IssuerSerial.defaultValues(Xs)),this.serialNumber=getParametersValue(e,ea,IssuerSerial.defaultValues(ea)),ta in e&&(this.issuerUID=getParametersValue(e,ta,IssuerSerial.defaultValues(ta))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Xs:return new GeneralNames;case ea:return new Integer;case ta:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[GeneralNames.schema(t.issuer||{}),new Integer({name:t.serialNumber||Ce}),new BitString({optional:!0,name:t.issuerUID||Ce})]})}fromSchema(e){clearProps(e,ra);const t=compareSchema(e,e,IssuerSerial.schema({names:{issuer:{names:{blockName:Xs}},serialNumber:ea,issuerUID:ta}}));AsnError.assertSchema(t,this.className),this.issuer=new GeneralNames({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber,ta in t.result&&(this.issuerUID=t.result.issuerUID)}toSchema(){const e=new Sequence({value:[this.issuer.toSchema(),this.serialNumber]});return this.issuerUID&&e.valueBlock.value.push(this.issuerUID),e}toJSON(){const e={issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()};return this.issuerUID&&(e.issuerUID=this.issuerUID.toJSON()),e}}IssuerSerial.CLASS_NAME="IssuerSerial";const sa="version",aa="baseCertificateID",ia="subjectName",na="issuer",oa="signature",la="serialNumber",ca="attrCertValidityPeriod",ua="attributes",ha="issuerUniqueID",ma="extensions",fa=[sa,aa,ia,na,oa,la,ca,ua,ha,ma];class AttributeCertificateInfoV1 extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,sa,AttributeCertificateInfoV1.defaultValues(sa)),aa in e&&(this.baseCertificateID=getParametersValue(e,aa,AttributeCertificateInfoV1.defaultValues(aa))),ia in e&&(this.subjectName=getParametersValue(e,ia,AttributeCertificateInfoV1.defaultValues(ia))),this.issuer=getParametersValue(e,na,AttributeCertificateInfoV1.defaultValues(na)),this.signature=getParametersValue(e,oa,AttributeCertificateInfoV1.defaultValues(oa)),this.serialNumber=getParametersValue(e,la,AttributeCertificateInfoV1.defaultValues(la)),this.attrCertValidityPeriod=getParametersValue(e,ca,AttributeCertificateInfoV1.defaultValues(ca)),this.attributes=getParametersValue(e,ua,AttributeCertificateInfoV1.defaultValues(ua)),ha in e&&(this.issuerUniqueID=getParametersValue(e,ha,AttributeCertificateInfoV1.defaultValues(ha))),ma in e&&(this.extensions=getParametersValue(e,ma,AttributeCertificateInfoV1.defaultValues(ma))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case sa:return 0;case aa:return new IssuerSerial;case ia:case na:return new GeneralNames;case oa:return new AlgorithmIdentifier;case la:return new Integer;case ca:return new AttCertValidityPeriod;case ua:return[];case ha:return new BitString;case ma:return new Extensions;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||Ce}),new Choice({value:[new Constructed({name:t.baseCertificateID||Ce,idBlock:{tagClass:3,tagNumber:0},value:IssuerSerial.schema().valueBlock.value}),new Constructed({name:t.subjectName||Ce,idBlock:{tagClass:3,tagNumber:1},value:GeneralNames.schema().valueBlock.value})]}),GeneralNames.schema({names:{blockName:t.issuer||Ce}}),AlgorithmIdentifier.schema(t.signature||{}),new Integer({name:t.serialNumber||Ce}),AttCertValidityPeriod.schema(t.attrCertValidityPeriod||{}),new Sequence({name:t.attributes||Ce,value:[new Repeated({value:Attribute.schema()})]}),new BitString({optional:!0,name:t.issuerUniqueID||Ce}),Extensions.schema(t.extensions||{},!0)]})}fromSchema(e){clearProps(e,fa);const t=compareSchema(e,e,AttributeCertificateInfoV1.schema({names:{version:sa,baseCertificateID:aa,subjectName:ia,issuer:na,signature:{names:{blockName:oa}},serialNumber:la,attrCertValidityPeriod:{names:{blockName:ca}},attributes:ua,issuerUniqueID:ha,extensions:{names:{blockName:ma}}}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,aa in t.result&&(this.baseCertificateID=new IssuerSerial({schema:new Sequence({value:t.result.baseCertificateID.valueBlock.value})})),ia in t.result&&(this.subjectName=new GeneralNames({schema:new Sequence({value:t.result.subjectName.valueBlock.value})})),this.issuer=t.result.issuer,this.signature=new AlgorithmIdentifier({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new AttCertValidityPeriod({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,e=>new Attribute({schema:e})),ha in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),ma in t.result&&(this.extensions=new Extensions({schema:t.result.extensions}))}toSchema(){const e=new Sequence({value:[new Integer({value:this.version})]});return this.baseCertificateID&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.subjectName&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.subjectName.toSchema().valueBlock.value})),e.valueBlock.value.push(this.issuer.toSchema()),e.valueBlock.value.push(this.signature.toSchema()),e.valueBlock.value.push(this.serialNumber),e.valueBlock.value.push(this.attrCertValidityPeriod.toSchema()),e.valueBlock.value.push(new Sequence({value:Array.from(this.attributes,e=>e.toSchema())})),this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){const e={version:this.version};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.subjectName&&(e.subjectName=this.subjectName.toJSON()),e.issuer=this.issuer.toJSON(),e.signature=this.signature.toJSON(),e.serialNumber=this.serialNumber.toJSON(),e.attrCertValidityPeriod=this.attrCertValidityPeriod.toJSON(),e.attributes=Array.from(this.attributes,e=>e.toJSON()),this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}}AttributeCertificateInfoV1.CLASS_NAME="AttributeCertificateInfoV1";const ga="acinfo",da="signatureAlgorithm",pa="signatureValue",Sa=[ga,pa,da];class AttributeCertificateV1 extends PkiObject{constructor(e={}){super(),this.acinfo=getParametersValue(e,ga,AttributeCertificateV1.defaultValues(ga)),this.signatureAlgorithm=getParametersValue(e,da,AttributeCertificateV1.defaultValues(da)),this.signatureValue=getParametersValue(e,pa,AttributeCertificateV1.defaultValues(pa)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ga:return new AttributeCertificateInfoV1;case da:return new AlgorithmIdentifier;case pa:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[AttributeCertificateInfoV1.schema(t.acinfo||{}),AlgorithmIdentifier.schema(t.signatureAlgorithm||{}),new BitString({name:t.signatureValue||Ce})]})}fromSchema(e){clearProps(e,Sa);const t=compareSchema(e,e,AttributeCertificateV1.schema({names:{acinfo:{names:{blockName:ga}},signatureAlgorithm:{names:{blockName:da}},signatureValue:pa}}));AsnError.assertSchema(t,this.className),this.acinfo=new AttributeCertificateInfoV1({schema:t.result.acinfo}),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new Sequence({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}AttributeCertificateV1.CLASS_NAME="AttributeCertificateV1";const ya="digestedObjectType",wa="otherObjectTypeID",va="digestAlgorithm",ba="objectDigest",Aa=[ya,wa,va,ba];class ObjectDigestInfo extends PkiObject{constructor(e={}){super(),this.digestedObjectType=getParametersValue(e,ya,ObjectDigestInfo.defaultValues(ya)),wa in e&&(this.otherObjectTypeID=getParametersValue(e,wa,ObjectDigestInfo.defaultValues(wa))),this.digestAlgorithm=getParametersValue(e,va,ObjectDigestInfo.defaultValues(va)),this.objectDigest=getParametersValue(e,ba,ObjectDigestInfo.defaultValues(ba)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ya:return new Enumerated;case wa:return new ObjectIdentifier;case va:return new AlgorithmIdentifier;case ba:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Enumerated({name:t.digestedObjectType||Ce}),new ObjectIdentifier({optional:!0,name:t.otherObjectTypeID||Ce}),AlgorithmIdentifier.schema(t.digestAlgorithm||{}),new BitString({name:t.objectDigest||Ce})]})}fromSchema(e){clearProps(e,Aa);const t=compareSchema(e,e,ObjectDigestInfo.schema({names:{digestedObjectType:ya,otherObjectTypeID:wa,digestAlgorithm:{names:{blockName:va}},objectDigest:ba}}));AsnError.assertSchema(t,this.className),this.digestedObjectType=t.result.digestedObjectType,wa in t.result&&(this.otherObjectTypeID=t.result.otherObjectTypeID),this.digestAlgorithm=new AlgorithmIdentifier({schema:t.result.digestAlgorithm}),this.objectDigest=t.result.objectDigest}toSchema(){const e=new Sequence({value:[this.digestedObjectType]});return this.otherObjectTypeID&&e.valueBlock.value.push(this.otherObjectTypeID),e.valueBlock.value.push(this.digestAlgorithm.toSchema()),e.valueBlock.value.push(this.objectDigest),e}toJSON(){const e={digestedObjectType:this.digestedObjectType.toJSON(),digestAlgorithm:this.digestAlgorithm.toJSON(),objectDigest:this.objectDigest.toJSON()};return this.otherObjectTypeID&&(e.otherObjectTypeID=this.otherObjectTypeID.toJSON()),e}}ObjectDigestInfo.CLASS_NAME="ObjectDigestInfo";const ka="issuerName",Ca="baseCertificateID",Va="objectDigestInfo",Ba=[ka,Ca,Va];class V2Form extends PkiObject{constructor(e={}){super(),ka in e&&(this.issuerName=getParametersValue(e,ka,V2Form.defaultValues(ka))),Ca in e&&(this.baseCertificateID=getParametersValue(e,Ca,V2Form.defaultValues(Ca))),Va in e&&(this.objectDigestInfo=getParametersValue(e,Va,V2Form.defaultValues(Va))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ka:return new GeneralNames;case Ca:return new IssuerSerial;case Va:return new ObjectDigestInfo;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[GeneralNames.schema({names:{blockName:t.issuerName}},!0),new Constructed({optional:!0,name:t.baseCertificateID||Ce,idBlock:{tagClass:3,tagNumber:0},value:IssuerSerial.schema().valueBlock.value}),new Constructed({optional:!0,name:t.objectDigestInfo||Ce,idBlock:{tagClass:3,tagNumber:1},value:ObjectDigestInfo.schema().valueBlock.value})]})}fromSchema(e){clearProps(e,Ba);const t=compareSchema(e,e,V2Form.schema({names:{issuerName:ka,baseCertificateID:Ca,objectDigestInfo:Va}}));AsnError.assertSchema(t,this.className),ka in t.result&&(this.issuerName=new GeneralNames({schema:t.result.issuerName})),Ca in t.result&&(this.baseCertificateID=new IssuerSerial({schema:new Sequence({value:t.result.baseCertificateID.valueBlock.value})})),Va in t.result&&(this.objectDigestInfo=new ObjectDigestInfo({schema:new Sequence({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){const e=new Sequence;return this.issuerName&&e.valueBlock.value.push(this.issuerName.toSchema()),this.baseCertificateID&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){const e={};return this.issuerName&&(e.issuerName=this.issuerName.toJSON()),this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}V2Form.CLASS_NAME="V2Form";const Ia="baseCertificateID",Na="entityName",Pa="objectDigestInfo",Ea=[Ia,Na,Pa];class Holder extends PkiObject{constructor(e={}){super(),Ia in e&&(this.baseCertificateID=getParametersValue(e,Ia,Holder.defaultValues(Ia))),Na in e&&(this.entityName=getParametersValue(e,Na,Holder.defaultValues(Na))),Pa in e&&(this.objectDigestInfo=getParametersValue(e,Pa,Holder.defaultValues(Pa))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ia:return new IssuerSerial;case Na:return new GeneralNames;case Pa:return new ObjectDigestInfo;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Constructed({optional:!0,name:t.baseCertificateID||Ce,idBlock:{tagClass:3,tagNumber:0},value:IssuerSerial.schema().valueBlock.value}),new Constructed({optional:!0,name:t.entityName||Ce,idBlock:{tagClass:3,tagNumber:1},value:GeneralNames.schema().valueBlock.value}),new Constructed({optional:!0,name:t.objectDigestInfo||Ce,idBlock:{tagClass:3,tagNumber:2},value:ObjectDigestInfo.schema().valueBlock.value})]})}fromSchema(e){clearProps(e,Ea);const t=compareSchema(e,e,Holder.schema({names:{baseCertificateID:Ia,entityName:Na,objectDigestInfo:Pa}}));AsnError.assertSchema(t,this.className),Ia in t.result&&(this.baseCertificateID=new IssuerSerial({schema:new Sequence({value:t.result.baseCertificateID.valueBlock.value})})),Na in t.result&&(this.entityName=new GeneralNames({schema:new Sequence({value:t.result.entityName.valueBlock.value})})),Pa in t.result&&(this.objectDigestInfo=new ObjectDigestInfo({schema:new Sequence({value:t.result.objectDigestInfo.valueBlock.value})}))}toSchema(){const e=new Sequence;return this.baseCertificateID&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),this.entityName&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.entityName.toSchema().valueBlock.value})),this.objectDigestInfo&&e.valueBlock.value.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){const e={};return this.baseCertificateID&&(e.baseCertificateID=this.baseCertificateID.toJSON()),this.entityName&&(e.entityName=this.entityName.toJSON()),this.objectDigestInfo&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}Holder.CLASS_NAME="Holder";const Da="version",Oa="holder",xa="issuer",Ra="signature",Ka="serialNumber",Ua="attrCertValidityPeriod",Ta="attributes",La="issuerUniqueID",Ha="extensions",qa=[Da,Oa,xa,Ra,Ka,Ua,Ta,La,Ha];class AttributeCertificateInfoV2 extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Da,AttributeCertificateInfoV2.defaultValues(Da)),this.holder=getParametersValue(e,Oa,AttributeCertificateInfoV2.defaultValues(Oa)),this.issuer=getParametersValue(e,xa,AttributeCertificateInfoV2.defaultValues(xa)),this.signature=getParametersValue(e,Ra,AttributeCertificateInfoV2.defaultValues(Ra)),this.serialNumber=getParametersValue(e,Ka,AttributeCertificateInfoV2.defaultValues(Ka)),this.attrCertValidityPeriod=getParametersValue(e,Ua,AttributeCertificateInfoV2.defaultValues(Ua)),this.attributes=getParametersValue(e,Ta,AttributeCertificateInfoV2.defaultValues(Ta)),La in e&&(this.issuerUniqueID=getParametersValue(e,La,AttributeCertificateInfoV2.defaultValues(La))),Ha in e&&(this.extensions=getParametersValue(e,Ha,AttributeCertificateInfoV2.defaultValues(Ha))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Da:return 1;case Oa:return new Holder;case xa:return{};case Ra:return new AlgorithmIdentifier;case Ka:return new Integer;case Ua:return new AttCertValidityPeriod;case Ta:return[];case La:return new BitString;case Ha:return new Extensions;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||Ce}),Holder.schema(t.holder||{}),new Choice({value:[GeneralNames.schema({names:{blockName:t.issuer||Ce}}),new Constructed({name:t.issuer||Ce,idBlock:{tagClass:3,tagNumber:0},value:V2Form.schema().valueBlock.value})]}),AlgorithmIdentifier.schema(t.signature||{}),new Integer({name:t.serialNumber||Ce}),AttCertValidityPeriod.schema(t.attrCertValidityPeriod||{}),new Sequence({name:t.attributes||Ce,value:[new Repeated({value:Attribute.schema()})]}),new BitString({optional:!0,name:t.issuerUniqueID||Ce}),Extensions.schema(t.extensions||{},!0)]})}fromSchema(e){clearProps(e,qa);const t=compareSchema(e,e,AttributeCertificateInfoV2.schema({names:{version:Da,holder:{names:{blockName:Oa}},issuer:xa,signature:{names:{blockName:Ra}},serialNumber:Ka,attrCertValidityPeriod:{names:{blockName:Ua}},attributes:Ta,issuerUniqueID:La,extensions:{names:{blockName:Ha}}}}));if(AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.holder=new Holder({schema:t.result.holder}),3!==t.result.issuer.idBlock.tagClass)throw new Error("Incorrect value for 'issuer' in AttributeCertificateInfoV2");this.issuer=new V2Form({schema:new Sequence({value:t.result.issuer.valueBlock.value})}),this.signature=new AlgorithmIdentifier({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new AttCertValidityPeriod({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,e=>new Attribute({schema:e})),La in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),Ha in t.result&&(this.extensions=new Extensions({schema:t.result.extensions}))}toSchema(){const e=new Sequence({value:[new Integer({value:this.version}),this.holder.toSchema(),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.issuer.toSchema().valueBlock.value}),this.signature.toSchema(),this.serialNumber,this.attrCertValidityPeriod.toSchema(),new Sequence({value:Array.from(this.attributes,e=>e.toSchema())})]});return this.issuerUniqueID&&e.valueBlock.value.push(this.issuerUniqueID),this.extensions&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){const e={version:this.version,holder:this.holder.toJSON(),issuer:this.issuer.toJSON(),signature:this.signature.toJSON(),serialNumber:this.serialNumber.toJSON(),attrCertValidityPeriod:this.attrCertValidityPeriod.toJSON(),attributes:Array.from(this.attributes,e=>e.toJSON())};return this.issuerUniqueID&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),this.extensions&&(e.extensions=this.extensions.toJSON()),e}}AttributeCertificateInfoV2.CLASS_NAME="AttributeCertificateInfoV2";const ja="acinfo",Ma="signatureAlgorithm",Ja="signatureValue",_a=[ja,Ma,Ja];class AttributeCertificateV2 extends PkiObject{constructor(e={}){super(),this.acinfo=getParametersValue(e,ja,AttributeCertificateV2.defaultValues(ja)),this.signatureAlgorithm=getParametersValue(e,Ma,AttributeCertificateV2.defaultValues(Ma)),this.signatureValue=getParametersValue(e,Ja,AttributeCertificateV2.defaultValues(Ja)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ja:return new AttributeCertificateInfoV2;case Ma:return new AlgorithmIdentifier;case Ja:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[AttributeCertificateInfoV2.schema(t.acinfo||{}),AlgorithmIdentifier.schema(t.signatureAlgorithm||{}),new BitString({name:t.signatureValue||Ce})]})}fromSchema(e){clearProps(e,_a);const t=compareSchema(e,e,AttributeCertificateV2.schema({names:{acinfo:{names:{blockName:ja}},signatureAlgorithm:{names:{blockName:Ma}},signatureValue:Ja}}));AsnError.assertSchema(t,this.className),this.acinfo=new AttributeCertificateInfoV2({schema:t.result.acinfo}),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new Sequence({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}AttributeCertificateV2.CLASS_NAME="AttributeCertificateV2";const Fa="contentType",$a="content",Wa=[Fa,$a];class ContentInfo extends PkiObject{constructor(e={}){super(),this.contentType=getParametersValue(e,Fa,ContentInfo.defaultValues(Fa)),this.content=getParametersValue(e,$a,ContentInfo.defaultValues($a)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Fa:return Ce;case $a:return new Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Fa:return"string"==typeof t&&t===this.defaultValues(Fa);case $a:return t instanceof Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return"optional"in t==!1&&(t.optional=!1),new Sequence({name:t.blockName||"ContentInfo",optional:t.optional,value:[new ObjectIdentifier({name:t.contentType||Fa}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.content||$a})]})]})}fromSchema(e){clearProps(e,Wa);const t=compareSchema(e,e,ContentInfo.schema());AsnError.assertSchema(t,this.className),this.contentType=t.result.contentType.valueBlock.toString(),this.content=t.result.content}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.contentType}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.content]})]})}toJSON(){const e={contentType:this.contentType};return this.content instanceof Any||(e.content=this.content.toJSON()),e}}ContentInfo.CLASS_NAME="ContentInfo",ContentInfo.DATA=mt,ContentInfo.SIGNED_DATA=ft,ContentInfo.ENVELOPED_DATA=gt,ContentInfo.ENCRYPTED_DATA=dt;const Ga="type",za="value",Qa="utcTimeName",Za="generalTimeName",Ya=[Qa,Za];var Xa;!function(e){e[e.UTCTime=0]="UTCTime",e[e.GeneralizedTime=1]="GeneralizedTime",e[e.empty=2]="empty"}(Xa||(Xa={}));class Time extends PkiObject{constructor(e={}){super(),this.type=getParametersValue(e,Ga,Time.defaultValues(Ga)),this.value=getParametersValue(e,za,Time.defaultValues(za)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ga:return 0;case za:return new Date(0,0,0);default:return super.defaultValues(e)}}static schema(e={},t=!1){const r=getParametersValue(e,"names",{});return new Choice({optional:t,value:[new UTCTime({name:r.utcTimeName||Ce}),new GeneralizedTime({name:r.generalTimeName||Ce})]})}fromSchema(e){clearProps(e,Ya);const t=compareSchema(e,e,Time.schema({names:{utcTimeName:Qa,generalTimeName:Za}}));AsnError.assertSchema(t,this.className),Qa in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),Za in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){return 0===this.type?new UTCTime({valueDate:this.value}):1===this.type?new GeneralizedTime({valueDate:this.value}):{}}toJSON(){return{type:this.type,value:this.value}}}Time.CLASS_NAME="Time";const ei="tbs",ti="version",ri="serialNumber",si="signature",ai="issuer",ii="notBefore",ni="notAfter",oi="subject",li="subjectPublicKeyInfo",ci="issuerUniqueID",ui="subjectUniqueID",hi="extensions",mi="signatureAlgorithm",fi="signatureValue",gi="tbsCertificate",di=`${gi}.${ti}`,pi=`${gi}.${ri}`,Si=`${gi}.${si}`,yi=`${gi}.${ai}`,wi=`${gi}.${ii}`,vi=`${gi}.${ni}`,bi=`${gi}.${oi}`,Ai=`${gi}.${li}`,ki=`${gi}.${ci}`,Ci=`${gi}.${ui}`,Vi=`${gi}.${hi}`,Bi=[gi,di,pi,Si,yi,wi,vi,bi,Ai,ki,Ci,Vi,mi,fi];function tbsCertificate(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||gi,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Integer({name:t.tbsCertificateVersion||di})]}),new Integer({name:t.tbsCertificateSerialNumber||pi}),AlgorithmIdentifier.schema(t.signature||{names:{blockName:Si}}),RelativeDistinguishedNames.schema(t.issuer||{names:{blockName:yi}}),new Sequence({name:t.tbsCertificateValidity||"tbsCertificate.validity",value:[Time.schema(t.notBefore||{names:{utcTimeName:wi,generalTimeName:wi}}),Time.schema(t.notAfter||{names:{utcTimeName:vi,generalTimeName:vi}})]}),RelativeDistinguishedNames.schema(t.subject||{names:{blockName:bi}}),PublicKeyInfo.schema(t.subjectPublicKeyInfo||{names:{blockName:Ai}}),new Primitive({name:t.tbsCertificateIssuerUniqueID||ki,optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new Primitive({name:t.tbsCertificateSubjectUniqueID||Ci,optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[Extensions.schema(t.extensions||{names:{blockName:Vi}})]})]})}class Certificate extends PkiObject{get tbs(){return BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(getParametersValue(e,ei,Certificate.defaultValues(ei))),this.version=getParametersValue(e,ti,Certificate.defaultValues(ti)),this.serialNumber=getParametersValue(e,ri,Certificate.defaultValues(ri)),this.signature=getParametersValue(e,si,Certificate.defaultValues(si)),this.issuer=getParametersValue(e,ai,Certificate.defaultValues(ai)),this.notBefore=getParametersValue(e,ii,Certificate.defaultValues(ii)),this.notAfter=getParametersValue(e,ni,Certificate.defaultValues(ni)),this.subject=getParametersValue(e,oi,Certificate.defaultValues(oi)),this.subjectPublicKeyInfo=getParametersValue(e,li,Certificate.defaultValues(li)),ci in e&&(this.issuerUniqueID=getParametersValue(e,ci,Certificate.defaultValues(ci))),ui in e&&(this.subjectUniqueID=getParametersValue(e,ui,Certificate.defaultValues(ui))),hi in e&&(this.extensions=getParametersValue(e,hi,Certificate.defaultValues(hi))),this.signatureAlgorithm=getParametersValue(e,mi,Certificate.defaultValues(mi)),this.signatureValue=getParametersValue(e,fi,Certificate.defaultValues(fi)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ei:return ke;case ti:return 0;case ri:return new Integer;case si:return new AlgorithmIdentifier;case ai:return new RelativeDistinguishedNames;case ii:case ni:return new Time;case oi:return new RelativeDistinguishedNames;case li:return new PublicKeyInfo;case ci:case ui:return ke;case hi:return[];case mi:return new AlgorithmIdentifier;case fi:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[tbsCertificate(t.tbsCertificate),AlgorithmIdentifier.schema(t.signatureAlgorithm||{names:{blockName:mi}}),new BitString({name:t.signatureValue||fi})]})}fromSchema(e){clearProps(e,Bi);const t=compareSchema(e,e,Certificate.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:Vi}}}}}}));AsnError.assertSchema(t,this.className),this.tbsView=t.result.tbsCertificate.valueBeforeDecodeView,di in t.result&&(this.version=t.result[di].valueBlock.valueDec),this.serialNumber=t.result[pi],this.signature=new AlgorithmIdentifier({schema:t.result[Si]}),this.issuer=new RelativeDistinguishedNames({schema:t.result[yi]}),this.notBefore=new Time({schema:t.result[wi]}),this.notAfter=new Time({schema:t.result[vi]}),this.subject=new RelativeDistinguishedNames({schema:t.result[bi]}),this.subjectPublicKeyInfo=new PublicKeyInfo({schema:t.result[Ai]}),ki in t.result&&(this.issuerUniqueID=t.result[ki].valueBlock.valueHex),Ci in t.result&&(this.subjectUniqueID=t.result[Ci].valueBlock.valueHex),Vi in t.result&&(this.extensions=Array.from(t.result[Vi],e=>new Extension({schema:e}))),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return ti in this&&this.version!==Certificate.defaultValues(ti)&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Integer({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new Sequence({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),this.issuerUniqueID&&e.push(new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),this.subjectUniqueID&&e.push(new Primitive({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),this.extensions&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new Sequence({value:Array.from(this.extensions,e=>e.toSchema())})]})),new Sequence({value:e})}toSchema(e=!1){let t;if(!1===e){if(!this.tbsView.byteLength)return Certificate.schema().value[0];const e=fromBER(this.tbsView);AsnError.assert(e,"TBS Certificate"),t=e.result}else t=this.encodeTBS();return new Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:Convert.ToHex(this.tbsView),version:this.version,serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return ti in this&&this.version!==Certificate.defaultValues(ti)&&(e.version=this.version),this.issuerUniqueID&&(e.issuerUniqueID=Convert.ToHex(this.issuerUniqueID)),this.subjectUniqueID&&(e.subjectUniqueID=Convert.ToHex(this.subjectUniqueID)),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}async getPublicKey(e,t=getCrypto(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}async getKeyHash(e="SHA-1",t=getCrypto(!0)){return t.digest({name:e},this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView)}async sign(e,t="SHA-1",r=getCrypto(!0)){if(!e)throw new Error("Need to provide a private key for signing");const s=await r.getSignatureParameters(e,t),a=s.parameters;this.signature=s.signatureAlgorithm,this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());const i=await r.signWithPrivateKey(this.tbsView,e,a);this.signatureValue=new BitString({valueHex:i})}async verify(e,t=getCrypto(!0)){let r;if(e?r=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(r=this.subjectPublicKeyInfo),!(r instanceof PublicKeyInfo))throw new Error("Please provide issuer certificate as a parameter");return t.verifyWithPublicKey(this.tbsView,this.signatureValue,r,this.signatureAlgorithm)}}function checkCA(e,t=null){if(t&&e.issuer.isEqual(t.issuer)&&e.serialNumber.isEqual(t.serialNumber))return null;let r=!1;if(e.extensions)for(const t of e.extensions)if(t.extnID===et&&t.parsedValue instanceof BasicConstraints&&t.parsedValue.cA){r=!0;break}return r?e:null}Certificate.CLASS_NAME="Certificate";const Ii="certId",Ni="certValue",Pi="parsedValue",Ei=[Ii,Ni];class CertBag extends PkiObject{constructor(e={}){super(),this.certId=getParametersValue(e,Ii,CertBag.defaultValues(Ii)),this.certValue=getParametersValue(e,Ni,CertBag.defaultValues(Ni)),Pi in e&&(this.parsedValue=getParametersValue(e,Pi,CertBag.defaultValues(Pi))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ii:return Ce;case Ni:return new Any;case Pi:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ii:return t===Ce;case Ni:return t instanceof Any;case Pi:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.id||"id"}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.value||"value"})]})]})}fromSchema(e){clearProps(e,Ei);const t=compareSchema(e,e,CertBag.schema({names:{id:Ii,value:Ni}}));AsnError.assertSchema(t,this.className),this.certId=t.result.certId.valueBlock.toString(),this.certValue=t.result.certValue;const r=this.certValue.valueBlock.valueHexView;switch(this.certId){case pt:try{this.parsedValue=Certificate.fromBER(r)}catch(e){AttributeCertificateV2.fromBER(r)}break;case St:this.parsedValue=AttributeCertificateV2.fromBER(r);break;default:throw new Error(`Incorrect CERT_ID value in CertBag: ${this.certId}`)}}toSchema(){return Pi in this&&("acinfo"in this.parsedValue?this.certId=St:this.certId=pt,this.certValue=new OctetString({valueHex:this.parsedValue.toSchema().toBER(!1)})),new Sequence({value:[new ObjectIdentifier({value:this.certId}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:["toSchema"in this.certValue?this.certValue.toSchema():this.certValue]})]})}toJSON(){return{certId:this.certId,certValue:this.certValue.toJSON()}}}CertBag.CLASS_NAME="CertBag";const Di="userCertificate",Oi="revocationDate",xi="crlEntryExtensions",Ri=[Di,Oi,xi];class RevokedCertificate extends PkiObject{constructor(e={}){super(),this.userCertificate=getParametersValue(e,Di,RevokedCertificate.defaultValues(Di)),this.revocationDate=getParametersValue(e,Oi,RevokedCertificate.defaultValues(Oi)),xi in e&&(this.crlEntryExtensions=getParametersValue(e,xi,RevokedCertificate.defaultValues(xi))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Di:return new Integer;case Oi:return new Time;case xi:return new Extensions;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.userCertificate||Di}),Time.schema({names:{utcTimeName:t.revocationDate||Oi,generalTimeName:t.revocationDate||Oi}}),Extensions.schema({names:{blockName:t.crlEntryExtensions||xi}},!0)]})}fromSchema(e){clearProps(e,Ri);const t=compareSchema(e,e,RevokedCertificate.schema());AsnError.assertSchema(t,this.className),this.userCertificate=t.result.userCertificate,this.revocationDate=new Time({schema:t.result.revocationDate}),xi in t.result&&(this.crlEntryExtensions=new Extensions({schema:t.result.crlEntryExtensions}))}toSchema(){const e=[this.userCertificate,this.revocationDate.toSchema()];return this.crlEntryExtensions&&e.push(this.crlEntryExtensions.toSchema()),new Sequence({value:e})}toJSON(){const e={userCertificate:this.userCertificate.toJSON(),revocationDate:this.revocationDate.toJSON()};return this.crlEntryExtensions&&(e.crlEntryExtensions=this.crlEntryExtensions.toJSON()),e}}RevokedCertificate.CLASS_NAME="RevokedCertificate";const Ki="tbs",Ui="version",Ti="signature",Li="issuer",Hi="thisUpdate",qi="nextUpdate",ji="revokedCertificates",Mi="crlExtensions",Ji="signatureAlgorithm",_i="signatureValue",Fi="tbsCertList",$i=`${Fi}.version`,Wi=`${Fi}.signature`,Gi=`${Fi}.issuer`,zi=`${Fi}.thisUpdate`,Qi=`${Fi}.nextUpdate`,Zi=`${Fi}.revokedCertificates`,Yi=`${Fi}.extensions`,Xi=[Fi,$i,Wi,Gi,zi,Qi,Zi,Yi,Ji,_i];function tbsCertList(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Fi,value:[new Integer({optional:!0,name:t.tbsCertListVersion||$i,value:2}),AlgorithmIdentifier.schema(t.signature||{names:{blockName:Wi}}),RelativeDistinguishedNames.schema(t.issuer||{names:{blockName:Gi}}),Time.schema(t.tbsCertListThisUpdate||{names:{utcTimeName:zi,generalTimeName:zi}}),Time.schema(t.tbsCertListNextUpdate||{names:{utcTimeName:Qi,generalTimeName:Qi}},!0),new Sequence({optional:!0,value:[new Repeated({name:t.tbsCertListRevokedCertificates||Zi,value:new Sequence({value:[new Integer,Time.schema(),Extensions.schema({},!0)]})})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Extensions.schema(t.crlExtensions||{names:{blockName:Yi}})]})]})}const en=[ct,Xe,"2.5.29.20","2.5.29.27",tt,it,ht,"2.5.29.21","2.5.29.24",rt];class CertificateRevocationList extends PkiObject{get tbs(){return BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(getParametersValue(e,Ki,CertificateRevocationList.defaultValues(Ki))),this.version=getParametersValue(e,Ui,CertificateRevocationList.defaultValues(Ui)),this.signature=getParametersValue(e,Ti,CertificateRevocationList.defaultValues(Ti)),this.issuer=getParametersValue(e,Li,CertificateRevocationList.defaultValues(Li)),this.thisUpdate=getParametersValue(e,Hi,CertificateRevocationList.defaultValues(Hi)),qi in e&&(this.nextUpdate=getParametersValue(e,qi,CertificateRevocationList.defaultValues(qi))),ji in e&&(this.revokedCertificates=getParametersValue(e,ji,CertificateRevocationList.defaultValues(ji))),Mi in e&&(this.crlExtensions=getParametersValue(e,Mi,CertificateRevocationList.defaultValues(Mi))),this.signatureAlgorithm=getParametersValue(e,Ji,CertificateRevocationList.defaultValues(Ji)),this.signatureValue=getParametersValue(e,_i,CertificateRevocationList.defaultValues(_i)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ki:return ke;case Ui:return 0;case Ti:return new AlgorithmIdentifier;case Li:return new RelativeDistinguishedNames;case Hi:case qi:return new Time;case ji:return[];case Mi:return new Extensions;case Ji:return new AlgorithmIdentifier;case _i:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||"CertificateList",value:[tbsCertList(e),AlgorithmIdentifier.schema(t.signatureAlgorithm||{names:{blockName:Ji}}),new BitString({name:t.signatureValue||_i})]})}fromSchema(e){clearProps(e,Xi);const t=compareSchema(e,e,CertificateRevocationList.schema());AsnError.assertSchema(t,this.className),this.tbsView=t.result.tbsCertList.valueBeforeDecodeView,$i in t.result&&(this.version=t.result[$i].valueBlock.valueDec),this.signature=new AlgorithmIdentifier({schema:t.result[Wi]}),this.issuer=new RelativeDistinguishedNames({schema:t.result[Gi]}),this.thisUpdate=new Time({schema:t.result[zi]}),Qi in t.result&&(this.nextUpdate=new Time({schema:t.result[Qi]})),Zi in t.result&&(this.revokedCertificates=Array.from(t.result[Zi],e=>new RevokedCertificate({schema:e}))),Yi in t.result&&(this.crlExtensions=new Extensions({schema:t.result[Yi]})),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return this.version!==CertificateRevocationList.defaultValues(Ui)&&e.push(new Integer({value:this.version})),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(this.thisUpdate.toSchema()),this.nextUpdate&&e.push(this.nextUpdate.toSchema()),this.revokedCertificates&&e.push(new Sequence({value:Array.from(this.revokedCertificates,e=>e.toSchema())})),this.crlExtensions&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.crlExtensions.toSchema()]})),new Sequence({value:e})}toSchema(e=!1){let t;if(e)t=this.encodeTBS();else{if(!this.tbsView.byteLength)return CertificateRevocationList.schema();const e=fromBER(this.tbsView);AsnError.assert(e,"TBS Certificate Revocation List"),t=e.result}return new Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:Convert.ToHex(this.tbsView),version:this.version,signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),thisUpdate:this.thisUpdate.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return this.version!==CertificateRevocationList.defaultValues(Ui)&&(e.version=this.version),this.nextUpdate&&(e.nextUpdate=this.nextUpdate.toJSON()),this.revokedCertificates&&(e.revokedCertificates=Array.from(this.revokedCertificates,e=>e.toJSON())),this.crlExtensions&&(e.crlExtensions=this.crlExtensions.toJSON()),e}isCertificateRevoked(e){if(!this.issuer.isEqual(e.issuer))return!1;if(!this.revokedCertificates)return!1;for(const t of this.revokedCertificates)if(t.userCertificate.isEqual(e.serialNumber))return!0;return!1}async sign(e,t="SHA-1",r=getCrypto(!0)){if(!e)throw new Error("Need to provide a private key for signing");const s=await r.getSignatureParameters(e,t),{parameters:a}=s;this.signature=s.signatureAlgorithm,this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());const i=await r.signWithPrivateKey(this.tbsView,e,a);this.signatureValue=new BitString({valueHex:i})}async verify(e={},t=getCrypto(!0)){let r;if(e.issuerCertificate&&(r=e.issuerCertificate.subjectPublicKeyInfo,!this.issuer.isEqual(e.issuerCertificate.subject)))return!1;if(e.publicKeyInfo&&(r=e.publicKeyInfo),!r)throw new Error("Issuer's certificate must be provided as an input parameter");if(this.crlExtensions)for(const e of this.crlExtensions.extensions)if(e.critical&&!en.includes(e.extnID))return!1;return t.verifyWithPublicKey(this.tbsView,this.signatureValue,r,this.signatureAlgorithm)}}CertificateRevocationList.CLASS_NAME="CertificateRevocationList";const tn="crlId",rn="crlValue",sn="parsedValue",an=[tn,rn];class CRLBag extends PkiObject{constructor(e={}){super(),this.crlId=getParametersValue(e,tn,CRLBag.defaultValues(tn)),this.crlValue=getParametersValue(e,rn,CRLBag.defaultValues(rn)),sn in e&&(this.parsedValue=getParametersValue(e,sn,CRLBag.defaultValues(sn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tn:return Ce;case rn:return new Any;case sn:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case tn:return t===Ce;case rn:return t instanceof Any;case sn:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.id||"id"}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.value||"value"})]})]})}fromSchema(e){clearProps(e,an);const t=compareSchema(e,e,CRLBag.schema({names:{id:tn,value:rn}}));if(AsnError.assertSchema(t,this.className),this.crlId=t.result.crlId.valueBlock.toString(),this.crlValue=t.result.crlValue,this.crlId!==yt)throw new Error(`Incorrect CRL_ID value in CRLBag: ${this.crlId}`);this.parsedValue=CertificateRevocationList.fromBER(this.certValue.valueBlock.valueHex)}toSchema(){return this.parsedValue&&(this.crlId=yt,this.crlValue=new OctetString({valueHex:this.parsedValue.toSchema().toBER(!1)})),new Sequence({value:[new ObjectIdentifier({value:this.crlId}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.crlValue.toSchema()]})]})}toJSON(){return{crlId:this.crlId,crlValue:this.crlValue.toJSON()}}}CRLBag.CLASS_NAME="CRLBag";const nn="version",on="encryptedContentInfo",ln="unprotectedAttrs",cn=[nn,on,ln];class EncryptedData extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,nn,EncryptedData.defaultValues(nn)),this.encryptedContentInfo=getParametersValue(e,on,EncryptedData.defaultValues(on)),ln in e&&(this.unprotectedAttrs=getParametersValue(e,ln,EncryptedData.defaultValues(ln))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case nn:return 0;case on:return new EncryptedContentInfo;case ln:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case nn:return 0===t;case on:return EncryptedContentInfo.compareWithDefault("contentType",t.contentType)&&EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&EncryptedContentInfo.compareWithDefault("encryptedContent",t.encryptedContent);case ln:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||Ce}),EncryptedContentInfo.schema(t.encryptedContentInfo||{}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Repeated({name:t.unprotectedAttrs||Ce,value:Attribute.schema()})]})]})}fromSchema(e){clearProps(e,cn);const t=compareSchema(e,e,EncryptedData.schema({names:{version:nn,encryptedContentInfo:{names:{blockName:on}},unprotectedAttrs:ln}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.encryptedContentInfo=new EncryptedContentInfo({schema:t.result.encryptedContentInfo}),ln in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new Attribute({schema:e})))}toSchema(){const e=[];return e.push(new Integer({value:this.version})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={version:this.version,encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}async encrypt(e,t=getCrypto(!0)){ArgumentError.assert(e,"parameters","object");const r={...e,contentType:"1.2.840.113549.1.7.1"};this.encryptedContentInfo=await t.encryptEncryptedContentInfo(r)}async decrypt(e,t=getCrypto(!0)){ArgumentError.assert(e,"parameters","object");const r={...e,encryptedContentInfo:this.encryptedContentInfo};return t.decryptEncryptedContentInfo(r)}}EncryptedData.CLASS_NAME="EncryptedData";const un="encryptionAlgorithm",hn="encryptedData",mn="parsedValue",fn=[un,hn];class PKCS8ShroudedKeyBag extends PkiObject{constructor(e={}){super(),this.encryptionAlgorithm=getParametersValue(e,un,PKCS8ShroudedKeyBag.defaultValues(un)),this.encryptedData=getParametersValue(e,hn,PKCS8ShroudedKeyBag.defaultValues(hn)),mn in e&&(this.parsedValue=getParametersValue(e,mn,PKCS8ShroudedKeyBag.defaultValues(mn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case un:return new AlgorithmIdentifier;case hn:return new OctetString;case mn:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case un:return AlgorithmIdentifier.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case hn:return t.isEqual(PKCS8ShroudedKeyBag.defaultValues(e));case mn:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[AlgorithmIdentifier.schema(t.encryptionAlgorithm||{names:{blockName:un}}),new Choice({value:[new OctetString({name:t.encryptedData||hn}),new OctetString({idBlock:{isConstructed:!0},name:t.encryptedData||hn})]})]})}fromSchema(e){clearProps(e,fn);const t=compareSchema(e,e,PKCS8ShroudedKeyBag.schema({names:{encryptionAlgorithm:{names:{blockName:un}},encryptedData:hn}}));AsnError.assertSchema(t,this.className),this.encryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.encryptionAlgorithm}),this.encryptedData=t.result.encryptedData}toSchema(){return new Sequence({value:[this.encryptionAlgorithm.toSchema(),this.encryptedData]})}toJSON(){return{encryptionAlgorithm:this.encryptionAlgorithm.toJSON(),encryptedData:this.encryptedData.toJSON()}}async parseInternalValues(e,t=getCrypto(!0)){const r=new EncryptedData({encryptedContentInfo:new EncryptedContentInfo({contentEncryptionAlgorithm:this.encryptionAlgorithm,encryptedContent:this.encryptedData})}),s=await r.decrypt(e,t);this.parsedValue=PrivateKeyInfo.fromBER(s)}async makeInternalValues(e,t=getCrypto(!0)){if(!this.parsedValue)throw new Error('Please initialize "parsedValue" first');const r=new EncryptedData,s={...e,contentToEncrypt:this.parsedValue.toSchema().toBER(!1)};if(await r.encrypt(s,t),!r.encryptedContentInfo.encryptedContent)throw new Error("The filed `encryptedContent` in EncryptedContentInfo is empty");this.encryptionAlgorithm=r.encryptedContentInfo.contentEncryptionAlgorithm,this.encryptedData=r.encryptedContentInfo.encryptedContent}}PKCS8ShroudedKeyBag.CLASS_NAME="PKCS8ShroudedKeyBag";const gn="secretTypeId",dn="secretValue",pn=[gn,dn];class SecretBag extends PkiObject{constructor(e={}){super(),this.secretTypeId=getParametersValue(e,gn,SecretBag.defaultValues(gn)),this.secretValue=getParametersValue(e,dn,SecretBag.defaultValues(dn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case gn:return Ce;case dn:return new Any;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case gn:return t===Ce;case dn:return t instanceof Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.id||"id"}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.value||"value"})]})]})}fromSchema(e){clearProps(e,pn);const t=compareSchema(e,e,SecretBag.schema({names:{id:gn,value:dn}}));AsnError.assertSchema(t,this.className),this.secretTypeId=t.result.secretTypeId.valueBlock.toString(),this.secretValue=t.result.secretValue}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.secretTypeId}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.secretValue.toSchema()]})]})}toJSON(){return{secretTypeId:this.secretTypeId,secretValue:this.secretValue.toJSON()}}}SecretBag.CLASS_NAME="SecretBag";class SafeBagValueFactory{static getItems(){return this.items||(this.items={},SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.1",PrivateKeyInfo),SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.2",PKCS8ShroudedKeyBag),SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.3",CertBag),SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.4",CRLBag),SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.5",SecretBag),SafeBagValueFactory.register("1.2.840.113549.1.12.10.1.6",SafeContents)),this.items}static register(e,t){this.getItems()[e]=t}static find(e){return this.getItems()[e]||null}}const Sn="bagId",yn="bagValue",wn="bagAttributes",vn=[Sn,yn,wn];class SafeBag extends PkiObject{constructor(e={}){super(),this.bagId=getParametersValue(e,Sn,SafeBag.defaultValues(Sn)),this.bagValue=getParametersValue(e,yn,SafeBag.defaultValues(yn)),wn in e&&(this.bagAttributes=getParametersValue(e,wn,SafeBag.defaultValues(wn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Sn:return Ce;case yn:return new Any;case wn:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Sn:return t===Ce;case yn:return t instanceof Any;case wn:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.bagId||Sn}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.bagValue||yn})]}),new Set({optional:!0,value:[new Repeated({name:t.bagAttributes||wn,value:Attribute.schema()})]})]})}fromSchema(e){clearProps(e,vn);const t=compareSchema(e,e,SafeBag.schema({names:{bagId:Sn,bagValue:yn,bagAttributes:wn}}));AsnError.assertSchema(t,this.className),this.bagId=t.result.bagId.valueBlock.toString();const r=SafeBagValueFactory.find(this.bagId);if(!r)throw new Error(`Invalid BAG_ID for SafeBag: ${this.bagId}`);this.bagValue=new r({schema:t.result.bagValue}),wn in t.result&&(this.bagAttributes=Array.from(t.result.bagAttributes,e=>new Attribute({schema:e})))}toSchema(){const e=[new ObjectIdentifier({value:this.bagId}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.bagValue.toSchema()]})];return this.bagAttributes&&e.push(new Set({value:Array.from(this.bagAttributes,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={bagId:this.bagId,bagValue:this.bagValue.toJSON()};return this.bagAttributes&&(e.bagAttributes=Array.from(this.bagAttributes,e=>e.toJSON())),e}}SafeBag.CLASS_NAME="SafeBag";const bn="safeBags";class SafeContents extends PkiObject{constructor(e={}){super(),this.safeBags=getParametersValue(e,bn,SafeContents.defaultValues(bn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===bn?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===bn?0===t.length:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.safeBags||Ce,value:SafeBag.schema()})]})}fromSchema(e){clearProps(e,[bn]);const t=compareSchema(e,e,SafeContents.schema({names:{safeBags:bn}}));AsnError.assertSchema(t,this.className),this.safeBags=Array.from(t.result.safeBags,e=>new SafeBag({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.safeBags,e=>e.toSchema())})}toJSON(){return{safeBags:Array.from(this.safeBags,e=>e.toJSON())}}}SafeContents.CLASS_NAME="SafeContents";const An="otherCertFormat",kn="otherCert",Cn=[An,kn];class OtherCertificateFormat extends PkiObject{constructor(e={}){super(),this.otherCertFormat=getParametersValue(e,An,OtherCertificateFormat.defaultValues(An)),this.otherCert=getParametersValue(e,kn,OtherCertificateFormat.defaultValues(kn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case An:return Ce;case kn:return new Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.otherCertFormat||An}),new Any({name:t.otherCert||kn})]})}fromSchema(e){clearProps(e,Cn);const t=compareSchema(e,e,OtherCertificateFormat.schema());AsnError.assertSchema(t,this.className),this.otherCertFormat=t.result.otherCertFormat.valueBlock.toString(),this.otherCert=t.result.otherCert}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.otherCertFormat}),this.otherCert]})}toJSON(){const e={otherCertFormat:this.otherCertFormat};return this.otherCert instanceof Any||(e.otherCert=this.otherCert.toJSON()),e}}const Vn="certificates",Bn=[Vn];class CertificateSet extends PkiObject{constructor(e={}){super(),this.certificates=getParametersValue(e,Vn,CertificateSet.defaultValues(Vn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===Vn?[]:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Set({name:t.blockName||Ce,value:[new Repeated({name:t.certificates||Vn,value:new Choice({value:[Certificate.schema(),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Any]}),new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new Sequence]}),new Constructed({idBlock:{tagClass:3,tagNumber:2},value:AttributeCertificateV2.schema().valueBlock.value}),new Constructed({idBlock:{tagClass:3,tagNumber:3},value:OtherCertificateFormat.schema().valueBlock.value})]})})]})}fromSchema(e){clearProps(e,Bn);const t=compareSchema(e,e,CertificateSet.schema());AsnError.assertSchema(t,this.className),this.certificates=Array.from(t.result.certificates||[],e=>{const t=e.idBlock.tagNumber;if(1===e.idBlock.tagClass)return new Certificate({schema:e});const r=new Sequence({value:e.valueBlock.value});switch(t){case 1:return 1===r.valueBlock.value[0].valueBlock.value[0].valueBlock.valueDec?new AttributeCertificateV2({schema:r}):new AttributeCertificateV1({schema:r});case 2:return new AttributeCertificateV2({schema:r});case 3:return new OtherCertificateFormat({schema:r})}return e})}toSchema(){return new Set({value:Array.from(this.certificates,e=>{switch(!0){case e instanceof Certificate:return e.toSchema();case e instanceof AttributeCertificateV1:return new Constructed({idBlock:{tagClass:3,tagNumber:1},value:e.toSchema().valueBlock.value});case e instanceof AttributeCertificateV2:return new Constructed({idBlock:{tagClass:3,tagNumber:2},value:e.toSchema().valueBlock.value});case e instanceof OtherCertificateFormat:return new Constructed({idBlock:{tagClass:3,tagNumber:3},value:e.toSchema().valueBlock.value})}return e.toSchema()})})}toJSON(){return{certificates:Array.from(this.certificates,e=>e.toJSON())}}}CertificateSet.CLASS_NAME="CertificateSet";const In="otherRevInfoFormat",Nn="otherRevInfo",Pn=[In,Nn];class OtherRevocationInfoFormat extends PkiObject{constructor(e={}){super(),this.otherRevInfoFormat=getParametersValue(e,In,OtherRevocationInfoFormat.defaultValues(In)),this.otherRevInfo=getParametersValue(e,Nn,OtherRevocationInfoFormat.defaultValues(Nn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case In:return Ce;case Nn:return new Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.otherRevInfoFormat||In}),new Any({name:t.otherRevInfo||Nn})]})}fromSchema(e){clearProps(e,Pn);const t=compareSchema(e,e,OtherRevocationInfoFormat.schema());AsnError.assertSchema(t,this.className),this.otherRevInfoFormat=t.result.otherRevInfoFormat.valueBlock.toString(),this.otherRevInfo=t.result.otherRevInfo}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.otherRevInfoFormat}),this.otherRevInfo]})}toJSON(){const e={otherRevInfoFormat:this.otherRevInfoFormat};return this.otherRevInfo instanceof Any||(e.otherRevInfo=this.otherRevInfo.toJSON()),e}}OtherRevocationInfoFormat.CLASS_NAME="OtherRevocationInfoFormat";const En="crls",Dn="otherRevocationInfos",On=[En];class RevocationInfoChoices extends PkiObject{constructor(e={}){super(),this.crls=getParametersValue(e,En,RevocationInfoChoices.defaultValues(En)),this.otherRevocationInfos=getParametersValue(e,Dn,RevocationInfoChoices.defaultValues(Dn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case En:case Dn:return[];default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Set({name:t.blockName||Ce,value:[new Repeated({name:t.crls||Ce,value:new Choice({value:[CertificateRevocationList.schema(),new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new ObjectIdentifier,new Any]})]})})]})}fromSchema(e){clearProps(e,On);const t=compareSchema(e,e,RevocationInfoChoices.schema({names:{crls:En}}));if(AsnError.assertSchema(t,this.className),t.result.crls)for(const e of t.result.crls)1===e.idBlock.tagClass?this.crls.push(new CertificateRevocationList({schema:e})):this.otherRevocationInfos.push(new OtherRevocationInfoFormat({schema:e}))}toSchema(){const e=[];return e.push(...Array.from(this.crls,e=>e.toSchema())),e.push(...Array.from(this.otherRevocationInfos,e=>{const t=e.toSchema();return t.idBlock.tagClass=3,t.idBlock.tagNumber=1,t})),new Set({value:e})}toJSON(){return{crls:Array.from(this.crls,e=>e.toJSON()),otherRevocationInfos:Array.from(this.otherRevocationInfos,e=>e.toJSON())}}}RevocationInfoChoices.CLASS_NAME="RevocationInfoChoices";const xn="certs",Rn="crls",Kn=[xn,Rn];class OriginatorInfo extends PkiObject{constructor(e={}){super(),this.crls=getParametersValue(e,Rn,OriginatorInfo.defaultValues(Rn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case xn:return new CertificateSet;case Rn:return new RevocationInfoChoices;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case xn:return 0===t.certificates.length;case Rn:return 0===t.crls.length&&0===t.otherRevocationInfos.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Constructed({name:t.certs||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:CertificateSet.schema().valueBlock.value}),new Constructed({name:t.crls||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:1},value:RevocationInfoChoices.schema().valueBlock.value})]})}fromSchema(e){clearProps(e,Kn);const t=compareSchema(e,e,OriginatorInfo.schema({names:{certs:xn,crls:Rn}}));AsnError.assertSchema(t,this.className),xn in t.result&&(this.certs=new CertificateSet({schema:new Set({value:t.result.certs.valueBlock.value})})),Rn in t.result&&(this.crls=new RevocationInfoChoices({schema:new Set({value:t.result.crls.valueBlock.value})}))}toSchema(){const e=[];return this.certs&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.certs.toSchema().valueBlock.value})),this.crls&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:this.crls.toSchema().valueBlock.value})),new Sequence({value:e})}toJSON(){const e={};return this.certs&&(e.certs=this.certs.toJSON()),this.crls&&(e.crls=this.crls.toJSON()),e}}OriginatorInfo.CLASS_NAME="OriginatorInfo";const Un="issuer",Tn="serialNumber",Ln=[Un,Tn];class IssuerAndSerialNumber extends PkiObject{constructor(e={}){super(),this.issuer=getParametersValue(e,Un,IssuerAndSerialNumber.defaultValues(Un)),this.serialNumber=getParametersValue(e,Tn,IssuerAndSerialNumber.defaultValues(Tn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Un:return new RelativeDistinguishedNames;case Tn:return new Integer;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[RelativeDistinguishedNames.schema(t.issuer||{}),new Integer({name:t.serialNumber||Ce})]})}fromSchema(e){clearProps(e,Ln);const t=compareSchema(e,e,IssuerAndSerialNumber.schema({names:{issuer:{names:{blockName:Un}},serialNumber:Tn}}));AsnError.assertSchema(t,this.className),this.issuer=new RelativeDistinguishedNames({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber}toSchema(){return new Sequence({value:[this.issuer.toSchema(),this.serialNumber]})}toJSON(){return{issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()}}}IssuerAndSerialNumber.CLASS_NAME="IssuerAndSerialNumber";const Hn="variant",qn="value",jn=["blockName"];class RecipientIdentifier extends PkiObject{constructor(e={}){super(),this.variant=getParametersValue(e,Hn,RecipientIdentifier.defaultValues(Hn)),qn in e&&(this.value=getParametersValue(e,qn,RecipientIdentifier.defaultValues(qn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Hn:return-1;case qn:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Hn:return-1===t;case qn:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Choice({value:[IssuerAndSerialNumber.schema({names:{blockName:t.blockName||Ce}}),new Primitive({name:t.blockName||Ce,idBlock:{tagClass:3,tagNumber:0}})]})}fromSchema(e){clearProps(e,jn);const t=compareSchema(e,e,RecipientIdentifier.schema({names:{blockName:"blockName"}}));AsnError.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new IssuerAndSerialNumber({schema:t.result.blockName})):(this.variant=2,this.value=new OctetString({valueHex:t.result.blockName.valueBlock.valueHex}))}toSchema(){switch(this.variant){case 1:if(!(this.value instanceof IssuerAndSerialNumber))throw new Error("Incorrect type of RecipientIdentifier.value. It should be IssuerAndSerialNumber.");return this.value.toSchema();case 2:if(!(this.value instanceof OctetString))throw new Error("Incorrect type of RecipientIdentifier.value. It should be ASN.1 OctetString.");return new Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.value.valueBlock.valueHexView});default:return new Any}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant||!this.value||(e.value=this.value.toJSON()),e}}RecipientIdentifier.CLASS_NAME="RecipientIdentifier";const Mn="version",Jn="rid",_n="keyEncryptionAlgorithm",Fn="encryptedKey",$n="recipientCertificate",Wn=[Mn,Jn,_n,Fn];class KeyTransRecipientInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Mn,KeyTransRecipientInfo.defaultValues(Mn)),this.rid=getParametersValue(e,Jn,KeyTransRecipientInfo.defaultValues(Jn)),this.keyEncryptionAlgorithm=getParametersValue(e,_n,KeyTransRecipientInfo.defaultValues(_n)),this.encryptedKey=getParametersValue(e,Fn,KeyTransRecipientInfo.defaultValues(Fn)),this.recipientCertificate=getParametersValue(e,$n,KeyTransRecipientInfo.defaultValues($n)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Mn:return-1;case Jn:return{};case _n:return new AlgorithmIdentifier;case Fn:return new OctetString;case $n:return new Certificate;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Mn:return t===KeyTransRecipientInfo.defaultValues(Mn);case Jn:return 0===Object.keys(t).length;case _n:case Fn:return t.isEqual(KeyTransRecipientInfo.defaultValues(e));case $n:return!1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||Ce}),RecipientIdentifier.schema(t.rid||{}),AlgorithmIdentifier.schema(t.keyEncryptionAlgorithm||{}),new OctetString({name:t.encryptedKey||Ce})]})}fromSchema(e){clearProps(e,Wn);const t=compareSchema(e,e,KeyTransRecipientInfo.schema({names:{version:Mn,rid:{names:{blockName:Jn}},keyEncryptionAlgorithm:{names:{blockName:_n}},encryptedKey:Fn}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,3===t.result.rid.idBlock.tagClass?this.rid=new OctetString({valueHex:t.result.rid.valueBlock.valueHex}):this.rid=new IssuerAndSerialNumber({schema:t.result.rid}),this.keyEncryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){const e=[];return this.rid instanceof IssuerAndSerialNumber?(this.version=0,e.push(new Integer({value:this.version})),e.push(this.rid.toSchema())):(this.version=2,e.push(new Integer({value:this.version})),e.push(new Primitive({idBlock:{tagClass:3,tagNumber:0},valueHex:this.rid.valueBlock.valueHexView}))),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new Sequence({value:e})}toJSON(){return{version:this.version,rid:this.rid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}KeyTransRecipientInfo.CLASS_NAME="KeyTransRecipientInfo";const Gn="algorithm",zn="publicKey",Qn=[Gn,zn];class OriginatorPublicKey extends PkiObject{constructor(e={}){super(),this.algorithm=getParametersValue(e,Gn,OriginatorPublicKey.defaultValues(Gn)),this.publicKey=getParametersValue(e,zn,OriginatorPublicKey.defaultValues(zn)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Gn:return new AlgorithmIdentifier;case zn:return new BitString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Gn:case zn:return t.isEqual(OriginatorPublicKey.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[AlgorithmIdentifier.schema(t.algorithm||{}),new BitString({name:t.publicKey||Ce})]})}fromSchema(e){clearProps(e,Qn);const t=compareSchema(e,e,OriginatorPublicKey.schema({names:{algorithm:{names:{blockName:Gn}},publicKey:zn}}));AsnError.assertSchema(t,this.className),this.algorithm=new AlgorithmIdentifier({schema:t.result.algorithm}),this.publicKey=t.result.publicKey}toSchema(){return new Sequence({value:[this.algorithm.toSchema(),this.publicKey]})}toJSON(){return{algorithm:this.algorithm.toJSON(),publicKey:this.publicKey.toJSON()}}}OriginatorPublicKey.CLASS_NAME="OriginatorPublicKey";const Zn="variant",Yn="value",Xn=["blockName"];class OriginatorIdentifierOrKey extends PkiObject{constructor(e={}){super(),this.variant=getParametersValue(e,Zn,OriginatorIdentifierOrKey.defaultValues(Zn)),Yn in e&&(this.value=getParametersValue(e,Yn,OriginatorIdentifierOrKey.defaultValues(Yn))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Zn:return-1;case Yn:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Zn:return-1===t;case Yn:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Choice({value:[IssuerAndSerialNumber.schema({names:{blockName:t.blockName||Ce}}),new Primitive({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||Ce}),new Constructed({idBlock:{tagClass:3,tagNumber:1},name:t.blockName||Ce,value:OriginatorPublicKey.schema().valueBlock.value})]})}fromSchema(e){clearProps(e,Xn);const t=compareSchema(e,e,OriginatorIdentifierOrKey.schema({names:{blockName:"blockName"}}));AsnError.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new IssuerAndSerialNumber({schema:t.result.blockName})):0===t.result.blockName.idBlock.tagNumber?(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=4,this.variant=2,this.value=t.result.blockName):(this.variant=3,this.value=new OriginatorPublicKey({schema:new Sequence({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return this.value.idBlock.tagClass=3,this.value.idBlock.tagNumber=0,this.value;case 3:{const e=this.value.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}default:return new Any}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant&&3!==this.variant||(e.value=this.value.toJSON()),e}}OriginatorIdentifierOrKey.CLASS_NAME="OriginatorIdentifierOrKey";const eo="keyAttrId",to="keyAttr",ro=[eo,to];class OtherKeyAttribute extends PkiObject{constructor(e={}){super(),this.keyAttrId=getParametersValue(e,eo,OtherKeyAttribute.defaultValues(eo)),to in e&&(this.keyAttr=getParametersValue(e,to,OtherKeyAttribute.defaultValues(to))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eo:return Ce;case to:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case eo:return"string"==typeof t&&t===Ce;case to:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({optional:t.optional||!0,name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.keyAttrId||Ce}),new Any({optional:!0,name:t.keyAttr||Ce})]})}fromSchema(e){clearProps(e,ro);const t=compareSchema(e,e,OtherKeyAttribute.schema({names:{keyAttrId:eo,keyAttr:to}}));AsnError.assertSchema(t,this.className),this.keyAttrId=t.result.keyAttrId.valueBlock.toString(),to in t.result&&(this.keyAttr=t.result.keyAttr)}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.keyAttrId})),to in this&&e.push(this.keyAttr),new Sequence({value:e})}toJSON(){const e={keyAttrId:this.keyAttrId};return to in this&&(e.keyAttr=this.keyAttr.toJSON()),e}}OtherKeyAttribute.CLASS_NAME="OtherKeyAttribute";const so="subjectKeyIdentifier",ao="date",io="other",no=[so,ao,io];class RecipientKeyIdentifier extends PkiObject{constructor(e={}){super(),this.subjectKeyIdentifier=getParametersValue(e,so,RecipientKeyIdentifier.defaultValues(so)),ao in e&&(this.date=getParametersValue(e,ao,RecipientKeyIdentifier.defaultValues(ao))),io in e&&(this.other=getParametersValue(e,io,RecipientKeyIdentifier.defaultValues(io))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case so:return new OctetString;case ao:return new GeneralizedTime;case io:return new OtherKeyAttribute;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case so:return t.isEqual(RecipientKeyIdentifier.defaultValues(so));case ao:return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case io:return t.keyAttrId===Ce&&"keyAttr"in t==!1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new OctetString({name:t.subjectKeyIdentifier||Ce}),new GeneralizedTime({optional:!0,name:t.date||Ce}),OtherKeyAttribute.schema(t.other||{})]})}fromSchema(e){clearProps(e,no);const t=compareSchema(e,e,RecipientKeyIdentifier.schema({names:{subjectKeyIdentifier:so,date:ao,other:{names:{blockName:io}}}}));AsnError.assertSchema(t,this.className),this.subjectKeyIdentifier=t.result.subjectKeyIdentifier,ao in t.result&&(this.date=t.result.date),io in t.result&&(this.other=new OtherKeyAttribute({schema:t.result.other}))}toSchema(){const e=[];return e.push(this.subjectKeyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new Sequence({value:e})}toJSON(){const e={subjectKeyIdentifier:this.subjectKeyIdentifier.toJSON()};return this.date&&(e.date=this.date.toJSON()),this.other&&(e.other=this.other.toJSON()),e}}RecipientKeyIdentifier.CLASS_NAME="RecipientKeyIdentifier";const oo="variant",lo="value",co=["blockName"];class KeyAgreeRecipientIdentifier extends PkiObject{constructor(e={}){super(),this.variant=getParametersValue(e,oo,KeyAgreeRecipientIdentifier.defaultValues(oo)),this.value=getParametersValue(e,lo,KeyAgreeRecipientIdentifier.defaultValues(lo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case oo:return-1;case lo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case oo:return-1===t;case lo:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Choice({value:[IssuerAndSerialNumber.schema(t.issuerAndSerialNumber||{names:{blockName:t.blockName||Ce}}),new Constructed({name:t.blockName||Ce,idBlock:{tagClass:3,tagNumber:0},value:RecipientKeyIdentifier.schema(t.rKeyId||{names:{blockName:t.blockName||Ce}}).valueBlock.value})]})}fromSchema(e){clearProps(e,co);const t=compareSchema(e,e,KeyAgreeRecipientIdentifier.schema({names:{blockName:"blockName"}}));AsnError.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new IssuerAndSerialNumber({schema:t.result.blockName})):(this.variant=2,this.value=new RecipientKeyIdentifier({schema:new Sequence({value:t.result.blockName.valueBlock.value})}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.value.toSchema().valueBlock.value});default:return new Any}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant||(e.value=this.value.toJSON()),e}}KeyAgreeRecipientIdentifier.CLASS_NAME="KeyAgreeRecipientIdentifier";const uo="rid",ho="encryptedKey",mo=[uo,ho];class RecipientEncryptedKey extends PkiObject{constructor(e={}){super(),this.rid=getParametersValue(e,uo,RecipientEncryptedKey.defaultValues(uo)),this.encryptedKey=getParametersValue(e,ho,RecipientEncryptedKey.defaultValues(ho)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case uo:return new KeyAgreeRecipientIdentifier;case ho:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case uo:return-1===t.variant&&"value"in t==!1;case ho:return t.isEqual(RecipientEncryptedKey.defaultValues(ho));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[KeyAgreeRecipientIdentifier.schema(t.rid||{}),new OctetString({name:t.encryptedKey||Ce})]})}fromSchema(e){clearProps(e,mo);const t=compareSchema(e,e,RecipientEncryptedKey.schema({names:{rid:{names:{blockName:uo}},encryptedKey:ho}}));AsnError.assertSchema(t,this.className),this.rid=new KeyAgreeRecipientIdentifier({schema:t.result.rid}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new Sequence({value:[this.rid.toSchema(),this.encryptedKey]})}toJSON(){return{rid:this.rid.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}RecipientEncryptedKey.CLASS_NAME="RecipientEncryptedKey";const fo="encryptedKeys",go="RecipientEncryptedKeys",po=[go];class RecipientEncryptedKeys extends PkiObject{constructor(e={}){super(),this.encryptedKeys=getParametersValue(e,fo,RecipientEncryptedKeys.defaultValues(fo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){return e===fo?[]:super.defaultValues(e)}static compareWithDefault(e,t){return e===fo?0===t.length:super.defaultValues(e)}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.RecipientEncryptedKeys||Ce,value:RecipientEncryptedKey.schema()})]})}fromSchema(e){clearProps(e,po);const t=compareSchema(e,e,RecipientEncryptedKeys.schema({names:{RecipientEncryptedKeys:go}}));AsnError.assertSchema(t,this.className),this.encryptedKeys=Array.from(t.result.RecipientEncryptedKeys,e=>new RecipientEncryptedKey({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.encryptedKeys,e=>e.toSchema())})}toJSON(){return{encryptedKeys:Array.from(this.encryptedKeys,e=>e.toJSON())}}}RecipientEncryptedKeys.CLASS_NAME="RecipientEncryptedKeys";const So="version",yo="originator",wo="ukm",vo="keyEncryptionAlgorithm",bo="recipientEncryptedKeys",Ao="recipientCertificate",ko="recipientPublicKey",Co=[So,yo,wo,vo,bo];class KeyAgreeRecipientInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,So,KeyAgreeRecipientInfo.defaultValues(So)),this.originator=getParametersValue(e,yo,KeyAgreeRecipientInfo.defaultValues(yo)),wo in e&&(this.ukm=getParametersValue(e,wo,KeyAgreeRecipientInfo.defaultValues(wo))),this.keyEncryptionAlgorithm=getParametersValue(e,vo,KeyAgreeRecipientInfo.defaultValues(vo)),this.recipientEncryptedKeys=getParametersValue(e,bo,KeyAgreeRecipientInfo.defaultValues(bo)),this.recipientCertificate=getParametersValue(e,Ao,KeyAgreeRecipientInfo.defaultValues(Ao)),this.recipientPublicKey=getParametersValue(e,ko,KeyAgreeRecipientInfo.defaultValues(ko)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case So:return 0;case yo:return new OriginatorIdentifierOrKey;case wo:return new OctetString;case vo:return new AlgorithmIdentifier;case bo:return new RecipientEncryptedKeys;case Ao:return new Certificate;case ko:return null;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case So:return 0===t;case yo:return-1===t.variant&&"value"in t==!1;case wo:return t.isEqual(KeyAgreeRecipientInfo.defaultValues(wo));case vo:return t.algorithmId===Ce&&"algorithmParams"in t==!1;case bo:return 0===t.encryptedKeys.length;case Ao:case ko:return!1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||Ce}),new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[OriginatorIdentifierOrKey.schema(t.originator||{})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new OctetString({name:t.ukm||Ce})]}),AlgorithmIdentifier.schema(t.keyEncryptionAlgorithm||{}),RecipientEncryptedKeys.schema(t.recipientEncryptedKeys||{})]})}fromSchema(e){clearProps(e,Co);const t=compareSchema(e,e,KeyAgreeRecipientInfo.schema({names:{version:So,originator:{names:{blockName:yo}},ukm:wo,keyEncryptionAlgorithm:{names:{blockName:vo}},recipientEncryptedKeys:{names:{blockName:bo}}}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.originator=new OriginatorIdentifierOrKey({schema:t.result.originator}),wo in t.result&&(this.ukm=t.result.ukm),this.keyEncryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.keyEncryptionAlgorithm}),this.recipientEncryptedKeys=new RecipientEncryptedKeys({schema:t.result.recipientEncryptedKeys})}toSchema(){const e=[];return e.push(new Integer({value:this.version})),e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.originator.toSchema()]})),this.ukm&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[this.ukm]})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.recipientEncryptedKeys.toSchema()),new Sequence({value:e})}toJSON(){const e={version:this.version,originator:this.originator.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),recipientEncryptedKeys:this.recipientEncryptedKeys.toJSON()};return this.ukm&&(e.ukm=this.ukm.toJSON()),e}}KeyAgreeRecipientInfo.CLASS_NAME="KeyAgreeRecipientInfo";const Vo="keyIdentifier",Bo="date",Io="other",No=[Vo,Bo,Io];class KEKIdentifier extends PkiObject{constructor(e={}){super(),this.keyIdentifier=getParametersValue(e,Vo,KEKIdentifier.defaultValues(Vo)),Bo in e&&(this.date=getParametersValue(e,Bo,KEKIdentifier.defaultValues(Bo))),Io in e&&(this.other=getParametersValue(e,Io,KEKIdentifier.defaultValues(Io))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Vo:return new OctetString;case Bo:return new GeneralizedTime;case Io:return new OtherKeyAttribute;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Vo:return t.isEqual(KEKIdentifier.defaultValues(Vo));case Bo:return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case Io:return t.compareWithDefault("keyAttrId",t.keyAttrId)&&"keyAttr"in t==!1;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new OctetString({name:t.keyIdentifier||Ce}),new GeneralizedTime({optional:!0,name:t.date||Ce}),OtherKeyAttribute.schema(t.other||{})]})}fromSchema(e){clearProps(e,No);const t=compareSchema(e,e,KEKIdentifier.schema({names:{keyIdentifier:Vo,date:Bo,other:{names:{blockName:Io}}}}));AsnError.assertSchema(t,this.className),this.keyIdentifier=t.result.keyIdentifier,Bo in t.result&&(this.date=t.result.date),Io in t.result&&(this.other=new OtherKeyAttribute({schema:t.result.other}))}toSchema(){const e=[];return e.push(this.keyIdentifier),this.date&&e.push(this.date),this.other&&e.push(this.other.toSchema()),new Sequence({value:e})}toJSON(){const e={keyIdentifier:this.keyIdentifier.toJSON()};return this.date&&(e.date=this.date),this.other&&(e.other=this.other.toJSON()),e}}KEKIdentifier.CLASS_NAME="KEKIdentifier";const Po="version",Eo="kekid",Do="keyEncryptionAlgorithm",Oo="encryptedKey",xo="preDefinedKEK",Ro=[Po,Eo,Do,Oo];class KEKRecipientInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Po,KEKRecipientInfo.defaultValues(Po)),this.kekid=getParametersValue(e,Eo,KEKRecipientInfo.defaultValues(Eo)),this.keyEncryptionAlgorithm=getParametersValue(e,Do,KEKRecipientInfo.defaultValues(Do)),this.encryptedKey=getParametersValue(e,Oo,KEKRecipientInfo.defaultValues(Oo)),this.preDefinedKEK=getParametersValue(e,xo,KEKRecipientInfo.defaultValues(xo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Po:return 0;case Eo:return new KEKIdentifier;case Do:return new AlgorithmIdentifier;case Oo:return new OctetString;case xo:return ke;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"KEKRecipientInfo":return t===KEKRecipientInfo.defaultValues(Po);case Eo:return t.compareWithDefault("keyIdentifier",t.keyIdentifier)&&"date"in t==!1&&"other"in t==!1;case Do:return t.algorithmId===Ce&&"algorithmParams"in t==!1;case Oo:return t.isEqual(KEKRecipientInfo.defaultValues(Oo));case xo:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||Ce}),KEKIdentifier.schema(t.kekid||{}),AlgorithmIdentifier.schema(t.keyEncryptionAlgorithm||{}),new OctetString({name:t.encryptedKey||Ce})]})}fromSchema(e){clearProps(e,Ro);const t=compareSchema(e,e,KEKRecipientInfo.schema({names:{version:Po,kekid:{names:{blockName:Eo}},keyEncryptionAlgorithm:{names:{blockName:Do}},encryptedKey:Oo}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.kekid=new KEKIdentifier({schema:t.result.kekid}),this.keyEncryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new Sequence({value:[new Integer({value:this.version}),this.kekid.toSchema(),this.keyEncryptionAlgorithm.toSchema(),this.encryptedKey]})}toJSON(){return{version:this.version,kekid:this.kekid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}KEKRecipientInfo.CLASS_NAME="KEKRecipientInfo";const Ko="version",Uo="keyDerivationAlgorithm",To="keyEncryptionAlgorithm",Lo="encryptedKey",Ho="password",qo=[Ko,Uo,To,Lo];class PasswordRecipientinfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Ko,PasswordRecipientinfo.defaultValues(Ko)),Uo in e&&(this.keyDerivationAlgorithm=getParametersValue(e,Uo,PasswordRecipientinfo.defaultValues(Uo))),this.keyEncryptionAlgorithm=getParametersValue(e,To,PasswordRecipientinfo.defaultValues(To)),this.encryptedKey=getParametersValue(e,Lo,PasswordRecipientinfo.defaultValues(Lo)),this.password=getParametersValue(e,Ho,PasswordRecipientinfo.defaultValues(Ho)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ko:return-1;case Uo:case To:return new AlgorithmIdentifier;case Lo:return new OctetString;case Ho:return ke;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ko:return-1===t;case Uo:case To:return t.algorithmId===Ce&&"algorithmParams"in t==!1;case Lo:return t.isEqual(PasswordRecipientinfo.defaultValues(Lo));case Ho:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||Ce}),new Constructed({name:t.keyDerivationAlgorithm||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:AlgorithmIdentifier.schema().valueBlock.value}),AlgorithmIdentifier.schema(t.keyEncryptionAlgorithm||{}),new OctetString({name:t.encryptedKey||Ce})]})}fromSchema(e){clearProps(e,qo);const t=compareSchema(e,e,PasswordRecipientinfo.schema({names:{version:Ko,keyDerivationAlgorithm:Uo,keyEncryptionAlgorithm:{names:{blockName:To}},encryptedKey:Lo}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,Uo in t.result&&(this.keyDerivationAlgorithm=new AlgorithmIdentifier({schema:new Sequence({value:t.result.keyDerivationAlgorithm.valueBlock.value})})),this.keyEncryptionAlgorithm=new AlgorithmIdentifier({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){const e=[];return e.push(new Integer({value:this.version})),this.keyDerivationAlgorithm&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:this.keyDerivationAlgorithm.toSchema().valueBlock.value})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new Sequence({value:e})}toJSON(){const e={version:this.version,keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()};return this.keyDerivationAlgorithm&&(e.keyDerivationAlgorithm=this.keyDerivationAlgorithm.toJSON()),e}}PasswordRecipientinfo.CLASS_NAME="PasswordRecipientInfo";const jo="oriType",Mo="oriValue",Jo=[jo,Mo];class OtherRecipientInfo extends PkiObject{constructor(e={}){super(),this.oriType=getParametersValue(e,jo,OtherRecipientInfo.defaultValues(jo)),this.oriValue=getParametersValue(e,Mo,OtherRecipientInfo.defaultValues(Mo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case jo:return Ce;case Mo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case jo:return t===Ce;case Mo:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.oriType||Ce}),new Any({name:t.oriValue||Ce})]})}fromSchema(e){clearProps(e,Jo);const t=compareSchema(e,e,OtherRecipientInfo.schema({names:{oriType:jo,oriValue:Mo}}));AsnError.assertSchema(t,this.className),this.oriType=t.result.oriType.valueBlock.toString(),this.oriValue=t.result.oriValue}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.oriType}),this.oriValue]})}toJSON(){const e={oriType:this.oriType};return OtherRecipientInfo.compareWithDefault(Mo,this.oriValue)||(e.oriValue=this.oriValue.toJSON()),e}}OtherRecipientInfo.CLASS_NAME="OtherRecipientInfo";const _o="variant",Fo="value",$o=["blockName"];class RecipientInfo extends PkiObject{constructor(e={}){super(),this.variant=getParametersValue(e,_o,RecipientInfo.defaultValues(_o)),Fo in e&&(this.value=getParametersValue(e,Fo,RecipientInfo.defaultValues(Fo))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case _o:return-1;case Fo:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case _o:return t===RecipientInfo.defaultValues(e);case Fo:return 0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Choice({value:[KeyTransRecipientInfo.schema({names:{blockName:t.blockName||Ce}}),new Constructed({name:t.blockName||Ce,idBlock:{tagClass:3,tagNumber:1},value:KeyAgreeRecipientInfo.schema().valueBlock.value}),new Constructed({name:t.blockName||Ce,idBlock:{tagClass:3,tagNumber:2},value:KEKRecipientInfo.schema().valueBlock.value}),new Constructed({name:t.blockName||Ce,idBlock:{tagClass:3,tagNumber:3},value:PasswordRecipientinfo.schema().valueBlock.value}),new Constructed({name:t.blockName||Ce,idBlock:{tagClass:3,tagNumber:4},value:OtherRecipientInfo.schema().valueBlock.value})]})}fromSchema(e){clearProps(e,$o);const t=compareSchema(e,e,RecipientInfo.schema({names:{blockName:"blockName"}}));if(AsnError.assertSchema(t,this.className),1===t.result.blockName.idBlock.tagClass)this.variant=1,this.value=new KeyTransRecipientInfo({schema:t.result.blockName});else{const e=new Sequence({value:t.result.blockName.valueBlock.value});switch(t.result.blockName.idBlock.tagNumber){case 1:this.variant=2,this.value=new KeyAgreeRecipientInfo({schema:e});break;case 2:this.variant=3,this.value=new KEKRecipientInfo({schema:e});break;case 3:this.variant=4,this.value=new PasswordRecipientinfo({schema:e});break;case 4:this.variant=5,this.value=new OtherRecipientInfo({schema:e});break;default:throw new Error("Incorrect structure of RecipientInfo block")}}}toSchema(){ParameterError.assertEmpty(this.value,"value","RecipientInfo");const e=this.value.toSchema();switch(this.variant){case 1:return e;case 2:case 3:case 4:return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.variant-1,e;default:return new Any}}toJSON(){const e={variant:this.variant};return this.value&&this.variant>=1&&this.variant<=4&&(e.value=this.value.toJSON()),e}}RecipientInfo.CLASS_NAME="RecipientInfo";const Wo="hashAlgorithm",Go="maskGenAlgorithm",zo="pSourceAlgorithm",Qo=[Wo,Go,zo];class RSAESOAEPParams extends PkiObject{constructor(e={}){super(),this.hashAlgorithm=getParametersValue(e,Wo,RSAESOAEPParams.defaultValues(Wo)),this.maskGenAlgorithm=getParametersValue(e,Go,RSAESOAEPParams.defaultValues(Go)),this.pSourceAlgorithm=getParametersValue(e,zo,RSAESOAEPParams.defaultValues(zo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Wo:return new AlgorithmIdentifier({algorithmId:"1.3.14.3.2.26",algorithmParams:new Null});case Go:return new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new AlgorithmIdentifier({algorithmId:"1.3.14.3.2.26",algorithmParams:new Null}).toSchema()});case zo:return new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.9",algorithmParams:new OctetString({valueHex:new Uint8Array([218,57,163,238,94,107,75,13,50,85,191,239,149,96,24,144,175,216,7,9]).buffer})});default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Constructed({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[AlgorithmIdentifier.schema(t.hashAlgorithm||{})]}),new Constructed({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[AlgorithmIdentifier.schema(t.maskGenAlgorithm||{})]}),new Constructed({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[AlgorithmIdentifier.schema(t.pSourceAlgorithm||{})]})]})}fromSchema(e){clearProps(e,Qo);const t=compareSchema(e,e,RSAESOAEPParams.schema({names:{hashAlgorithm:{names:{blockName:Wo}},maskGenAlgorithm:{names:{blockName:Go}},pSourceAlgorithm:{names:{blockName:zo}}}}));AsnError.assertSchema(t,this.className),Wo in t.result&&(this.hashAlgorithm=new AlgorithmIdentifier({schema:t.result.hashAlgorithm})),Go in t.result&&(this.maskGenAlgorithm=new AlgorithmIdentifier({schema:t.result.maskGenAlgorithm})),zo in t.result&&(this.pSourceAlgorithm=new AlgorithmIdentifier({schema:t.result.pSourceAlgorithm}))}toSchema(){const e=[];return this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues(Wo))||e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues(Go))||e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues(zo))||e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.pSourceAlgorithm.toSchema()]})),new Sequence({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(RSAESOAEPParams.defaultValues(Wo))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(RSAESOAEPParams.defaultValues(Go))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.pSourceAlgorithm.isEqual(RSAESOAEPParams.defaultValues(zo))||(e.pSourceAlgorithm=this.pSourceAlgorithm.toJSON()),e}}RSAESOAEPParams.CLASS_NAME="RSAESOAEPParams";const Zo="keyInfo",Yo="entityUInfo",Xo="suppPubInfo",el=[Zo,Yo,Xo];class ECCCMSSharedInfo extends PkiObject{constructor(e={}){super(),this.keyInfo=getParametersValue(e,Zo,ECCCMSSharedInfo.defaultValues(Zo)),Yo in e&&(this.entityUInfo=getParametersValue(e,Yo,ECCCMSSharedInfo.defaultValues(Yo))),this.suppPubInfo=getParametersValue(e,Xo,ECCCMSSharedInfo.defaultValues(Xo)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Zo:return new AlgorithmIdentifier;case Yo:case Xo:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Zo:case Yo:case Xo:return t.isEqual(ECCCMSSharedInfo.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[AlgorithmIdentifier.schema(t.keyInfo||{}),new Constructed({name:t.entityUInfo||Ce,idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[new OctetString]}),new Constructed({name:t.suppPubInfo||Ce,idBlock:{tagClass:3,tagNumber:2},value:[new OctetString]})]})}fromSchema(e){clearProps(e,el);const t=compareSchema(e,e,ECCCMSSharedInfo.schema({names:{keyInfo:{names:{blockName:Zo}},entityUInfo:Yo,suppPubInfo:Xo}}));AsnError.assertSchema(t,this.className),this.keyInfo=new AlgorithmIdentifier({schema:t.result.keyInfo}),Yo in t.result&&(this.entityUInfo=t.result.entityUInfo.valueBlock.value[0]),this.suppPubInfo=t.result.suppPubInfo.valueBlock.value[0]}toSchema(){const e=[];return e.push(this.keyInfo.toSchema()),this.entityUInfo&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.entityUInfo]})),e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.suppPubInfo]})),new Sequence({value:e})}toJSON(){const e={keyInfo:this.keyInfo.toJSON(),suppPubInfo:this.suppPubInfo.toJSON()};return this.entityUInfo&&(e.entityUInfo=this.entityUInfo.toJSON()),e}}ECCCMSSharedInfo.CLASS_NAME="ECCCMSSharedInfo";const tl="version",rl="originatorInfo",sl="recipientInfos",al="encryptedContentInfo",il="unprotectedAttrs",nl=[tl,rl,sl,al,il],ol={kdfAlgorithm:"SHA-512",kekEncryptionLength:256},ll={"P-256":256,"P-384":384,"P-521":528};class EnvelopedData extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,tl,EnvelopedData.defaultValues(tl)),rl in e&&(this.originatorInfo=getParametersValue(e,rl,EnvelopedData.defaultValues(rl))),this.recipientInfos=getParametersValue(e,sl,EnvelopedData.defaultValues(sl)),this.encryptedContentInfo=getParametersValue(e,al,EnvelopedData.defaultValues(al)),il in e&&(this.unprotectedAttrs=getParametersValue(e,il,EnvelopedData.defaultValues(il))),this.policy={disableSplit:!!e.disableSplit},e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tl:return 0;case rl:return new OriginatorInfo;case sl:return[];case al:return new EncryptedContentInfo;case il:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case tl:return t===EnvelopedData.defaultValues(e);case rl:return 0===t.certs.certificates.length&&0===t.crls.crls.length;case sl:case il:return 0===t.length;case al:return EncryptedContentInfo.compareWithDefault("contentType",t.contentType)&&EncryptedContentInfo.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&EncryptedContentInfo.compareWithDefault("encryptedContent",t.encryptedContent);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||Ce}),new Constructed({name:t.originatorInfo||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:OriginatorInfo.schema().valueBlock.value}),new Set({value:[new Repeated({name:t.recipientInfos||Ce,value:RecipientInfo.schema()})]}),EncryptedContentInfo.schema(t.encryptedContentInfo||{}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Repeated({name:t.unprotectedAttrs||Ce,value:Attribute.schema()})]})]})}fromSchema(e){clearProps(e,nl);const t=compareSchema(e,e,EnvelopedData.schema({names:{version:tl,originatorInfo:rl,recipientInfos:sl,encryptedContentInfo:{names:{blockName:al}},unprotectedAttrs:il}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,rl in t.result&&(this.originatorInfo=new OriginatorInfo({schema:new Sequence({value:t.result.originatorInfo.valueBlock.value})})),this.recipientInfos=Array.from(t.result.recipientInfos,e=>new RecipientInfo({schema:e})),this.encryptedContentInfo=new EncryptedContentInfo({schema:t.result.encryptedContentInfo}),il in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new Attribute({schema:e})))}toSchema(){const e=[];return e.push(new Integer({value:this.version})),this.originatorInfo&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:this.originatorInfo.toSchema().valueBlock.value})),e.push(new Set({value:Array.from(this.recipientInfos,e=>e.toSchema())})),e.push(this.encryptedContentInfo.toSchema()),this.unprotectedAttrs&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={version:this.version,recipientInfos:Array.from(this.recipientInfos,e=>e.toJSON()),encryptedContentInfo:this.encryptedContentInfo.toJSON()};return this.originatorInfo&&(e.originatorInfo=this.originatorInfo.toJSON()),this.unprotectedAttrs&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}addRecipientByCertificate(e,t,r,s=getCrypto(!0)){const a=Object.assign({useOAEP:!0,oaepHashAlgorithm:"SHA-512"},ol,t||{});if(-1!==e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549"))r=1;else{if(-1===e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045"))throw new Error(`Unknown type of certificate's public key: ${e.subjectPublicKeyInfo.algorithm.algorithmId}`);r=2}switch(r){case 1:{let t,r;if(!0===a.useOAEP){t=s.getOIDByAlgorithm({name:"RSA-OAEP"},!0,"keyEncryptionAlgorithm");const e=s.getOIDByAlgorithm({name:a.oaepHashAlgorithm},!0,"RSAES-OAEP-params"),i=new AlgorithmIdentifier({algorithmId:e,algorithmParams:new Null});r=new RSAESOAEPParams({hashAlgorithm:i,maskGenAlgorithm:new AlgorithmIdentifier({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:i.toSchema()})}).toSchema()}else{if(t=s.getOIDByAlgorithm({name:"RSAES-PKCS1-v1_5"}),t===Ce)throw new Error("Can not find OID for RSAES-PKCS1-v1_5");r=new Null}const i=new KeyTransRecipientInfo({version:0,rid:new IssuerAndSerialNumber({issuer:e.issuer,serialNumber:e.serialNumber}),keyEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:t,algorithmParams:r}),recipientCertificate:e});this.recipientInfos.push(new RecipientInfo({variant:1,value:i}))}break;case 2:{const t=new KeyAgreeRecipientIdentifier({variant:1,value:new IssuerAndSerialNumber({issuer:e.issuer,serialNumber:e.serialNumber})});this._addKeyAgreeRecipientInfo(t,a,{recipientCertificate:e},s)}break;default:throw new Error(`Unknown "variant" value: ${r}`)}return!0}addRecipientByPreDefinedData(e,t={},r,s=getCrypto(!0)){if(ArgumentError.assert(e,"preDefinedData","ArrayBuffer"),!e.byteLength)throw new Error("Pre-defined data could have zero length");if(!t.keyIdentifier){const e=new ArrayBuffer(16),r=new Uint8Array(e);s.getRandomValues(r),t.keyIdentifier=e}switch(t.hmacHashAlgorithm||(t.hmacHashAlgorithm="SHA-512"),void 0===t.iterationCount&&(t.iterationCount=2048),t.keyEncryptionAlgorithm||(t.keyEncryptionAlgorithm={name:"AES-KW",length:256}),t.keyEncryptionAlgorithmParams||(t.keyEncryptionAlgorithmParams=new Null),r){case 1:{const r=s.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),a=new KEKRecipientInfo({version:4,kekid:new KEKIdentifier({keyIdentifier:new OctetString({valueHex:t.keyIdentifier})}),keyEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:r,algorithmParams:t.keyEncryptionAlgorithmParams}),preDefinedKEK:e});this.recipientInfos.push(new RecipientInfo({variant:3,value:a}))}break;case 2:{const r=s.getOIDByAlgorithm({name:"PBKDF2"},!0,"keyDerivationAlgorithm"),a=new ArrayBuffer(64),i=new Uint8Array(a);s.getRandomValues(i);const n=s.getOIDByAlgorithm({name:"HMAC",hash:{name:t.hmacHashAlgorithm}},!0,"hmacHashAlgorithm"),o=new PBKDF2Params({salt:new OctetString({valueHex:a}),iterationCount:t.iterationCount,prf:new AlgorithmIdentifier({algorithmId:n,algorithmParams:new Null})}),l=s.getOIDByAlgorithm(t.keyEncryptionAlgorithm,!0,"keyEncryptionAlgorithm"),c=new PasswordRecipientinfo({version:0,keyDerivationAlgorithm:new AlgorithmIdentifier({algorithmId:r,algorithmParams:o.toSchema()}),keyEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:l,algorithmParams:t.keyEncryptionAlgorithmParams}),password:e});this.recipientInfos.push(new RecipientInfo({variant:4,value:c}))}break;default:throw new Error(`Unknown value for "variant": ${r}`)}}addRecipientByKeyIdentifier(e,t,r,s=getCrypto(!0)){const a=Object.assign({},ol,r||{}),i=new KeyAgreeRecipientIdentifier({variant:2,value:new RecipientKeyIdentifier({subjectKeyIdentifier:new OctetString({valueHex:t})})});this._addKeyAgreeRecipientInfo(i,a,{recipientPublicKey:e},s)}_addKeyAgreeRecipientInfo(e,t,r,s=getCrypto(!0)){const a=new RecipientEncryptedKey({rid:e}),i=s.getOIDByAlgorithm({name:"AES-KW",length:t.kekEncryptionLength},!0,"keyEncryptionAlgorithm"),n=new AlgorithmIdentifier({algorithmId:i}),o=s.getOIDByAlgorithm({name:"ECDH",kdf:t.kdfAlgorithm},!0,"KeyAgreeRecipientInfo"),l=new ArrayBuffer(64),c=new Uint8Array(l);s.getRandomValues(c);const u={version:3,ukm:new OctetString({valueHex:l}),keyEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:o,algorithmParams:n.toSchema()}),recipientEncryptedKeys:new RecipientEncryptedKeys({encryptedKeys:[a]})},h=new KeyAgreeRecipientInfo(Object.assign(u,r));this.recipientInfos.push(new RecipientInfo({variant:2,value:h}))}async encrypt(e,t,r=getCrypto(!0)){const s=new ArrayBuffer(16),a=new Uint8Array(s);r.getRandomValues(a);const i=new Uint8Array(t),n=r.getOIDByAlgorithm(e,!0,"contentEncryptionAlgorithm"),o=await r.generateKey(e,!0,["encrypt"]),l=await r.encrypt({name:e.name,iv:a},o,i),c=await r.exportKey("raw",o);this.version=2,this.encryptedContentInfo=new EncryptedContentInfo({disableSplit:this.policy.disableSplit,contentType:"1.2.840.113549.1.7.1",contentEncryptionAlgorithm:new AlgorithmIdentifier({algorithmId:n,algorithmParams:new OctetString({valueHex:s})}),encryptedContent:new OctetString({valueHex:l})});const SubKeyAgreeRecipientInfo=async e=>{const t=this.recipientInfos[e].value;let s,a;if(t.recipientPublicKey)s=t.recipientPublicKey.algorithm.namedCurve,a=t.recipientPublicKey;else{if(!t.recipientCertificate)throw new Error("Unsupported RecipientInfo");{const i=t.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(i.constructor.blockName()!==ObjectIdentifier.blockName())throw new Error(`Incorrect "recipientCertificate" for index ${e}`);switch(i.valueBlock.toString()){case"1.2.840.10045.3.1.7":s="P-256";break;case"1.3.132.0.34":s="P-384";break;case"1.3.132.0.35":s="P-521";break;default:throw new Error(`Incorrect curve OID for index ${e}`)}a=await t.recipientCertificate.getPublicKey({algorithm:{algorithm:{name:"ECDH",namedCurve:s},usages:[]}},r)}}const i=ll[s],n=await r.generateKey({name:"ECDH",namedCurve:s},!0,["deriveBits"]),l=await r.exportKey("spki",n.publicKey),c=await r.deriveBits({name:"ECDH",public:a},n.privateKey,i),u=new AlgorithmIdentifier({schema:t.keyEncryptionAlgorithm.algorithmParams}),h=r.getAlgorithmByOID(u.algorithmId,!0,"aesKWAlgorithm");let m=h.length;const f=new ArrayBuffer(4),g=new Uint8Array(f);for(let e=3;e>=0;e--)g[e]=m,m>>=8;const d=new ECCCMSSharedInfo({keyInfo:new AlgorithmIdentifier({algorithmId:u.algorithmId}),entityUInfo:t.ukm,suppPubInfo:new OctetString({valueHex:f})}).toSchema().toBER(!1),p=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm"),S=await kdf(p.kdf,c,h.length,d,r),y=await r.importKey("raw",S,{name:"AES-KW"},!0,["wrapKey"]),w=await r.wrapKey("raw",o,y,{name:"AES-KW"}),v=new OriginatorIdentifierOrKey;return v.variant=3,v.value=OriginatorPublicKey.fromBER(l),t.originator=v,t.recipientEncryptedKeys.encryptedKeys[0].encryptedKey=new OctetString({valueHex:w}),{ecdhPrivateKey:n.privateKey}},SubKeyTransRecipientInfo=async e=>{const t=this.recipientInfos[e].value,s=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if("RSA-OAEP"===s.name){const e=t.keyEncryptionAlgorithm.algorithmParams,a=new RSAESOAEPParams({schema:e});if(s.hash=r.getAlgorithmByOID(a.hashAlgorithm.algorithmId),"name"in s.hash==!1)throw new Error(`Incorrect OID for hash algorithm: ${a.hashAlgorithm.algorithmId}`)}try{const e=await t.recipientCertificate.getPublicKey({algorithm:{algorithm:s,usages:["encrypt","wrapKey"]}},r),a=await r.encrypt(e.algorithm,e,c);t.encryptedKey=new OctetString({valueHex:a})}catch{}},SubKEKRecipientInfo=async e=>{const t=this.recipientInfos[e].value,s=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),a=await r.importKey("raw",new Uint8Array(t.preDefinedKEK),s,!0,["wrapKey"]),i=await r.wrapKey("raw",o,a,s);t.encryptedKey=new OctetString({valueHex:i})},SubPasswordRecipientinfo=async e=>{const t=this.recipientInfos[e].value;let s;if(!t.keyDerivationAlgorithm)throw new Error('Please append encoded "keyDerivationAlgorithm"');if(!t.keyDerivationAlgorithm.algorithmParams)throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');try{s=new PBKDF2Params({schema:t.keyDerivationAlgorithm.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "keyDerivationAlgorithm"')}const a=new Uint8Array(t.password),i=await r.importKey("raw",a,"PBKDF2",!1,["deriveKey"]),n=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm");let l="SHA-1";if(s.prf){l=r.getAlgorithmByOID(s.prf.algorithmId,!0,"prfAlgorithm").hash.name}const c=new Uint8Array(s.salt.valueBlock.valueHex),u=s.iterationCount,h=await r.deriveKey({name:"PBKDF2",hash:{name:l},salt:c,iterations:u},i,n,!0,["wrapKey"]),m=await r.wrapKey("raw",o,h,n);t.encryptedKey=new OctetString({valueHex:m})},u=[];for(let e=0;e<this.recipientInfos.length;e++)switch(this.recipientInfos[e].variant){case 1:u.push(await SubKeyTransRecipientInfo(e));break;case 2:u.push(await SubKeyAgreeRecipientInfo(e));break;case 3:u.push(await SubKEKRecipientInfo(e));break;case 4:u.push(await SubPasswordRecipientinfo(e));break;default:throw new Error(`Unknown recipient type in array with index ${e}`)}return u}async decrypt(e,t,r=getCrypto(!0)){const s=t||{};if(e+1>this.recipientInfos.length)throw new Error('Maximum value for "index" is: '+(this.recipientInfos.length-1));const SubKeyAgreeRecipientInfo=async e=>{const t=this.recipientInfos[e].value;let a,i,n;const o=t.originator;if(s.recipientCertificate){const t=s.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(t.constructor.blockName()!==ObjectIdentifier.blockName())throw new Error(`Incorrect "recipientCertificate" for index ${e}`);a=t.valueBlock.toString()}else{if(!o.value.algorithm.algorithmParams)throw new Error('Parameter "recipientCertificate" is mandatory for "KeyAgreeRecipientInfo" if algorithm params are missing from originator');{const t=o.value.algorithm.algorithmParams;if(t.constructor.blockName()!==ObjectIdentifier.blockName())throw new Error(`Incorrect originator for index ${e}`);a=t.valueBlock.toString()}}if(!s.recipientPrivateKey)throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyAgreeRecipientInfo"');switch(a){case"1.2.840.10045.3.1.7":i="P-256",n=256;break;case"1.3.132.0.34":i="P-384",n=384;break;case"1.3.132.0.35":i="P-521",n=528;break;default:throw new Error(`Incorrect curve OID for index ${e}`)}let l,c=r;BufferSourceConverter.isBufferSource(s.recipientPrivateKey)?l=await r.importKey("pkcs8",s.recipientPrivateKey,{name:"ECDH",namedCurve:i},!0,["deriveBits"]):(l=s.recipientPrivateKey,"crypto"in s&&s.crypto&&(c=s.crypto.subtle)),"algorithmParams"in o.value.algorithm==!1&&(o.value.algorithm.algorithmParams=new ObjectIdentifier({value:a}));const u=o.value.toSchema().toBER(!1),h=await r.importKey("spki",u,{name:"ECDH",namedCurve:i},!0,[]),m=await c.deriveBits({name:"ECDH",public:h},l,n);async function applyKDF(e){e=e||!1;const s=new AlgorithmIdentifier({schema:t.keyEncryptionAlgorithm.algorithmParams}),a=r.getAlgorithmByOID(s.algorithmId,!0,"kwAlgorithm");let i=a.length;const n=new ArrayBuffer(4),o=new Uint8Array(n);for(let e=3;e>=0;e--)o[e]=i,i>>=8;const l={algorithmId:s.algorithmId};e&&(l.algorithmParams=new Null);const c=new ECCCMSSharedInfo({keyInfo:new AlgorithmIdentifier(l),entityUInfo:t.ukm,suppPubInfo:new OctetString({valueHex:n})}).toSchema().toBER(!1),u=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"ecdhAlgorithm");if(!u.name)throw new Error(`Incorrect OID for key encryption algorithm: ${t.keyEncryptionAlgorithm.algorithmId}`);return kdf(u.kdf,m,a.length,c,r)}const f=await applyKDF(),importAesKwKey=async e=>r.importKey("raw",e,{name:"AES-KW"},!0,["unwrapKey"]),g=await importAesKwKey(f),unwrapSessionKey=async e=>{const s=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,a=r.getAlgorithmByOID(s,!0,"contentEncryptionAlgorithm");return r.unwrapKey("raw",t.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHexView,e,{name:"AES-KW"},a,!0,["decrypt"])};try{return await unwrapSessionKey(g)}catch{const e=await applyKDF(!0);return unwrapSessionKey(await importAesKwKey(e))}},SubKeyTransRecipientInfo=async e=>{const t=this.recipientInfos[e].value;if(!s.recipientPrivateKey)throw new Error('Parameter "recipientPrivateKey" is mandatory for "KeyTransRecipientInfo"');const a=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm");if("RSA-OAEP"===a.name){const e=t.keyEncryptionAlgorithm.algorithmParams,s=new RSAESOAEPParams({schema:e});if(a.hash=r.getAlgorithmByOID(s.hashAlgorithm.algorithmId),"name"in a.hash==!1)throw new Error(`Incorrect OID for hash algorithm: ${s.hashAlgorithm.algorithmId}`)}let i,n=r;BufferSourceConverter.isBufferSource(s.recipientPrivateKey)?i=await r.importKey("pkcs8",s.recipientPrivateKey,a,!0,["decrypt"]):(i=s.recipientPrivateKey,"crypto"in s&&s.crypto&&(n=s.crypto.subtle));const o=await n.decrypt(i.algorithm,i,t.encryptedKey.valueBlock.valueHexView),l=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,c=r.getAlgorithmByOID(l,!0,"contentEncryptionAlgorithm");if("name"in c==!1)throw new Error(`Incorrect "contentEncryptionAlgorithm": ${l}`);return r.importKey("raw",o,c,!0,["decrypt"])},SubKEKRecipientInfo=async e=>{const t=this.recipientInfos[e].value;if(!s.preDefinedData)throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');const a=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"kekAlgorithm"),i=await r.importKey("raw",s.preDefinedData,a,!0,["unwrapKey"]),n=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,o=r.getAlgorithmByOID(n,!0,"contentEncryptionAlgorithm");if(!o.name)throw new Error(`Incorrect "contentEncryptionAlgorithm": ${n}`);return r.unwrapKey("raw",t.encryptedKey.valueBlock.valueHexView,i,a,o,!0,["decrypt"])},SubPasswordRecipientinfo=async e=>{const t=this.recipientInfos[e].value;let a;if(!s.preDefinedData)throw new Error('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');if(!t.keyDerivationAlgorithm)throw new Error('Please append encoded "keyDerivationAlgorithm"');if(!t.keyDerivationAlgorithm.algorithmParams)throw new Error('Incorrectly encoded "keyDerivationAlgorithm"');try{a=new PBKDF2Params({schema:t.keyDerivationAlgorithm.algorithmParams})}catch(e){throw new Error('Incorrectly encoded "keyDerivationAlgorithm"')}const i=await r.importKey("raw",s.preDefinedData,"PBKDF2",!1,["deriveKey"]),n=r.getAlgorithmByOID(t.keyEncryptionAlgorithm.algorithmId,!0,"keyEncryptionAlgorithm"),o=a.prf?r.getAlgorithmByOID(a.prf.algorithmId,!0,"prfAlgorithm").hash.name:"SHA-1",l=new Uint8Array(a.salt.valueBlock.valueHex),c=a.iterationCount,u=await r.deriveKey({name:"PBKDF2",hash:{name:o},salt:l,iterations:c},i,n,!0,["unwrapKey"]),h=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,m=r.getAlgorithmByOID(h,!0,"contentEncryptionAlgorithm");return r.unwrapKey("raw",t.encryptedKey.valueBlock.valueHexView,u,n,m,!0,["decrypt"])};let a;switch(this.recipientInfos[e].variant){case 1:a=await SubKeyTransRecipientInfo(e);break;case 2:a=await SubKeyAgreeRecipientInfo(e);break;case 3:a=await SubKEKRecipientInfo(e);break;case 4:a=await SubPasswordRecipientinfo(e);break;default:throw new Error(`Unknown recipient type in array with index ${e}`)}const i=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId,n=r.getAlgorithmByOID(i,!0,"contentEncryptionAlgorithm"),o=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex,l=new Uint8Array(o);if(!this.encryptedContentInfo.encryptedContent)throw new Error("Required property `encryptedContent` is empty");const c=this.encryptedContentInfo.getEncryptedContent();return r.decrypt({name:n.name,iv:l},a,c)}}EnvelopedData.CLASS_NAME="EnvelopedData";const cl="safeContents",ul="parsedValue",hl="contentInfos";class AuthenticatedSafe extends PkiObject{constructor(e={}){super(),this.safeContents=getParametersValue(e,cl,AuthenticatedSafe.defaultValues(cl)),ul in e&&(this.parsedValue=getParametersValue(e,ul,AuthenticatedSafe.defaultValues(ul))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case cl:return[];case ul:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case cl:return 0===t.length;case ul:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Repeated({name:t.contentInfos||Ce,value:ContentInfo.schema()})]})}fromSchema(e){clearProps(e,[hl]);const t=compareSchema(e,e,AuthenticatedSafe.schema({names:{contentInfos:hl}}));AsnError.assertSchema(t,this.className),this.safeContents=Array.from(t.result.contentInfos,e=>new ContentInfo({schema:e}))}toSchema(){return new Sequence({value:Array.from(this.safeContents,e=>e.toSchema())})}toJSON(){return{safeContents:Array.from(this.safeContents,e=>e.toJSON())}}async parseInternalValues(e,t=getCrypto(!0)){if(ParameterError.assert(e,cl),ArgumentError.assert(e.safeContents,cl,"Array"),e.safeContents.length!==this.safeContents.length)throw new ArgumentError('Length of "parameters.safeContents" must be equal to "this.safeContents.length"');this.parsedValue={safeContents:[]};for(const[r,s]of this.safeContents.entries()){const a=e.safeContents[r],i=`parameters.safeContents[${r}]`;switch(s.contentType){case mt:{ArgumentError.assert(s.content,"this.safeContents[j].content",OctetString);const e=s.content.getValue();this.parsedValue.safeContents.push({privacyMode:0,value:SafeContents.fromBER(e)})}break;case gt:{const e=new EnvelopedData({schema:s.content});ParameterError.assert(i,a,"recipientCertificate","recipientKey");const r=a,n=r.recipientCertificate,o=r.recipientKey,l=await e.decrypt(0,{recipientCertificate:n,recipientPrivateKey:o},t);this.parsedValue.safeContents.push({privacyMode:2,value:SafeContents.fromBER(l)})}break;case dt:{const e=new EncryptedData({schema:s.content});ParameterError.assert(i,a,"password");const r=a.password,n=await e.decrypt({password:r},t);this.parsedValue.safeContents.push({privacyMode:1,value:SafeContents.fromBER(n)})}break;default:throw new Error(`Unknown "contentType" for AuthenticatedSafe: " ${s.contentType}`)}}}async makeInternalValues(e,t=getCrypto(!0)){if(!this.parsedValue)throw new Error('Please run "parseValues" first or add "parsedValue" manually');if(ArgumentError.assert(this.parsedValue,"this.parsedValue","object"),ArgumentError.assert(this.parsedValue.safeContents,"this.parsedValue.safeContents","Array"),ArgumentError.assert(e,"parameters","object"),ParameterError.assert(e,"safeContents"),ArgumentError.assert(e.safeContents,"parameters.safeContents","Array"),e.safeContents.length!==this.parsedValue.safeContents.length)throw new ArgumentError('Length of "parameters.safeContents" must be equal to "this.parsedValue.safeContents"');this.safeContents=[];for(const[r,s]of this.parsedValue.safeContents.entries())switch(ParameterError.assert("content",s,"privacyMode","value"),ArgumentError.assert(s.value,"content.value",SafeContents),s.privacyMode){case 0:{const e=s.value.toSchema().toBER(!1);this.safeContents.push(new ContentInfo({contentType:"1.2.840.113549.1.7.1",content:new OctetString({valueHex:e})}))}break;case 1:{const a=new EncryptedData,i=e.safeContents[r];i.contentToEncrypt=s.value.toSchema().toBER(!1),await a.encrypt(i,t),this.safeContents.push(new ContentInfo({contentType:"1.2.840.113549.1.7.6",content:a.toSchema()}))}break;case 2:{const a=new EnvelopedData,i=s.value.toSchema().toBER(!1),n=e.safeContents[r];switch(ParameterError.assert(`parameters.safeContents[${r}]`,n,"encryptingCertificate","encryptionAlgorithm"),!0){case"aes-cbc"===n.encryptionAlgorithm.name.toLowerCase():case"aes-gcm"===n.encryptionAlgorithm.name.toLowerCase():break;default:throw new Error(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${n.encryptionAlgorithm}`)}switch(!0){case 128===n.encryptionAlgorithm.length:case 192===n.encryptionAlgorithm.length:case 256===n.encryptionAlgorithm.length:break;default:throw new Error(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${n.encryptionAlgorithm.length}`)}const o=n.encryptionAlgorithm;a.addRecipientByCertificate(n.encryptingCertificate,{},void 0,t),await a.encrypt(o,i,t),this.safeContents.push(new ContentInfo({contentType:"1.2.840.113549.1.7.3",content:a.toSchema()}))}break;default:throw new Error(`Incorrect value for "content.privacyMode": ${s.privacyMode}`)}return this}}AuthenticatedSafe.CLASS_NAME="AuthenticatedSafe";const ml="hashAlgorithm",fl="issuerNameHash",gl="issuerKeyHash",dl="serialNumber",pl=[ml,fl,gl,dl];class CertID extends PkiObject{static async create(e,t,r=getCrypto(!0)){const s=new CertID;return await s.createForCertificate(e,t,r),s}constructor(e={}){super(),this.hashAlgorithm=getParametersValue(e,ml,CertID.defaultValues(ml)),this.issuerNameHash=getParametersValue(e,fl,CertID.defaultValues(fl)),this.issuerKeyHash=getParametersValue(e,gl,CertID.defaultValues(gl)),this.serialNumber=getParametersValue(e,dl,CertID.defaultValues(dl)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ml:return new AlgorithmIdentifier;case fl:case gl:return new OctetString;case dl:return new Integer;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ml:return t.algorithmId===Ce&&"algorithmParams"in t==!1;case fl:case gl:case dl:return t.isEqual(CertID.defaultValues(dl));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[AlgorithmIdentifier.schema(t.hashAlgorithmObject||{names:{blockName:t.hashAlgorithm||Ce}}),new OctetString({name:t.issuerNameHash||Ce}),new OctetString({name:t.issuerKeyHash||Ce}),new Integer({name:t.serialNumber||Ce})]})}fromSchema(e){clearProps(e,pl);const t=compareSchema(e,e,CertID.schema({names:{hashAlgorithm:ml,issuerNameHash:fl,issuerKeyHash:gl,serialNumber:dl}}));AsnError.assertSchema(t,this.className),this.hashAlgorithm=new AlgorithmIdentifier({schema:t.result.hashAlgorithm}),this.issuerNameHash=t.result.issuerNameHash,this.issuerKeyHash=t.result.issuerKeyHash,this.serialNumber=t.result.serialNumber}toSchema(){return new Sequence({value:[this.hashAlgorithm.toSchema(),this.issuerNameHash,this.issuerKeyHash,this.serialNumber]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),issuerNameHash:this.issuerNameHash.toJSON(),issuerKeyHash:this.issuerKeyHash.toJSON(),serialNumber:this.serialNumber.toJSON()}}isEqual(e){return this.hashAlgorithm.algorithmId===e.hashAlgorithm.algorithmId&&(!!BufferSourceConverter.isEqual(this.issuerNameHash.valueBlock.valueHexView,e.issuerNameHash.valueBlock.valueHexView)&&(!!BufferSourceConverter.isEqual(this.issuerKeyHash.valueBlock.valueHexView,e.issuerKeyHash.valueBlock.valueHexView)&&!!this.serialNumber.isEqual(e.serialNumber)))}async createForCertificate(e,t,r=getCrypto(!0)){ParameterError.assert(t,ml,"issuerCertificate");const s=r.getOIDByAlgorithm({name:t.hashAlgorithm},!0,"hashAlgorithm");this.hashAlgorithm=new AlgorithmIdentifier({algorithmId:s,algorithmParams:new Null});const a=t.issuerCertificate;this.serialNumber=e.serialNumber;const i=await r.digest({name:t.hashAlgorithm},a.subject.toSchema().toBER(!1));this.issuerNameHash=new OctetString({valueHex:i});const n=a.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView,o=await r.digest({name:t.hashAlgorithm},n);this.issuerKeyHash=new OctetString({valueHex:o})}}CertID.CLASS_NAME="CertID";const Sl="certID",yl="certStatus",wl="thisUpdate",vl="nextUpdate",bl="singleExtensions",Al=[Sl,yl,wl,vl,bl];class SingleResponse extends PkiObject{constructor(e={}){super(),this.certID=getParametersValue(e,Sl,SingleResponse.defaultValues(Sl)),this.certStatus=getParametersValue(e,yl,SingleResponse.defaultValues(yl)),this.thisUpdate=getParametersValue(e,wl,SingleResponse.defaultValues(wl)),vl in e&&(this.nextUpdate=getParametersValue(e,vl,SingleResponse.defaultValues(vl))),bl in e&&(this.singleExtensions=getParametersValue(e,bl,SingleResponse.defaultValues(bl))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Sl:return new CertID;case yl:return{};case wl:case vl:return new Date(0,0,0);case bl:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Sl:return CertID.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&CertID.compareWithDefault("issuerNameHash",t.issuerNameHash)&&CertID.compareWithDefault("issuerKeyHash",t.issuerKeyHash)&&CertID.compareWithDefault("serialNumber",t.serialNumber);case yl:return 0===Object.keys(t).length;case wl:case vl:return t===SingleResponse.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[CertID.schema(t.certID||{}),new Choice({value:[new Primitive({name:t.certStatus||Ce,idBlock:{tagClass:3,tagNumber:0}}),new Constructed({name:t.certStatus||Ce,idBlock:{tagClass:3,tagNumber:1},value:[new GeneralizedTime,new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Enumerated]})]}),new Primitive({name:t.certStatus||Ce,idBlock:{tagClass:3,tagNumber:2},lenBlock:{length:1}})]}),new GeneralizedTime({name:t.thisUpdate||Ce}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new GeneralizedTime({name:t.nextUpdate||Ce})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[Extensions.schema(t.singleExtensions||{})]})]})}fromSchema(e){clearProps(e,Al);const t=compareSchema(e,e,SingleResponse.schema({names:{certID:{names:{blockName:Sl}},certStatus:yl,thisUpdate:wl,nextUpdate:vl,singleExtensions:{names:{blockName:bl}}}}));AsnError.assertSchema(t,this.className),this.certID=new CertID({schema:t.result.certID}),this.certStatus=t.result.certStatus,this.thisUpdate=t.result.thisUpdate.toDate(),vl in t.result&&(this.nextUpdate=t.result.nextUpdate.toDate()),bl in t.result&&(this.singleExtensions=Array.from(t.result.singleExtensions.valueBlock.value,e=>new Extension({schema:e})))}toSchema(){const e=[];return e.push(this.certID.toSchema()),e.push(this.certStatus),e.push(new GeneralizedTime({valueDate:this.thisUpdate})),this.nextUpdate&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new GeneralizedTime({valueDate:this.nextUpdate})]})),this.singleExtensions&&e.push(new Sequence({value:Array.from(this.singleExtensions,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={certID:this.certID.toJSON(),certStatus:this.certStatus.toJSON(),thisUpdate:this.thisUpdate};return this.nextUpdate&&(e.nextUpdate=this.nextUpdate),this.singleExtensions&&(e.singleExtensions=Array.from(this.singleExtensions,e=>e.toJSON())),e}}SingleResponse.CLASS_NAME="SingleResponse";const kl="tbs",Cl="version",Vl="responderID",Bl="producedAt",Il="responses",Nl="responseExtensions",Pl="ResponseData",El=`${Pl}.${Cl}`,Dl=`${Pl}.${Vl}`,Ol=`${Pl}.${Bl}`,xl=`${Pl}.${Il}`,Rl=`${Pl}.${Nl}`,Kl=[Pl,El,Dl,Ol,xl,Rl];class ResponseData extends PkiObject{get tbs(){return BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(getParametersValue(e,kl,ResponseData.defaultValues(kl))),Cl in e&&(this.version=getParametersValue(e,Cl,ResponseData.defaultValues(Cl))),this.responderID=getParametersValue(e,Vl,ResponseData.defaultValues(Vl)),this.producedAt=getParametersValue(e,Bl,ResponseData.defaultValues(Bl)),this.responses=getParametersValue(e,Il,ResponseData.defaultValues(Il)),Nl in e&&(this.responseExtensions=getParametersValue(e,Nl,ResponseData.defaultValues(Nl))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Cl:return 0;case kl:return ke;case Vl:return{};case Bl:return new Date(0,0,0);case Il:case Nl:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case kl:return 0===t.byteLength;case Vl:return 0===Object.keys(t).length;case Bl:return t===ResponseData.defaultValues(e);case Il:case Nl:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Pl,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Integer({name:t.version||El})]}),new Choice({value:[new Constructed({name:t.responderID||Dl,idBlock:{tagClass:3,tagNumber:1},value:[RelativeDistinguishedNames.schema(t.ResponseDataByName||{names:{blockName:"ResponseData.byName"}})]}),new Constructed({name:t.responderID||Dl,idBlock:{tagClass:3,tagNumber:2},value:[new OctetString({name:t.ResponseDataByKey||"ResponseData.byKey"})]})]}),new GeneralizedTime({name:t.producedAt||Ol}),new Sequence({value:[new Repeated({name:xl,value:SingleResponse.schema(t.response||{})})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[Extensions.schema(t.extensions||{names:{blockName:Rl}})]})]})}fromSchema(e){clearProps(e,Kl);const t=compareSchema(e,e,ResponseData.schema());AsnError.assertSchema(t,this.className),this.tbsView=t.result.ResponseData.valueBeforeDecodeView,El in t.result&&(this.version=t.result[El].valueBlock.valueDec),1===t.result[Dl].idBlock.tagNumber?this.responderID=new RelativeDistinguishedNames({schema:t.result[Dl].valueBlock.value[0]}):this.responderID=t.result[Dl].valueBlock.value[0],this.producedAt=t.result[Ol].toDate(),this.responses=Array.from(t.result[xl],e=>new SingleResponse({schema:e})),Rl in t.result&&(this.responseExtensions=Array.from(t.result[Rl].valueBlock.value,e=>new Extension({schema:e})))}toSchema(e=!1){let t;if(!1===e){if(!this.tbsView.byteLength)return ResponseData.schema();const e=fromBER(this.tbsView);AsnError.assert(e,"TBS Response Data"),t=e.result}else{const e=[];Cl in this&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Integer({value:this.version})]})),this.responderID instanceof RelativeDistinguishedNames?e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.responderID.toSchema()]})):e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:[this.responderID]})),e.push(new GeneralizedTime({valueDate:this.producedAt})),e.push(new Sequence({value:Array.from(this.responses,e=>e.toSchema())})),this.responseExtensions&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[new Sequence({value:Array.from(this.responseExtensions,e=>e.toSchema())})]})),t=new Sequence({value:e})}return t}toJSON(){const e={};return Cl in this&&(e.version=this.version),this.responderID&&(e.responderID=this.responderID),this.producedAt&&(e.producedAt=this.producedAt),this.responses&&(e.responses=Array.from(this.responses,e=>e.toJSON())),this.responseExtensions&&(e.responseExtensions=Array.from(this.responseExtensions,e=>e.toJSON())),e}}ResponseData.CLASS_NAME="ResponseData";const Ul="trustedCerts",Tl="certs",Ll="crls",Hl="ocsps",ql="checkDate",jl="findOrigin",Ml="findIssuer";var Jl;!function(e){e[e.unknown=-1]="unknown",e[e.success=0]="success",e[e.noRevocation=11]="noRevocation",e[e.noPath=60]="noPath",e[e.noValidPath=97]="noValidPath"}(Jl||(Jl={}));class ChainValidationError extends Error{constructor(e,t){super(t),this.name=ChainValidationError.NAME,this.code=e,this.message=t}}ChainValidationError.NAME="ChainValidationError";class CertificateChainValidationEngine{constructor(e={}){this.trustedCerts=getParametersValue(e,Ul,this.defaultValues(Ul)),this.certs=getParametersValue(e,Tl,this.defaultValues(Tl)),this.crls=getParametersValue(e,Ll,this.defaultValues(Ll)),this.ocsps=getParametersValue(e,Hl,this.defaultValues(Hl)),this.checkDate=getParametersValue(e,ql,this.defaultValues(ql)),this.findOrigin=getParametersValue(e,jl,this.defaultValues(jl)),this.findIssuer=getParametersValue(e,Ml,this.defaultValues(Ml))}static defaultFindOrigin(e,t){0===e.tbsView.byteLength&&(e.tbsView=new Uint8Array(e.encodeTBS().toBER()));for(const r of t.certs)if(0===r.tbsView.byteLength&&(r.tbsView=new Uint8Array(r.encodeTBS().toBER())),BufferSourceConverter.isEqual(e.tbsView,r.tbsView))return"Intermediate Certificates";for(const r of t.trustedCerts)if(0===r.tbsView.byteLength&&(r.tbsView=new Uint8Array(r.encodeTBS().toBER())),BufferSourceConverter.isEqual(e.tbsView,r.tbsView))return"Trusted Certificates";return"Unknown"}async defaultFindIssuer(e,t,r=getCrypto(!0)){const s=[];let a=null,i=null,n=null;if(e.subject.isEqual(e.issuer))try{if(await e.verify(void 0,r))return[e]}catch(e){}if(e.extensions)for(const t of e.extensions)if(t.extnID===ct&&t.parsedValue instanceof AuthorityKeyIdentifier){t.parsedValue.keyIdentifier?a=t.parsedValue.keyIdentifier:(t.parsedValue.authorityCertIssuer&&(i=t.parsedValue.authorityCertIssuer),t.parsedValue.authorityCertSerialNumber&&(n=t.parsedValue.authorityCertSerialNumber));break}function checkCertificate(t){if(null!==a&&t.extensions){let e=!1;for(const r of t.extensions)if("2.5.29.14"===r.extnID&&r.parsedValue){e=!0,BufferSourceConverter.isEqual(r.parsedValue.valueBlock.valueHex,a.valueBlock.valueHexView)&&s.push(t);break}if(e)return}let r=!1;null!==n&&(r=t.serialNumber.isEqual(n)),null!==i?t.subject.isEqual(i)&&r&&s.push(t):e.issuer.isEqual(t.subject)&&s.push(t)}for(const e of t.trustedCerts)checkCertificate(e);for(const e of t.certs)checkCertificate(e);for(let t=s.length-1;t>=0;t--)try{!1===await e.verify(s[t],r)&&s.splice(t,1)}catch(e){s.splice(t,1)}return s}defaultValues(e){switch(e){case Ul:case Tl:case Ll:case Hl:return[];case ql:return new Date;case jl:return CertificateChainValidationEngine.defaultFindOrigin;case Ml:return this.defaultFindIssuer;default:throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${e}`)}}async sort(e=!1,t=getCrypto(!0)){const r=[],buildPath=async(e,t)=>{const r=[];function checkUnique(e){let t=!0;for(let r=0;r<e.length;r++){for(let s=0;s<e.length;s++)if(s!==r&&e[r]===e[s]){t=!1;break}if(!t)break}return t}if(function(e,t){for(let r=0;r<t.length;r++)if(BufferSourceConverter.isEqual(e.tbsView,t[r].tbsView))return!0;return!1}(e,this.trustedCerts))return[[e]];const s=await this.findIssuer(e,this,t);if(0===s.length)throw new Error("No valid certificate paths found");for(let a=0;a<s.length;a++){if(BufferSourceConverter.isEqual(s[a].tbsView,e.tbsView)){r.push([s[a]]);continue}const i=await buildPath(s[a],t);for(let e=0;e<i.length;e++){const t=i[e].slice();t.splice(0,0,s[a]),checkUnique(t)?r.push(t):r.push(i[e])}}return r},findCRL=async e=>{const s=[],a=[],i=[];if(s.push(...r.filter(t=>e.issuer.isEqual(t.subject))),0===s.length)return{status:1,statusMessage:"No certificate's issuers"};if(a.push(...this.crls.filter(t=>t.issuer.isEqual(e.issuer))),0===a.length)return{status:2,statusMessage:"No CRLs for specific certificate issuer"};for(let e=0;e<a.length;e++){const r=a[e];if(!(r.nextUpdate&&r.nextUpdate.value<this.checkDate))for(let r=0;r<s.length;r++)try{if(await a[e].verify({issuerCertificate:s[r]},t)){i.push({crl:a[e],certificate:s[r]});break}}catch(e){}}return i.length?{status:0,statusMessage:Ce,result:i}:{status:3,statusMessage:"No valid CRLs found"}},findOCSP=async(e,r)=>{const s=t.getAlgorithmByOID(e.signatureAlgorithm.algorithmId);if(!s.name)return 1;if(!s.hash)return 1;for(let s=0;s<this.ocsps.length;s++){const a=this.ocsps[s],i=await a.getCertificateStatus(e,r,t);if(i.isForCertificate)return 0===i.status?0:1}return 2};async function checkForCA(e,t=!1){let r=!1,s=!1,a=!1,i=!1;if(e.extensions){for(let t=0;t<e.extensions.length;t++){const n=e.extensions[t];if(n.critical&&!n.parsedValue)return{result:!1,resultCode:6,resultMessage:`Unable to parse critical certificate extension: ${n.extnID}`};if("2.5.29.15"===n.extnID){a=!0;const e=new Uint8Array(n.parsedValue.valueBlock.valueHex);4&~e[0]||(s=!0),2&~e[0]||(i=!0)}n.extnID===et&&"cA"in n.parsedValue&&!0===n.parsedValue.cA&&(r=!0)}if(!0===s&&!1===r)return{result:!1,resultCode:3,resultMessage:'Unable to build certificate chain - using "keyCertSign" flag set without BasicConstraints'};if(!0===a&&!0===r&&!1===s)return{result:!1,resultCode:4,resultMessage:'Unable to build certificate chain - "keyCertSign" flag was not set'};if(!0===r&&!0===a&&t&&!1===i)return{result:!1,resultCode:5,resultMessage:'Unable to build certificate chain - intermediate certificate must have "cRLSign" key usage flag'}}return!1===r?{result:!1,resultCode:7,resultMessage:"Unable to build certificate chain - more than one possible end-user certificate"}:{result:!0,resultCode:0,resultMessage:Ce}}r.push(...this.trustedCerts),r.push(...this.certs);for(let e=0;e<r.length;e++)for(let t=0;t<r.length;t++)if(e!==t&&BufferSourceConverter.isEqual(r[e].tbsView,r[t].tbsView)){r.splice(t,1),e=0;break}const s=r[r.length-1];let a;const i=[s];if(a=await buildPath(s,t),0===a.length)throw new ChainValidationError(Jl.noPath,"Unable to find certificate path");for(let e=a.length-1;e>=0;e--){let t=!1;for(let r=0;r<a[e].length;r++){const s=a[e][r];for(let e=0;e<this.trustedCerts.length;e++)if(BufferSourceConverter.isEqual(s.tbsView,this.trustedCerts[e].tbsView)){t=!0;break}if(t)break}t||a.splice(e,1)}if(0===a.length)throw new ChainValidationError(Jl.noValidPath,"No valid certificate paths found");let n=a[0].length,o=0;for(let e=0;e<a.length;e++)a[e].length<n&&(n=a[e].length,o=e);for(let e=0;e<a[o].length;e++)i.push(a[o][e]);if(a=await(async(t,r)=>{for(let e=0;e<t.length;e++)if(t[e].notBefore.value>r||t[e].notAfter.value<r)return{result:!1,resultCode:8,resultMessage:"The certificate is either not yet valid or expired"};if(t.length<2)return{result:!1,resultCode:9,resultMessage:"Too short certificate path"};for(let e=t.length-2;e>=0;e--)if(!1===t[e].issuer.isEqual(t[e].subject)&&!1===t[e].issuer.isEqual(t[e+1].subject))return{result:!1,resultCode:10,resultMessage:"Incorrect name chaining"};if(0!==this.crls.length||0!==this.ocsps.length)for(let r=0;r<t.length-1;r++){let s=2,a={status:0,statusMessage:Ce};if(0!==this.ocsps.length)switch(s=await findOCSP(t[r],t[r+1]),s){case 0:continue;case 1:return{result:!1,resultCode:12,resultMessage:"One of certificates was revoked via OCSP response"}}if(0!==this.crls.length){if(a=await findCRL(t[r]),0===a.status&&a.result)for(let e=0;e<a.result.length;e++){if(a.result[e].crl.isCertificateRevoked(t[r]))return{result:!1,resultCode:12,resultMessage:"One of certificates had been revoked"};if(!1===(await checkForCA(a.result[e].certificate,!0)).result)return{result:!1,resultCode:13,resultMessage:"CRL issuer certificate is not a CA certificate or does not have crlSign flag"}}else if(!1===e)throw new ChainValidationError(Jl.noRevocation,`No revocation values found for one of certificates: ${a.statusMessage}`)}else if(2===s)return{result:!1,resultCode:11,resultMessage:"No revocation values found for one of certificates"};if(2===s&&2===a.status&&e){const e=t[r+1];let s=!1;if(e.extensions)for(const t of e.extensions)switch(t.extnID){case at:case it:case ht:s=!0}if(s)throw new ChainValidationError(Jl.noRevocation,`No revocation values found for one of certificates: ${a.statusMessage}`)}}for(const[e,r]of t.entries()){if(!e)continue;if(!(await checkForCA(r)).result)return{result:!1,resultCode:14,resultMessage:"One of intermediate certificates is not a CA certificate"}}return{result:!0}})(i,this.checkDate),!1===a.result)throw a;return i}async verify(e={},t=getCrypto(!0)){function compareDNSName(e,t){const r=stringPrep(e),s=stringPrep(t),a=r.split("."),i=s.split("."),n=a.length,o=i.length;if(0===n||0===o||n<o)return!1;for(let e=0;e<n;e++)if(0===a[e].length)return!1;for(let e=0;e<o;e++)if(0===i[e].length){if(0===e){if(1===o)return!1;continue}return!1}for(let e=0;e<o;e++)if(0!==i[o-1-e].length&&0!==a[n-1-e].localeCompare(i[o-1-e]))return!1;return!0}function compareRFC822Name(e,t){const r=stringPrep(e),s=stringPrep(t),a=r.split("@"),i=s.split("@");if(0===a.length||0===i.length||a.length<i.length)return!1;if(1===i.length){if(compareDNSName(a[1],i[0])){const e=a[1].split("."),t=i[0].split(".");return 0===t[0].length||e.length===t.length}return!1}return 0===r.localeCompare(s)}function compareUniformResourceIdentifier(e,t){let r=stringPrep(e);const s=stringPrep(t),a=r.split("/");if(s.split("/").length>1)return!1;if(a.length>1)for(let e=0;e<a.length;e++)if(a[e].length>0&&":"!==a[e].charAt(a[e].length-1)){r=a[e].split(":")[0];break}if(compareDNSName(r,s)){const e=r.split("."),t=s.split(".");return 0===t[0].length||e.length===t.length}return!1}function compareIPAddress(e,t){const r=e.valueBlock.valueHexView,s=t.valueBlock.valueHexView;if(4===r.length&&8===s.length){for(let e=0;e<4;e++)if((r[e]^s[e])&s[e+4])return!1;return!0}if(16===r.length&&32===s.length){for(let e=0;e<16;e++)if((r[e]^s[e])&s[e+16])return!1;return!0}return!1}function compareDirectoryName(e,t){if(0===e.typesAndValues.length||0===t.typesAndValues.length)return!0;if(e.typesAndValues.length<t.typesAndValues.length)return!1;let r=!0,s=0;for(let a=0;a<t.typesAndValues.length;a++){let i=!1;for(let n=s;n<e.typesAndValues.length;n++)if(i=e.typesAndValues[n].isEqual(t.typesAndValues[a]),e.typesAndValues[n].type===t.typesAndValues[a].type&&(r=r&&i),!0===i){if(0===s||s===n){s=n+1;break}return!1}if(!1===i)return!1}return 0!==s&&r}try{if(0===this.certs.length)throw new Error("Empty certificate array");const r=e.passedWhenNotRevValues||!1,s=e.initialPolicySet||[ot],a=e.initialExplicitPolicy||!1,i=e.initialPolicyMappingInhibit||!1,n=e.initialInhibitPolicy||!1,o=e.initialPermittedSubtreesSet||[],l=e.initialExcludedSubtreesSet||[],c=e.initialRequiredNameForms||[];let u=a,h=i,m=n;const f=[!1,!1,!1];let g=0,d=0,p=0,S=o,y=l;const w=c;let v=1;this.certs=await this.sort(r,t);const b=[];b.push(ot);const A=[],k=new Array(this.certs.length-1);for(let e=0;e<this.certs.length-1;e++)k[e]=!0;A.push(k);const C=new Array(this.certs.length-1),V=new Array(this.certs.length-1);let B=u?this.certs.length-1:-1;for(let e=this.certs.length-2;e>=0;e--,v++){const t=this.certs[e];if(t.extensions){for(let r=0;r<t.extensions.length;r++){const s=t.extensions[r];if(s.extnID===nt){V[e]=s.parsedValue;for(let t=0;t<b.length;t++)if(b[t]===ot){delete A[t][e];break}for(let t=0;t<s.parsedValue.certificatePolicies.length;t++){let r=-1;const a=s.parsedValue.certificatePolicies[t].policyIdentifier;for(let e=0;e<b.length;e++)if(a===b[e]){r=e;break}if(-1===r){b.push(a);const t=new Array(this.certs.length-1);t[e]=!0,A.push(t)}else A[r][e]=!0}}if(s.extnID===lt){if(h)return{result:!1,resultCode:98,resultMessage:"Policy mapping prohibited"};C[e]=s.parsedValue}s.extnID===ut&&!1===u&&(0===s.parsedValue.requireExplicitPolicy?(u=!0,B=e):!1===f[0]?(f[0]=!0,g=s.parsedValue.requireExplicitPolicy):g=g>s.parsedValue.requireExplicitPolicy?s.parsedValue.requireExplicitPolicy:g,0===s.parsedValue.inhibitPolicyMapping?h=!0:!1===f[1]?(f[1]=!0,d=s.parsedValue.inhibitPolicyMapping+1):d=d>s.parsedValue.inhibitPolicyMapping+1?s.parsedValue.inhibitPolicyMapping+1:d),"2.5.29.54"===s.extnID&&!1===m&&(0===s.parsedValue.valueBlock.valueDec?m=!0:!1===f[2]?(f[2]=!0,p=s.parsedValue.valueBlock.valueDec):p=p>s.parsedValue.valueBlock.valueDec?s.parsedValue.valueBlock.valueDec:p)}if(!0===m){let t=-1;for(let e=0;e<b.length;e++)if(b[e]===ot){t=e;break}-1!==t&&delete A[0][e]}!1===u&&!0===f[0]&&(g--,0===g&&(u=!0,B=e,f[0]=!1)),!1===h&&!0===f[1]&&(d--,0===d&&(h=!0,f[1]=!1)),!1===m&&!0===f[2]&&(p--,0===p&&(m=!0,f[2]=!1))}}for(let e=0;e<this.certs.length-1;e++)if(e<this.certs.length-2&&void 0!==C[e+1])for(let t=0;t<C[e+1].mappings.length;t++){if(C[e+1].mappings[t].issuerDomainPolicy===ot||C[e+1].mappings[t].subjectDomainPolicy===ot)return{result:!1,resultCode:99,resultMessage:'The "anyPolicy" should not be a part of policy mapping scheme'};let r=-1,s=-1;for(let a=0;a<b.length;a++)b[a]===C[e+1].mappings[t].issuerDomainPolicy&&(r=a),b[a]===C[e+1].mappings[t].subjectDomainPolicy&&(s=a);void 0!==A[r][e]&&delete A[r][e];for(let a=0;a<V[e].certificatePolicies.length;a++)if(C[e+1].mappings[t].subjectDomainPolicy===V[e].certificatePolicies[a].policyIdentifier&&-1!==r&&-1!==s)for(let t=0;t<=e;t++)void 0!==A[s][t]&&(A[r][t]=!0,delete A[s][t])}for(let e=0;e<b.length;e++)if(b[e]===ot)for(let t=0;t<B;t++)delete A[e][t];const I=[];for(let e=0;e<A.length;e++){let t=!0;for(let r=0;r<this.certs.length-1;r++){let s=!1;if(r<B&&b[e]===ot&&b.length>1){t=!1;break}if(void 0===A[e][r]){if(r>=B)for(let e=0;e<b.length;e++)if(b[e]===ot){!0===A[e][r]&&(s=!0);break}if(!s){t=!1;break}}}!0===t&&I.push(b[e])}let N=[];if(1===s.length&&s[0]===ot&&!1===u)N=s;else if(1===I.length&&I[0]===ot)N=s;else for(let e=0;e<I.length;e++)for(let t=0;t<s.length;t++)if(s[t]===I[e]||s[t]===ot){N.push(I[e]);break}const P={result:N.length>0,resultCode:0,resultMessage:N.length>0?Ce:'Zero "userConstrPolicies" array, no intersections with "authConstrPolicies"',authConstrPolicies:I,userConstrPolicies:N,explicitPolicyIndicator:u,policyMappings:C,certificatePath:this.certs};if(0===N.length)return P;if(!1===P.result)return P;v=1;for(let e=this.certs.length-2;e>=0;e--,v++){const t=this.certs[e];let r=[],s=[],a=[];if(t.extensions)for(let e=0;e<t.extensions.length;e++){const i=t.extensions[e];i.extnID===st&&("permittedSubtrees"in i.parsedValue&&(s=s.concat(i.parsedValue.permittedSubtrees)),"excludedSubtrees"in i.parsedValue&&(a=a.concat(i.parsedValue.excludedSubtrees))),i.extnID===Ye&&(r=r.concat(i.parsedValue.altNames))}let i=w.length<=0;for(let e=0;e<w.length;e++)switch(w[e].base.type){case 4:if(w[e].base.value.typesAndValues.length!==t.subject.typesAndValues.length)continue;i=!0;for(let r=0;r<t.subject.typesAndValues.length;r++)if(t.subject.typesAndValues[r].type!==w[e].base.value.typesAndValues[r].type){i=!1;break}if(!0===i)break}if(!1===i)throw P.result=!1,P.resultCode=21,P.resultMessage="No necessary name form found",P;const n=[[],[],[],[],[]];for(let e=0;e<S.length;e++)switch(S[e].base.type){case 1:n[0].push(S[e]);break;case 2:n[1].push(S[e]);break;case 4:n[2].push(S[e]);break;case 6:n[3].push(S[e]);break;case 7:n[4].push(S[e])}for(let e=0;e<5;e++){let s=!1,a=!1;const i=n[e];for(let n=0;n<i.length;n++){switch(e){case 0:if(r.length>0)for(let e=0;e<r.length;e++)1===r[e].type&&(a=!0,s=s||compareRFC822Name(r[e].value,i[n].base.value));else for(let e=0;e<t.subject.typesAndValues.length;e++)"1.2.840.113549.1.9.1"!==t.subject.typesAndValues[e].type&&"0.9.2342.19200300.100.1.3"!==t.subject.typesAndValues[e].type||(a=!0,s=s||compareRFC822Name(t.subject.typesAndValues[e].value.valueBlock.value,i[n].base.value));break;case 1:if(r.length>0)for(let e=0;e<r.length;e++)2===r[e].type&&(a=!0,s=s||compareDNSName(r[e].value,i[n].base.value));break;case 2:a=!0,s=compareDirectoryName(t.subject,i[n].base.value);break;case 3:if(r.length>0)for(let e=0;e<r.length;e++)6===r[e].type&&(a=!0,s=s||compareUniformResourceIdentifier(r[e].value,i[n].base.value));break;case 4:if(r.length>0)for(let e=0;e<r.length;e++)7===r[e].type&&(a=!0,s=s||compareIPAddress(r[e].value,i[n].base.value))}if(s)break}if(!1===s&&i.length>0&&a)throw P.result=!1,P.resultCode=41,P.resultMessage='Failed to meet "permitted sub-trees" name constraint',P}let o=!1;for(let e=0;e<y.length;e++){switch(y[e].base.type){case 1:if(r.length>=0)for(let t=0;t<r.length;t++)1===r[t].type&&(o=o||compareRFC822Name(r[t].value,y[e].base.value));else for(let r=0;r<t.subject.typesAndValues.length;r++)"1.2.840.113549.1.9.1"!==t.subject.typesAndValues[r].type&&"0.9.2342.19200300.100.1.3"!==t.subject.typesAndValues[r].type||(o=o||compareRFC822Name(t.subject.typesAndValues[r].value.valueBlock.value,y[e].base.value));break;case 2:if(r.length>0)for(let t=0;t<r.length;t++)2===r[t].type&&(o=o||compareDNSName(r[t].value,y[e].base.value));break;case 4:o=o||compareDirectoryName(t.subject,y[e].base.value);break;case 6:if(r.length>0)for(let t=0;t<r.length;t++)6===r[t].type&&(o=o||compareUniformResourceIdentifier(r[t].value,y[e].base.value));break;case 7:if(r.length>0)for(let t=0;t<r.length;t++)7===r[t].type&&(o=o||compareIPAddress(r[t].value,y[e].base.value))}if(o)break}if(!0===o)throw P.result=!1,P.resultCode=42,P.resultMessage='Failed to meet "excluded sub-trees" name constraint',P;S=S.concat(s),y=y.concat(a)}return P}catch(e){return e instanceof Error?e instanceof ChainValidationError?{result:!1,resultCode:e.code,resultMessage:e.message,error:e}:{result:!1,resultCode:Jl.unknown,resultMessage:e.message,error:e}:e&&"object"==typeof e&&"resultMessage"in e?e:{result:!1,resultCode:-1,resultMessage:`${e}`}}}}const _l="tbsResponseData",Fl="signatureAlgorithm",$l="signature",Wl="certs",Gl="BasicOCSPResponse",zl=`${Gl}.${_l}`,Ql=`${Gl}.${Fl}`,Zl=`${Gl}.${$l}`,Yl=`${Gl}.${Wl}`,Xl=[zl,Ql,Zl,Yl];class BasicOCSPResponse extends PkiObject{constructor(e={}){super(),this.tbsResponseData=getParametersValue(e,_l,BasicOCSPResponse.defaultValues(_l)),this.signatureAlgorithm=getParametersValue(e,Fl,BasicOCSPResponse.defaultValues(Fl)),this.signature=getParametersValue(e,$l,BasicOCSPResponse.defaultValues($l)),Wl in e&&(this.certs=getParametersValue(e,Wl,BasicOCSPResponse.defaultValues(Wl))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case _l:return new ResponseData;case Fl:return new AlgorithmIdentifier;case $l:return new BitString;case Wl:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case"type":{let e=ResponseData.compareWithDefault("tbs",t.tbs)&&ResponseData.compareWithDefault("responderID",t.responderID)&&ResponseData.compareWithDefault("producedAt",t.producedAt)&&ResponseData.compareWithDefault("responses",t.responses);return"responseExtensions"in t&&(e=e&&ResponseData.compareWithDefault("responseExtensions",t.responseExtensions)),e}case Fl:return t.algorithmId===Ce&&"algorithmParams"in t==!1;case $l:return t.isEqual(BasicOCSPResponse.defaultValues(e));case Wl:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Gl,value:[ResponseData.schema(t.tbsResponseData||{names:{blockName:zl}}),AlgorithmIdentifier.schema(t.signatureAlgorithm||{names:{blockName:Ql}}),new BitString({name:t.signature||Zl}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Sequence({value:[new Repeated({name:Yl,value:Certificate.schema(t.certs||{})})]})]})]})}fromSchema(e){clearProps(e,Xl);const t=compareSchema(e,e,BasicOCSPResponse.schema());AsnError.assertSchema(t,this.className),this.tbsResponseData=new ResponseData({schema:t.result[zl]}),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result[Ql]}),this.signature=t.result[Zl],Yl in t.result&&(this.certs=Array.from(t.result[Yl],e=>new Certificate({schema:e})))}toSchema(){const e=[];return e.push(this.tbsResponseData.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Sequence({value:Array.from(this.certs,e=>e.toSchema())})]})),new Sequence({value:e})}toJSON(){const e={tbsResponseData:this.tbsResponseData.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,e=>e.toJSON())),e}async getCertificateStatus(e,t,r=getCrypto(!0)){const s={isForCertificate:!1,status:2},a={},i=[];for(const s of this.tbsResponseData.responses){const n=r.getAlgorithmByOID(s.certID.hashAlgorithm.algorithmId,!0,"CertID.hashAlgorithm");if(!a[n.name]){a[n.name]=1;const s=new CertID;i.push(s),await s.createForCertificate(e,{hashAlgorithm:n.name,issuerCertificate:t},r)}}for(const e of this.tbsResponseData.responses)for(const t of i)if(e.certID.isEqual(t)){s.isForCertificate=!0;try{switch(e.certStatus.idBlock.isConstructed){case!0:1===e.certStatus.idBlock.tagNumber&&(s.status=1);break;case!1:switch(e.certStatus.idBlock.tagNumber){case 0:s.status=0;break;case 2:s.status=2}}}catch(e){}return s}return s}async sign(e,t="SHA-1",r=getCrypto(!0)){if(!e)throw new Error("Need to provide a private key for signing");const s=await r.getSignatureParameters(e,t),a=s.parameters.algorithm;if(!("name"in a))throw new Error("Empty algorithm");this.signatureAlgorithm=s.signatureAlgorithm,this.tbsResponseData.tbsView=new Uint8Array(this.tbsResponseData.toSchema(!0).toBER());const i=await r.signWithPrivateKey(this.tbsResponseData.tbsView,e,{algorithm:a});this.signature=new BitString({valueHex:i})}async verify(e={},t=getCrypto(!0)){let r=null,s=-1;const a=e.trustedCerts||[];if(!this.certs)throw new Error("No certificates attached to the BasicOCSPResponse");switch(!0){case this.tbsResponseData.responderID instanceof RelativeDistinguishedNames:for(const[e,t]of this.certs.entries())if(t.subject.isEqual(this.tbsResponseData.responderID)){s=e;break}break;case this.tbsResponseData.responderID instanceof OctetString:for(const[e,r]of this.certs.entries()){if(isEqualBuffer(await t.digest({name:"sha-1"},r.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView),this.tbsResponseData.responderID.valueBlock.valueHex)){s=e;break}}break;default:throw new Error("Wrong value for responderID")}if(-1===s)throw new Error("Correct certificate was not found in OCSP response");r=this.certs[s];const i=[r];for(const e of this.certs){const t=await checkCA(e,r);t&&i.push(t)}const n=new CertificateChainValidationEngine({certs:i,trustedCerts:a});if(!(await n.verify({},t)).result)throw new Error("Validation of signer's certificate failed");return t.verifyWithPublicKey(this.tbsResponseData.tbsView,this.signature,this.certs[s].subjectPublicKeyInfo,this.signatureAlgorithm)}}BasicOCSPResponse.CLASS_NAME="BasicOCSPResponse";const ec="tbs",tc="version",rc="subject",sc="subjectPublicKeyInfo",ac="attributes",ic="signatureAlgorithm",nc="signatureValue",oc="CertificationRequestInfo",lc=`${oc}.version`,cc=`${oc}.subject`,uc=`${oc}.subjectPublicKeyInfo`,hc=`${oc}.attributes`,mc=[oc,lc,cc,uc,hc,ic,nc];function CertificationRequestInfo(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.CertificationRequestInfo||oc,value:[new Integer({name:t.CertificationRequestInfoVersion||lc}),RelativeDistinguishedNames.schema(t.subject||{names:{blockName:cc}}),PublicKeyInfo.schema({names:{blockName:uc}}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({optional:!0,name:t.CertificationRequestInfoAttributes||hc,value:Attribute.schema(t.attributes||{})})]})]})}class CertificationRequest extends PkiObject{get tbs(){return BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(getParametersValue(e,ec,CertificationRequest.defaultValues(ec))),this.version=getParametersValue(e,tc,CertificationRequest.defaultValues(tc)),this.subject=getParametersValue(e,rc,CertificationRequest.defaultValues(rc)),this.subjectPublicKeyInfo=getParametersValue(e,sc,CertificationRequest.defaultValues(sc)),ac in e&&(this.attributes=getParametersValue(e,ac,CertificationRequest.defaultValues(ac))),this.signatureAlgorithm=getParametersValue(e,ic,CertificationRequest.defaultValues(ic)),this.signatureValue=getParametersValue(e,nc,CertificationRequest.defaultValues(nc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ec:return ke;case tc:return 0;case rc:return new RelativeDistinguishedNames;case sc:return new PublicKeyInfo;case ac:return[];case ic:return new AlgorithmIdentifier;case nc:return new BitString;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({value:[CertificationRequestInfo(t.certificationRequestInfo||{}),new Sequence({name:t.signatureAlgorithm||ic,value:[new ObjectIdentifier,new Any({optional:!0})]}),new BitString({name:t.signatureValue||nc})]})}fromSchema(e){clearProps(e,mc);const t=compareSchema(e,e,CertificationRequest.schema());AsnError.assertSchema(t,this.className),this.tbsView=t.result.CertificationRequestInfo.valueBeforeDecodeView,this.version=t.result[lc].valueBlock.valueDec,this.subject=new RelativeDistinguishedNames({schema:t.result[cc]}),this.subjectPublicKeyInfo=new PublicKeyInfo({schema:t.result[uc]}),hc in t.result&&(this.attributes=Array.from(t.result[hc],e=>new Attribute({schema:e}))),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[new Integer({value:this.version}),this.subject.toSchema(),this.subjectPublicKeyInfo.toSchema()];return ac in this&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes||[],e=>e.toSchema())})),new Sequence({value:e})}toSchema(e=!1){let t;if(!1===e){if(0===this.tbsView.byteLength)return CertificationRequest.schema();const e=fromBER(this.tbsView);AsnError.assert(e,"PKCS#10 Certificate Request"),t=e.result}else t=this.encodeTBS();return new Sequence({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:Convert.ToHex(this.tbsView),version:this.version,subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return ac in this&&(e.attributes=Array.from(this.attributes||[],e=>e.toJSON())),e}async sign(e,t="SHA-1",r=getCrypto(!0)){if(!e)throw new Error("Need to provide a private key for signing");const s=await r.getSignatureParameters(e,t),a=s.parameters;this.signatureAlgorithm=s.signatureAlgorithm,this.tbsView=new Uint8Array(this.encodeTBS().toBER());const i=await r.signWithPrivateKey(this.tbsView,e,a);this.signatureValue=new BitString({valueHex:i})}async verify(e=getCrypto(!0)){return e.verifyWithPublicKey(this.tbsView,this.signatureValue,this.subjectPublicKeyInfo,this.signatureAlgorithm)}async getPublicKey(e,t=getCrypto(!0)){return t.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}}CertificationRequest.CLASS_NAME="CertificationRequest";const fc="digestAlgorithm",gc="digest",dc=[fc,gc];class DigestInfo extends PkiObject{constructor(e={}){super(),this.digestAlgorithm=getParametersValue(e,fc,DigestInfo.defaultValues(fc)),this.digest=getParametersValue(e,gc,DigestInfo.defaultValues(gc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case fc:return new AlgorithmIdentifier;case gc:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case fc:return AlgorithmIdentifier.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case gc:return t.isEqual(DigestInfo.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[AlgorithmIdentifier.schema(t.digestAlgorithm||{names:{blockName:fc}}),new OctetString({name:t.digest||gc})]})}fromSchema(e){clearProps(e,dc);const t=compareSchema(e,e,DigestInfo.schema({names:{digestAlgorithm:{names:{blockName:fc}},digest:gc}}));AsnError.assertSchema(t,this.className),this.digestAlgorithm=new AlgorithmIdentifier({schema:t.result.digestAlgorithm}),this.digest=t.result.digest}toSchema(){return new Sequence({value:[this.digestAlgorithm.toSchema(),this.digest]})}toJSON(){return{digestAlgorithm:this.digestAlgorithm.toJSON(),digest:this.digest.toJSON()}}}DigestInfo.CLASS_NAME="DigestInfo";const pc="eContentType",Sc="eContent",yc=[pc,Sc];class EncapsulatedContentInfo extends PkiObject{constructor(e={}){if(super(),this.eContentType=getParametersValue(e,pc,EncapsulatedContentInfo.defaultValues(pc)),Sc in e&&(this.eContent=getParametersValue(e,Sc,EncapsulatedContentInfo.defaultValues(Sc)),1===this.eContent.idBlock.tagClass&&4===this.eContent.idBlock.tagNumber&&!1===this.eContent.idBlock.isConstructed)){const e=new OctetString({idBlock:{isConstructed:!0},isConstructed:!0});let t=0;const r=this.eContent.valueBlock.valueHexView.slice().buffer;let s=r.byteLength;for(;s>0;){const a=new Uint8Array(r,t,t+65536>r.byteLength?r.byteLength-t:65536),i=new ArrayBuffer(a.length),n=new Uint8Array(i);for(let e=0;e<n.length;e++)n[e]=a[e];e.valueBlock.value.push(new OctetString({valueHex:i})),s-=a.length,t+=a.length}this.eContent=e}e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case pc:return Ce;case Sc:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case pc:return t===Ce;case Sc:return 1===t.idBlock.tagClass&&4===t.idBlock.tagNumber&&t.isEqual(EncapsulatedContentInfo.defaultValues(Sc));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.eContentType||Ce}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Any({name:t.eContent||Ce})]})]})}fromSchema(e){clearProps(e,yc);const t=compareSchema(e,e,EncapsulatedContentInfo.schema({names:{eContentType:pc,eContent:Sc}}));AsnError.assertSchema(t,this.className),this.eContentType=t.result.eContentType.valueBlock.toString(),Sc in t.result&&(this.eContent=t.result.eContent)}toSchema(){const e=[];return e.push(new ObjectIdentifier({value:this.eContentType})),this.eContent&&!1===EncapsulatedContentInfo.compareWithDefault(Sc,this.eContent)&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.eContent]})),new Sequence({value:e})}toJSON(){const e={eContentType:this.eContentType};return this.eContent&&!1===EncapsulatedContentInfo.compareWithDefault(Sc,this.eContent)&&(e.eContent=this.eContent.toJSON()),e}}EncapsulatedContentInfo.CLASS_NAME="EncapsulatedContentInfo";const wc="mac",vc="macSalt",bc="iterations",Ac=[wc,vc,bc];class MacData extends PkiObject{constructor(e={}){super(),this.mac=getParametersValue(e,wc,MacData.defaultValues(wc)),this.macSalt=getParametersValue(e,vc,MacData.defaultValues(vc)),bc in e&&(this.iterations=getParametersValue(e,bc,MacData.defaultValues(bc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case wc:return new DigestInfo;case vc:return new OctetString;case bc:return 1;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case wc:return DigestInfo.compareWithDefault("digestAlgorithm",t.digestAlgorithm)&&DigestInfo.compareWithDefault("digest",t.digest);case vc:return t.isEqual(MacData.defaultValues(e));case bc:return t===MacData.defaultValues(e);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,optional:t.optional||!0,value:[DigestInfo.schema(t.mac||{names:{blockName:wc}}),new OctetString({name:t.macSalt||vc}),new Integer({optional:!0,name:t.iterations||bc})]})}fromSchema(e){clearProps(e,Ac);const t=compareSchema(e,e,MacData.schema({names:{mac:{names:{blockName:wc}},macSalt:vc,iterations:bc}}));AsnError.assertSchema(t,this.className),this.mac=new DigestInfo({schema:t.result.mac}),this.macSalt=t.result.macSalt,bc in t.result&&(this.iterations=t.result.iterations.valueBlock.valueDec)}toSchema(){const e=[this.mac.toSchema(),this.macSalt];return void 0!==this.iterations&&e.push(new Integer({value:this.iterations})),new Sequence({value:e})}toJSON(){const e={mac:this.mac.toJSON(),macSalt:this.macSalt.toJSON()};return void 0!==this.iterations&&(e.iterations=this.iterations),e}}MacData.CLASS_NAME="MacData";const kc="hashAlgorithm",Cc="hashedMessage",Vc=[kc,Cc];class MessageImprint extends PkiObject{static async create(e,t,r=getCrypto(!0)){const s=r.getOIDByAlgorithm({name:e},!0,"hashAlgorithm"),a=await r.digest(e,t);return new MessageImprint({hashAlgorithm:new AlgorithmIdentifier({algorithmId:s,algorithmParams:new Null}),hashedMessage:new OctetString({valueHex:a})})}constructor(e={}){super(),this.hashAlgorithm=getParametersValue(e,kc,MessageImprint.defaultValues(kc)),this.hashedMessage=getParametersValue(e,Cc,MessageImprint.defaultValues(Cc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case kc:return new AlgorithmIdentifier;case Cc:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case kc:return t.algorithmId===Ce&&"algorithmParams"in t==!1;case Cc:return 0===t.isEqual(MessageImprint.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[AlgorithmIdentifier.schema(t.hashAlgorithm||{}),new OctetString({name:t.hashedMessage||Ce})]})}fromSchema(e){clearProps(e,Vc);const t=compareSchema(e,e,MessageImprint.schema({names:{hashAlgorithm:{names:{blockName:kc}},hashedMessage:Cc}}));AsnError.assertSchema(t,this.className),this.hashAlgorithm=new AlgorithmIdentifier({schema:t.result.hashAlgorithm}),this.hashedMessage=t.result.hashedMessage}toSchema(){return new Sequence({value:[this.hashAlgorithm.toSchema(),this.hashedMessage]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),hashedMessage:this.hashedMessage.toJSON()}}}MessageImprint.CLASS_NAME="MessageImprint";const Bc="reqCert",Ic="singleRequestExtensions",Nc=[Bc,Ic];class Request extends PkiObject{constructor(e={}){super(),this.reqCert=getParametersValue(e,Bc,Request.defaultValues(Bc)),Ic in e&&(this.singleRequestExtensions=getParametersValue(e,Ic,Request.defaultValues(Ic))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Bc:return new CertID;case Ic:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Bc:return t.isEqual(Request.defaultValues(e));case Ic:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[CertID.schema(t.reqCert||{}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Extension.schema(t.extensions||{names:{blockName:t.singleRequestExtensions||Ce}})]})]})}fromSchema(e){clearProps(e,Nc);const t=compareSchema(e,e,Request.schema({names:{reqCert:{names:{blockName:Bc}},extensions:{names:{blockName:Ic}}}}));AsnError.assertSchema(t,this.className),this.reqCert=new CertID({schema:t.result.reqCert}),Ic in t.result&&(this.singleRequestExtensions=Array.from(t.result.singleRequestExtensions.valueBlock.value,e=>new Extension({schema:e})))}toSchema(){const e=[];return e.push(this.reqCert.toSchema()),this.singleRequestExtensions&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Sequence({value:Array.from(this.singleRequestExtensions,e=>e.toSchema())})]})),new Sequence({value:e})}toJSON(){const e={reqCert:this.reqCert.toJSON()};return this.singleRequestExtensions&&(e.singleRequestExtensions=Array.from(this.singleRequestExtensions,e=>e.toJSON())),e}}Request.CLASS_NAME="Request";const Pc="tbs",Ec="version",Dc="requestorName",Oc="requestList",xc="requestExtensions",Rc="TBSRequest",Kc=`${Rc}.${Ec}`,Uc=`${Rc}.${Dc}`,Tc=`${Rc}.requests`,Lc=`${Rc}.${xc}`,Hc=[Rc,Kc,Uc,Tc,Lc];class TBSRequest extends PkiObject{get tbs(){return BufferSourceConverter.toArrayBuffer(this.tbsView)}set tbs(e){this.tbsView=new Uint8Array(e)}constructor(e={}){super(),this.tbsView=new Uint8Array(getParametersValue(e,Pc,TBSRequest.defaultValues(Pc))),Ec in e&&(this.version=getParametersValue(e,Ec,TBSRequest.defaultValues(Ec))),Dc in e&&(this.requestorName=getParametersValue(e,Dc,TBSRequest.defaultValues(Dc))),this.requestList=getParametersValue(e,Oc,TBSRequest.defaultValues(Oc)),xc in e&&(this.requestExtensions=getParametersValue(e,xc,TBSRequest.defaultValues(xc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Pc:return ke;case Ec:return 0;case Dc:return new GeneralName;case Oc:case xc:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Pc:return 0===t.byteLength;case Ec:return t===TBSRequest.defaultValues(e);case Dc:return t.type===GeneralName.defaultValues("type")&&0===Object.keys(t.value).length;case Oc:case xc:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Rc,value:[new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Integer({name:t.TBSRequestVersion||Kc})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[GeneralName.schema(t.requestorName||{names:{blockName:Uc}})]}),new Sequence({name:t.requestList||"TBSRequest.requestList",value:[new Repeated({name:t.requests||Tc,value:Request.schema(t.requestNames||{})})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[Extensions.schema(t.extensions||{names:{blockName:t.requestExtensions||Lc}})]})]})}fromSchema(e){clearProps(e,Hc);const t=compareSchema(e,e,TBSRequest.schema());AsnError.assertSchema(t,this.className),this.tbsView=t.result.TBSRequest.valueBeforeDecodeView,Kc in t.result&&(this.version=t.result[Kc].valueBlock.valueDec),Uc in t.result&&(this.requestorName=new GeneralName({schema:t.result[Uc]})),this.requestList=Array.from(t.result[Tc],e=>new Request({schema:e})),Lc in t.result&&(this.requestExtensions=Array.from(t.result[Lc].valueBlock.value,e=>new Extension({schema:e})))}toSchema(e=!1){let t;if(!1===e){if(0===this.tbsView.byteLength)return TBSRequest.schema();const e=fromBER(this.tbsView);if(AsnError.assert(e,"TBS Request"),!(e.result instanceof Sequence))throw new Error("ASN.1 result should be SEQUENCE");t=e.result}else{const e=[];void 0!==this.version&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[new Integer({value:this.version})]})),this.requestorName&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:[this.requestorName.toSchema()]})),e.push(new Sequence({value:Array.from(this.requestList,e=>e.toSchema())})),this.requestExtensions&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:2},value:[new Sequence({value:Array.from(this.requestExtensions,e=>e.toSchema())})]})),t=new Sequence({value:e})}return t}toJSON(){const e={};return null!=this.version&&(e.version=this.version),this.requestorName&&(e.requestorName=this.requestorName.toJSON()),e.requestList=Array.from(this.requestList,e=>e.toJSON()),this.requestExtensions&&(e.requestExtensions=Array.from(this.requestExtensions,e=>e.toJSON())),e}}TBSRequest.CLASS_NAME="TBSRequest";const qc="signatureAlgorithm",jc="signature",Mc="certs";class Signature extends PkiObject{constructor(e={}){super(),this.signatureAlgorithm=getParametersValue(e,qc,Signature.defaultValues(qc)),this.signature=getParametersValue(e,jc,Signature.defaultValues(jc)),Mc in e&&(this.certs=getParametersValue(e,Mc,Signature.defaultValues(Mc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case qc:return new AlgorithmIdentifier;case jc:return new BitString;case Mc:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case qc:return t.algorithmId===Ce&&"algorithmParams"in t==!1;case jc:return t.isEqual(Signature.defaultValues(e));case Mc:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[AlgorithmIdentifier.schema(t.signatureAlgorithm||{}),new BitString({name:t.signature||Ce}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Sequence({value:[new Repeated({name:t.certs||Ce,value:Certificate.schema({})})]})]})]})}fromSchema(e){clearProps(e,[qc,jc,Mc]);const t=compareSchema(e,e,Signature.schema({names:{signatureAlgorithm:{names:{blockName:qc}},signature:jc,certs:Mc}}));AsnError.assertSchema(t,this.className),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result.signatureAlgorithm}),this.signature=t.result.signature,Mc in t.result&&(this.certs=Array.from(t.result.certs,e=>new Certificate({schema:e})))}toSchema(){const e=[];return e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.certs&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Sequence({value:Array.from(this.certs,e=>e.toSchema())})]})),new Sequence({value:e})}toJSON(){const e={signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.certs&&(e.certs=Array.from(this.certs,e=>e.toJSON())),e}}Signature.CLASS_NAME="Signature";const Jc="tbsRequest",_c="optionalSignature",Fc=[Jc,_c];class OCSPRequest extends PkiObject{constructor(e={}){super(),this.tbsRequest=getParametersValue(e,Jc,OCSPRequest.defaultValues(Jc)),_c in e&&(this.optionalSignature=getParametersValue(e,_c,OCSPRequest.defaultValues(_c))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Jc:return new TBSRequest;case _c:return new Signature;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Jc:return TBSRequest.compareWithDefault("tbs",t.tbs)&&TBSRequest.compareWithDefault("version",t.version)&&TBSRequest.compareWithDefault("requestorName",t.requestorName)&&TBSRequest.compareWithDefault("requestList",t.requestList)&&TBSRequest.compareWithDefault("requestExtensions",t.requestExtensions);case _c:return Signature.compareWithDefault("signatureAlgorithm",t.signatureAlgorithm)&&Signature.compareWithDefault("signature",t.signature)&&Signature.compareWithDefault("certs",t.certs);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||"OCSPRequest",value:[TBSRequest.schema(t.tbsRequest||{names:{blockName:Jc}}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Signature.schema(t.optionalSignature||{names:{blockName:_c}})]})]})}fromSchema(e){clearProps(e,Fc);const t=compareSchema(e,e,OCSPRequest.schema());AsnError.assertSchema(t,this.className),this.tbsRequest=new TBSRequest({schema:t.result.tbsRequest}),_c in t.result&&(this.optionalSignature=new Signature({schema:t.result.optionalSignature}))}toSchema(e=!1){const t=[];return t.push(this.tbsRequest.toSchema(e)),this.optionalSignature&&t.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.optionalSignature.toSchema()]})),new Sequence({value:t})}toJSON(){const e={tbsRequest:this.tbsRequest.toJSON()};return this.optionalSignature&&(e.optionalSignature=this.optionalSignature.toJSON()),e}async createForCertificate(e,t,r=getCrypto(!0)){const s=new CertID;await s.createForCertificate(e,t,r),this.tbsRequest.requestList.push(new Request({reqCert:s}))}async sign(e,t="SHA-1",r=getCrypto(!0)){if(ParameterError.assertEmpty(e,"privateKey","OCSPRequest.sign method"),!this.optionalSignature)throw new Error('Need to create "optionalSignature" field before signing');const s=await r.getSignatureParameters(e,t),a=s.parameters;this.optionalSignature.signatureAlgorithm=s.signatureAlgorithm;const i=this.tbsRequest.toSchema(!0).toBER(!1),n=await r.signWithPrivateKey(i,e,a);this.optionalSignature.signature=new BitString({valueHex:n})}verify(){}}OCSPRequest.CLASS_NAME="OCSPRequest";const $c="responseType",Wc="response",Gc=[$c,Wc];class ResponseBytes extends PkiObject{constructor(e={}){super(),this.responseType=getParametersValue(e,$c,ResponseBytes.defaultValues($c)),this.response=getParametersValue(e,Wc,ResponseBytes.defaultValues(Wc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case $c:return Ce;case Wc:return new OctetString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case $c:return t===Ce;case Wc:return t.isEqual(ResponseBytes.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new ObjectIdentifier({name:t.responseType||Ce}),new OctetString({name:t.response||Ce})]})}fromSchema(e){clearProps(e,Gc);const t=compareSchema(e,e,ResponseBytes.schema({names:{responseType:$c,response:Wc}}));AsnError.assertSchema(t,this.className),this.responseType=t.result.responseType.valueBlock.toString(),this.response=t.result.response}toSchema(){return new Sequence({value:[new ObjectIdentifier({value:this.responseType}),this.response]})}toJSON(){return{responseType:this.responseType,response:this.response.toJSON()}}}ResponseBytes.CLASS_NAME="ResponseBytes";const zc="responseStatus",Qc="responseBytes";class OCSPResponse extends PkiObject{constructor(e={}){super(),this.responseStatus=getParametersValue(e,zc,OCSPResponse.defaultValues(zc)),Qc in e&&(this.responseBytes=getParametersValue(e,Qc,OCSPResponse.defaultValues(Qc))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case zc:return new Enumerated;case Qc:return new ResponseBytes;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case zc:return t.isEqual(OCSPResponse.defaultValues(e));case Qc:return ResponseBytes.compareWithDefault("responseType",t.responseType)&&ResponseBytes.compareWithDefault("response",t.response);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||"OCSPResponse",value:[new Enumerated({name:t.responseStatus||zc}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[ResponseBytes.schema(t.responseBytes||{names:{blockName:Qc}})]})]})}fromSchema(e){clearProps(e,[zc,Qc]);const t=compareSchema(e,e,OCSPResponse.schema());AsnError.assertSchema(t,this.className),this.responseStatus=t.result.responseStatus,Qc in t.result&&(this.responseBytes=new ResponseBytes({schema:t.result.responseBytes}))}toSchema(){const e=[];return e.push(this.responseStatus),this.responseBytes&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:[this.responseBytes.toSchema()]})),new Sequence({value:e})}toJSON(){const e={responseStatus:this.responseStatus.toJSON()};return this.responseBytes&&(e.responseBytes=this.responseBytes.toJSON()),e}async getCertificateStatus(e,t,r=getCrypto(!0)){let s;const a={isForCertificate:!1,status:2};if(!this.responseBytes)return a;if(this.responseBytes.responseType!==wt)return a;try{const e=fromBER(this.responseBytes.response.valueBlock.valueHexView);AsnError.assert(e,"Basic OCSP response"),s=new BasicOCSPResponse({schema:e.result})}catch(e){return a}return s.getCertificateStatus(e,t,r)}async sign(e,t,r=getCrypto(!0)){var s;if(this.responseBytes&&this.responseBytes.responseType===wt){return BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView).sign(e,t,r)}throw new Error(`Unknown ResponseBytes type: ${(null===(s=this.responseBytes)||void 0===s?void 0:s.responseType)||"Unknown"}`)}async verify(e=null,t=getCrypto(!0)){var r;if(Qc in this==!1)throw new Error("Empty ResponseBytes field");if(this.responseBytes&&this.responseBytes.responseType===wt){const r=BasicOCSPResponse.fromBER(this.responseBytes.response.valueBlock.valueHexView);return null!==e&&(r.certs||(r.certs=[]),r.certs.push(e)),r.verify({},t)}throw new Error(`Unknown ResponseBytes type: ${(null===(r=this.responseBytes)||void 0===r?void 0:r.responseType)||"Unknown"}`)}}OCSPResponse.CLASS_NAME="OCSPResponse";const Zc="type",Yc="attributes",Xc="encodedValue",eu=[Yc];class SignedAndUnsignedAttributes extends PkiObject{constructor(e={}){super(),this.type=getParametersValue(e,Zc,SignedAndUnsignedAttributes.defaultValues(Zc)),this.attributes=getParametersValue(e,Yc,SignedAndUnsignedAttributes.defaultValues(Yc)),this.encodedValue=getParametersValue(e,Xc,SignedAndUnsignedAttributes.defaultValues(Xc)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Zc:return-1;case Yc:return[];case Xc:return ke;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Zc:return t===SignedAndUnsignedAttributes.defaultValues(Zc);case Yc:return 0===t.length;case Xc:return 0===t.byteLength;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Constructed({name:t.blockName||Ce,optional:!0,idBlock:{tagClass:3,tagNumber:t.tagNumber||0},value:[new Repeated({name:t.attributes||Ce,value:Attribute.schema()})]})}fromSchema(e){clearProps(e,eu);const t=compareSchema(e,e,SignedAndUnsignedAttributes.schema({names:{tagNumber:this.type,attributes:Yc}}));AsnError.assertSchema(t,this.className),this.type=t.result.idBlock.tagNumber,this.encodedValue=BufferSourceConverter.toArrayBuffer(t.result.valueBeforeDecodeView);if(new Uint8Array(this.encodedValue)[0]=49,Yc in t.result!=!1)this.attributes=Array.from(t.result.attributes,e=>new Attribute({schema:e}));else if(0===this.type)throw new Error("Wrong structure of SignedUnsignedAttributes")}toSchema(){if(SignedAndUnsignedAttributes.compareWithDefault(Zc,this.type)||SignedAndUnsignedAttributes.compareWithDefault(Yc,this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:this.type},value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){if(SignedAndUnsignedAttributes.compareWithDefault(Zc,this.type)||SignedAndUnsignedAttributes.compareWithDefault(Yc,this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return{type:this.type,attributes:Array.from(this.attributes,e=>e.toJSON())}}}SignedAndUnsignedAttributes.CLASS_NAME="SignedAndUnsignedAttributes";const tu="version",ru="sid",su="digestAlgorithm",au="signedAttrs",iu="signatureAlgorithm",nu="signature",ou="unsignedAttrs",lu="SignerInfo",cu=`${lu}.${tu}`,uu=`${lu}.${ru}`,hu=`${lu}.${su}`,mu=`${lu}.${au}`,fu=`${lu}.${iu}`,gu=`${lu}.${nu}`,du=`${lu}.${ou}`,pu=[cu,uu,hu,mu,fu,gu,du];class SignerInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,tu,SignerInfo.defaultValues(tu)),this.sid=getParametersValue(e,ru,SignerInfo.defaultValues(ru)),this.digestAlgorithm=getParametersValue(e,su,SignerInfo.defaultValues(su)),au in e&&(this.signedAttrs=getParametersValue(e,au,SignerInfo.defaultValues(au))),this.signatureAlgorithm=getParametersValue(e,iu,SignerInfo.defaultValues(iu)),this.signature=getParametersValue(e,nu,SignerInfo.defaultValues(nu)),ou in e&&(this.unsignedAttrs=getParametersValue(e,ou,SignerInfo.defaultValues(ou))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case tu:return 0;case ru:return new Any;case su:return new AlgorithmIdentifier;case au:return new SignedAndUnsignedAttributes({type:0});case iu:return new AlgorithmIdentifier;case nu:return new OctetString;case ou:return new SignedAndUnsignedAttributes({type:1});default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case tu:return SignerInfo.defaultValues(tu)===t;case ru:return t instanceof Any;case su:return t instanceof AlgorithmIdentifier!=!1&&t.isEqual(SignerInfo.defaultValues(su));case au:return SignedAndUnsignedAttributes.compareWithDefault("type",t.type)&&SignedAndUnsignedAttributes.compareWithDefault("attributes",t.attributes)&&SignedAndUnsignedAttributes.compareWithDefault("encodedValue",t.encodedValue);case iu:return t instanceof AlgorithmIdentifier!=!1&&t.isEqual(SignerInfo.defaultValues(iu));case nu:case ou:return SignedAndUnsignedAttributes.compareWithDefault("type",t.type)&&SignedAndUnsignedAttributes.compareWithDefault("attributes",t.attributes)&&SignedAndUnsignedAttributes.compareWithDefault("encodedValue",t.encodedValue);default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:lu,value:[new Integer({name:t.version||cu}),new Choice({value:[IssuerAndSerialNumber.schema(t.sidSchema||{names:{blockName:uu}}),new Choice({value:[new Constructed({optional:!0,name:t.sid||uu,idBlock:{tagClass:3,tagNumber:0},value:[new OctetString]}),new Primitive({optional:!0,name:t.sid||uu,idBlock:{tagClass:3,tagNumber:0}})]})]}),AlgorithmIdentifier.schema(t.digestAlgorithm||{names:{blockName:hu}}),SignedAndUnsignedAttributes.schema(t.signedAttrs||{names:{blockName:mu,tagNumber:0}}),AlgorithmIdentifier.schema(t.signatureAlgorithm||{names:{blockName:fu}}),new OctetString({name:t.signature||gu}),SignedAndUnsignedAttributes.schema(t.unsignedAttrs||{names:{blockName:du,tagNumber:1}})]})}fromSchema(e){clearProps(e,pu);const t=compareSchema(e,e,SignerInfo.schema());AsnError.assertSchema(t,this.className),this.version=t.result[cu].valueBlock.valueDec;const r=t.result[uu];1===r.idBlock.tagClass?this.sid=new IssuerAndSerialNumber({schema:r}):this.sid=r,this.digestAlgorithm=new AlgorithmIdentifier({schema:t.result[hu]}),mu in t.result&&(this.signedAttrs=new SignedAndUnsignedAttributes({type:0,schema:t.result[mu]})),this.signatureAlgorithm=new AlgorithmIdentifier({schema:t.result[fu]}),this.signature=t.result[gu],du in t.result&&(this.unsignedAttrs=new SignedAndUnsignedAttributes({type:1,schema:t.result[du]}))}toSchema(){if(SignerInfo.compareWithDefault(ru,this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');const e=[];return e.push(new Integer({value:this.version})),this.sid instanceof IssuerAndSerialNumber?e.push(this.sid.toSchema()):e.push(this.sid),e.push(this.digestAlgorithm.toSchema()),this.signedAttrs&&!1===SignerInfo.compareWithDefault(au,this.signedAttrs)&&e.push(this.signedAttrs.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),this.unsignedAttrs&&!1===SignerInfo.compareWithDefault(ou,this.unsignedAttrs)&&e.push(this.unsignedAttrs.toSchema()),new Sequence({value:e})}toJSON(){if(SignerInfo.compareWithDefault(ru,this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');const e={version:this.version,digestAlgorithm:this.digestAlgorithm.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return this.sid instanceof Any||(e.sid=this.sid.toJSON()),this.signedAttrs&&!1===SignerInfo.compareWithDefault(au,this.signedAttrs)&&(e.signedAttrs=this.signedAttrs.toJSON()),this.unsignedAttrs&&!1===SignerInfo.compareWithDefault(ou,this.unsignedAttrs)&&(e.unsignedAttrs=this.unsignedAttrs.toJSON()),e}}SignerInfo.CLASS_NAME="SignerInfo";const Su="version",yu="policy",wu="messageImprint",vu="serialNumber",bu="genTime",Au="ordering",ku="nonce",Cu="accuracy",Vu="tsa",Bu="extensions",Iu="TSTInfo",Nu=`${Iu}.${Su}`,Pu=`${Iu}.${yu}`,Eu=`${Iu}.${wu}`,Du=`${Iu}.${vu}`,Ou=`${Iu}.${bu}`,xu=`${Iu}.${Cu}`,Ru=`${Iu}.${Au}`,Ku=`${Iu}.${ku}`,Uu=`${Iu}.${Vu}`,Tu=`${Iu}.${Bu}`,Lu=[Nu,Pu,Eu,Du,Ou,xu,Ru,Ku,Uu,Tu];class TSTInfo extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Su,TSTInfo.defaultValues(Su)),this.policy=getParametersValue(e,yu,TSTInfo.defaultValues(yu)),this.messageImprint=getParametersValue(e,wu,TSTInfo.defaultValues(wu)),this.serialNumber=getParametersValue(e,vu,TSTInfo.defaultValues(vu)),this.genTime=getParametersValue(e,bu,TSTInfo.defaultValues(bu)),Cu in e&&(this.accuracy=getParametersValue(e,Cu,TSTInfo.defaultValues(Cu))),Au in e&&(this.ordering=getParametersValue(e,Au,TSTInfo.defaultValues(Au))),ku in e&&(this.nonce=getParametersValue(e,ku,TSTInfo.defaultValues(ku))),Vu in e&&(this.tsa=getParametersValue(e,Vu,TSTInfo.defaultValues(Vu))),Bu in e&&(this.extensions=getParametersValue(e,Bu,TSTInfo.defaultValues(Bu))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Su:return 0;case yu:return Ce;case wu:return new MessageImprint;case vu:return new Integer;case bu:return new Date(0,0,0);case Cu:return new Accuracy;case Au:return!1;case ku:return new Integer;case Vu:return new GeneralName;case Bu:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Su:case yu:case bu:case Au:return t===TSTInfo.defaultValues(Au);case wu:return MessageImprint.compareWithDefault(kc,t.hashAlgorithm)&&MessageImprint.compareWithDefault(Cc,t.hashedMessage);case vu:case ku:return t.isEqual(TSTInfo.defaultValues(ku));case Cu:return Accuracy.compareWithDefault(Re,t.seconds)&&Accuracy.compareWithDefault(Ke,t.millis)&&Accuracy.compareWithDefault(Ue,t.micros);case Vu:return GeneralName.compareWithDefault(Pe,t.type)&&GeneralName.compareWithDefault(Ee,t.value);case Bu:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Iu,value:[new Integer({name:t.version||Nu}),new ObjectIdentifier({name:t.policy||Pu}),MessageImprint.schema(t.messageImprint||{names:{blockName:Eu}}),new Integer({name:t.serialNumber||Du}),new GeneralizedTime({name:t.genTime||Ou}),Accuracy.schema(t.accuracy||{names:{blockName:xu}}),new Boolean({name:t.ordering||Ru,optional:!0}),new Integer({name:t.nonce||Ku,optional:!0}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[GeneralName.schema(t.tsa||{names:{blockName:Uu}})]}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new Repeated({name:t.extensions||Tu,value:Extension.schema(t.extension||{})})]})]})}fromSchema(e){clearProps(e,Lu);const t=compareSchema(e,e,TSTInfo.schema());AsnError.assertSchema(t,this.className),this.version=t.result[Nu].valueBlock.valueDec,this.policy=t.result[Pu].valueBlock.toString(),this.messageImprint=new MessageImprint({schema:t.result[Eu]}),this.serialNumber=t.result[Du],this.genTime=t.result[Ou].toDate(),xu in t.result&&(this.accuracy=new Accuracy({schema:t.result[xu]})),Ru in t.result&&(this.ordering=t.result[Ru].valueBlock.value),Ku in t.result&&(this.nonce=t.result[Ku]),Uu in t.result&&(this.tsa=new GeneralName({schema:t.result[Uu]})),Tu in t.result&&(this.extensions=Array.from(t.result[Tu],e=>new Extension({schema:e})))}toSchema(){const e=[];return e.push(new Integer({value:this.version})),e.push(new ObjectIdentifier({value:this.policy})),e.push(this.messageImprint.toSchema()),e.push(this.serialNumber),e.push(new GeneralizedTime({valueDate:this.genTime})),this.accuracy&&e.push(this.accuracy.toSchema()),void 0!==this.ordering&&e.push(new Boolean({value:this.ordering})),this.nonce&&e.push(this.nonce),this.tsa&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.tsa.toSchema()]})),this.extensions&&e.push(new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.extensions,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={version:this.version,policy:this.policy,messageImprint:this.messageImprint.toJSON(),serialNumber:this.serialNumber.toJSON(),genTime:this.genTime};return this.accuracy&&(e.accuracy=this.accuracy.toJSON()),void 0!==this.ordering&&(e.ordering=this.ordering),this.nonce&&(e.nonce=this.nonce.toJSON()),this.tsa&&(e.tsa=this.tsa.toJSON()),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}async verify(e,t=getCrypto(!0)){if(!e.data)throw new Error('"data" is a mandatory attribute for TST_INFO verification');const r=e.data;if(e.notBefore&&this.genTime<e.notBefore)throw new Error("Generation time for TSTInfo object is less than notBefore value");if(e.notAfter&&this.genTime>e.notAfter)throw new Error("Generation time for TSTInfo object is more than notAfter value");const s=t.getAlgorithmByOID(this.messageImprint.hashAlgorithm.algorithmId,!0,"MessageImprint.hashAlgorithm"),a=await t.digest(s.name,new Uint8Array(r));return BufferSourceConverter.isEqual(a,this.messageImprint.hashedMessage.valueBlock.valueHexView)}}TSTInfo.CLASS_NAME="TSTInfo";const Hu="version",qu="digestAlgorithms",ju="encapContentInfo",Mu="certificates",Ju="crls",_u="signerInfos",Fu="ocsps",$u="SignedData",Wu=`${$u}.${Hu}`,Gu=`${$u}.${qu}`,zu=`${$u}.${ju}`,Qu=`${$u}.${Mu}`,Zu=`${$u}.${Ju}`,Yu=`${$u}.${_u}`,Xu=[Wu,Gu,zu,Qu,Zu,Yu];class SignedDataVerifyError extends Error{constructor({message:e,code:t=0,date:r=new Date,signatureVerified:s=null,signerCertificate:a=null,signerCertificateVerified:i=null,timestampSerial:n=null,certificatePath:o=[]}){super(e),this.name="SignedDataVerifyError",this.date=r,this.code=t,this.timestampSerial=n,this.signatureVerified=s,this.signerCertificate=a,this.signerCertificateVerified=i,this.certificatePath=o}}class SignedData extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,Hu,SignedData.defaultValues(Hu)),this.digestAlgorithms=getParametersValue(e,qu,SignedData.defaultValues(qu)),this.encapContentInfo=getParametersValue(e,ju,SignedData.defaultValues(ju)),Mu in e&&(this.certificates=getParametersValue(e,Mu,SignedData.defaultValues(Mu))),Ju in e&&(this.crls=getParametersValue(e,Ju,SignedData.defaultValues(Ju))),Fu in e&&(this.ocsps=getParametersValue(e,Fu,SignedData.defaultValues(Fu))),this.signerInfos=getParametersValue(e,_u,SignedData.defaultValues(_u)),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Hu:return 0;case qu:return[];case ju:return new EncapsulatedContentInfo;case Mu:case Ju:case Fu:case _u:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Hu:return t===SignedData.defaultValues(Hu);case ju:return EncapsulatedContentInfo.compareWithDefault("eContentType",t.eContentType)&&EncapsulatedContentInfo.compareWithDefault("eContent",t.eContent);case qu:case Mu:case Ju:case Fu:case _u:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return void 0===t.optional&&(t.optional=!1),new Sequence({name:t.blockName||$u,optional:t.optional,value:[new Integer({name:t.version||Wu}),new Set({value:[new Repeated({name:t.digestAlgorithms||Gu,value:AlgorithmIdentifier.schema()})]}),EncapsulatedContentInfo.schema(t.encapContentInfo||{names:{blockName:zu}}),new Constructed({name:t.certificates||Qu,optional:!0,idBlock:{tagClass:3,tagNumber:0},value:CertificateSet.schema().valueBlock.value}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:RevocationInfoChoices.schema(t.crls||{names:{crls:Zu}}).valueBlock.value}),new Set({value:[new Repeated({name:t.signerInfos||Yu,value:SignerInfo.schema()})]})]})}fromSchema(e){clearProps(e,Xu);const t=compareSchema(e,e,SignedData.schema());if(AsnError.assertSchema(t,this.className),this.version=t.result[Wu].valueBlock.valueDec,Gu in t.result&&(this.digestAlgorithms=Array.from(t.result[Gu],e=>new AlgorithmIdentifier({schema:e}))),this.encapContentInfo=new EncapsulatedContentInfo({schema:t.result[zu]}),Qu in t.result){const e=new CertificateSet({schema:new Set({value:t.result[Qu].valueBlock.value})});this.certificates=e.certificates.slice(0)}Zu in t.result&&(this.crls=Array.from(t.result[Zu],e=>1===e.idBlock.tagClass?new CertificateRevocationList({schema:e}):(e.idBlock.tagClass=1,e.idBlock.tagNumber=16,new OtherRevocationInfoFormat({schema:e})))),Yu in t.result&&(this.signerInfos=Array.from(t.result[Yu],e=>new SignerInfo({schema:e})))}toSchema(e=!1){const t=[];if(this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof OtherCertificateFormat)||this.crls&&this.crls.length&&this.crls.some(e=>e instanceof OtherRevocationInfoFormat)?this.version=5:this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof AttributeCertificateV2)?this.version=4:this.certificates&&this.certificates.length&&this.certificates.some(e=>e instanceof AttributeCertificateV1)||this.signerInfos.some(e=>3===e.version)||this.encapContentInfo.eContentType!==SignedData.ID_DATA?this.version=3:this.version=1,t.push(new Integer({value:this.version})),t.push(new Set({value:Array.from(this.digestAlgorithms,e=>e.toSchema())})),t.push(this.encapContentInfo.toSchema()),this.certificates){const e=new CertificateSet({certificates:this.certificates}).toSchema();t.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:e.valueBlock.value}))}return this.crls&&t.push(new Constructed({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.crls,t=>{if(t instanceof OtherRevocationInfoFormat){const e=t.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}return t.toSchema(e)})})),t.push(new Set({value:Array.from(this.signerInfos,e=>e.toSchema())})),new Sequence({value:t})}toJSON(){const e={version:this.version,digestAlgorithms:Array.from(this.digestAlgorithms,e=>e.toJSON()),encapContentInfo:this.encapContentInfo.toJSON(),signerInfos:Array.from(this.signerInfos,e=>e.toJSON())};return this.certificates&&(e.certificates=Array.from(this.certificates,e=>e.toJSON())),this.crls&&(e.crls=Array.from(this.crls,e=>e.toJSON())),e}async verify({signer:e=-1,data:t=ke,trustedCerts:r=[],checkDate:s=new Date,checkChain:a=!1,passedWhenNotRevValues:i=!1,extendedMode:n=!1,findOrigin:o=null,findIssuer:l=null}={},c=getCrypto(!0)){let u=null,h=null;try{let m=ke,f=Ce,g=[];const d=this.signerInfos[e];if(!d)throw new SignedDataVerifyError({date:s,code:1,message:"Unable to get signer by supplied index"});if(!this.certificates)throw new SignedDataVerifyError({date:s,code:2,message:"No certificates attached to this signed data"});if(d.sid instanceof IssuerAndSerialNumber){for(const e of this.certificates)if(e instanceof Certificate&&e.issuer.isEqual(d.sid.issuer)&&e.serialNumber.isEqual(d.sid.serialNumber)){u=e;break}}else{const e=d.sid,t=e.idBlock.isConstructed?e.valueBlock.value[0].valueBlock.valueHex:e.valueBlock.valueHex;for(const e of this.certificates){if(!(e instanceof Certificate))continue;if(isEqualBuffer(await c.digest({name:"sha-1"},e.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHexView),t)){u=e;break}}}if(!u)throw new SignedDataVerifyError({date:s,code:3,message:"Unable to find signer certificate"});if("1.2.840.113549.1.9.16.1.4"===this.encapContentInfo.eContentType){if(!this.encapContentInfo.eContent)throw new SignedDataVerifyError({date:s,code:15,message:"Error during verification: TSTInfo eContent is empty",signatureVerified:null,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0});let e;try{e=TSTInfo.fromBER(this.encapContentInfo.eContent.valueBlock.valueHexView)}catch(e){throw new SignedDataVerifyError({date:s,code:15,message:"Error during verification: TSTInfo wrong ASN.1 schema ",signatureVerified:null,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0})}if(s=e.genTime,h=e.serialNumber.valueBlock.valueHexView.slice(),0===t.byteLength)throw new SignedDataVerifyError({date:s,code:4,message:"Missed detached data input array"});if(!await e.verify({data:t},c))throw new SignedDataVerifyError({date:s,code:15,message:"Error during verification: TSTInfo verification is failed",signatureVerified:!1,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0})}if(a){const e=this.certificates.filter(e=>e instanceof Certificate&&!!checkCA(e,u)),t={checkDate:s,certs:e,trustedCerts:r};l&&(t.findIssuer=l),o&&(t.findOrigin=o);const a=new CertificateChainValidationEngine(t);if(a.certs.push(u),this.crls)for(const e of this.crls)"thisUpdate"in e?a.crls.push(e):e.otherRevInfoFormat===wt&&a.ocsps.push(new BasicOCSPResponse({schema:e.otherRevInfo}));this.ocsps&&a.ocsps.push(...this.ocsps);const n=await a.verify({passedWhenNotRevValues:i},c).catch(e=>{throw new SignedDataVerifyError({date:s,code:5,message:`Validation of signer's certificate failed with error: ${e instanceof Object?e.resultMessage:e}`,signerCertificate:u,signerCertificateVerified:!1})});if(n.certificatePath&&(g=n.certificatePath),!n.result)throw new SignedDataVerifyError({date:s,code:5,message:`Validation of signer's certificate failed: ${n.resultMessage}`,signerCertificate:u,signerCertificateVerified:!1})}const p=c.getAlgorithmByOID(d.digestAlgorithm.algorithmId);if(!("name"in p))throw new SignedDataVerifyError({date:s,code:7,message:`Unsupported signature algorithm: ${d.digestAlgorithm.algorithmId}`,signerCertificate:u,signerCertificateVerified:!0});f=p.name;const S=this.encapContentInfo.eContent;if(S)t=1===S.idBlock.tagClass&&4===S.idBlock.tagNumber?S.getValue():S.valueBlock.valueBeforeDecodeView;else if(0===t.byteLength)throw new SignedDataVerifyError({date:s,code:8,message:"Missed detached data input array",signerCertificate:u,signerCertificateVerified:!0});if(d.signedAttrs){let e=!1,t=!1;for(const r of d.signedAttrs.attributes)if("1.2.840.113549.1.9.3"===r.type&&(e=!0),"1.2.840.113549.1.9.4"===r.type&&(t=!0,m=r.values[0].valueBlock.valueHex),e&&t)break;if(!1===e)throw new SignedDataVerifyError({date:s,code:9,message:'Attribute "content-type" is a mandatory attribute for "signed attributes"',signerCertificate:u,signerCertificateVerified:!0});if(!1===t)throw new SignedDataVerifyError({date:s,code:10,message:'Attribute "message-digest" is a mandatory attribute for "signed attributes"',signatureVerified:null,signerCertificate:u,signerCertificateVerified:!0})}if(d.signedAttrs){if(!isEqualBuffer(await c.digest(f,new Uint8Array(t)),m))throw new SignedDataVerifyError({date:s,code:15,message:"Error during verification: Message digest doesn't match",signatureVerified:null,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0});t=d.signedAttrs.encodedValue}const y="1.2.840.113549.1.1.1"===d.signatureAlgorithm.algorithmId?await c.verifyWithPublicKey(t,d.signature,u.subjectPublicKeyInfo,d.signatureAlgorithm,f):await c.verifyWithPublicKey(t,d.signature,u.subjectPublicKeyInfo,d.signatureAlgorithm);return n?{date:s,code:14,message:Ce,signatureVerified:y,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0,certificatePath:g}:y}catch(e){if(e instanceof SignedDataVerifyError)throw e;throw new SignedDataVerifyError({date:s,code:15,message:`Error during verification: ${e instanceof Error?e.message:e}`,signatureVerified:null,signerCertificate:u,timestampSerial:h,signerCertificateVerified:!0})}}async sign(e,t,r="SHA-1",s=ke,a=getCrypto(!0)){var i;if(!e)throw new Error("Need to provide a private key for signing");const n=this.signerInfos[t];if(!n)throw new RangeError("SignerInfo index is out of range");!(null===(i=n.signedAttrs)||void 0===i?void 0:i.attributes.length)&&"hash"in e.algorithm&&"hash"in e.algorithm&&e.algorithm.hash&&(r=e.algorithm.hash.name);const o=a.getOIDByAlgorithm({name:r},!0,"hashAlgorithm");0===this.digestAlgorithms.filter(e=>e.algorithmId===o).length&&this.digestAlgorithms.push(new AlgorithmIdentifier({algorithmId:o,algorithmParams:new Null})),n.digestAlgorithm=new AlgorithmIdentifier({algorithmId:o,algorithmParams:new Null});const l=await a.getSignatureParameters(e,r),c=l.parameters;if(n.signatureAlgorithm=l.signatureAlgorithm,n.signedAttrs)if(0!==n.signedAttrs.encodedValue.byteLength)s=n.signedAttrs.encodedValue;else{s=n.signedAttrs.toSchema().toBER();BufferSourceConverter.toUint8Array(s)[0]=49}else{const e=this.encapContentInfo.eContent;if(e)s=1===e.idBlock.tagClass&&4===e.idBlock.tagNumber?e.getValue():e.valueBlock.valueBeforeDecodeView;else if(0===s.byteLength)throw new Error("Missed detached data input array")}const u=await a.signWithPrivateKey(s,e,c);n.signature=new OctetString({valueHex:u})}}SignedData.CLASS_NAME="SignedData",SignedData.ID_DATA=mt;const eh="version",th="authSafe",rh="macData",sh="parsedValue",ah=[eh,th,rh];class PFX extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,eh,PFX.defaultValues(eh)),this.authSafe=getParametersValue(e,th,PFX.defaultValues(th)),rh in e&&(this.macData=getParametersValue(e,rh,PFX.defaultValues(rh))),sh in e&&(this.parsedValue=getParametersValue(e,sh,PFX.defaultValues(sh))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case eh:return 3;case th:return new ContentInfo;case rh:return new MacData;case sh:return{};default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case eh:return t===PFX.defaultValues(e);case th:return ContentInfo.compareWithDefault("contentType",t.contentType)&&ContentInfo.compareWithDefault("content",t.content);case rh:return MacData.compareWithDefault("mac",t.mac)&&MacData.compareWithDefault("macSalt",t.macSalt)&&MacData.compareWithDefault("iterations",t.iterations);case sh:return t instanceof Object&&0===Object.keys(t).length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.version||eh}),ContentInfo.schema(t.authSafe||{names:{blockName:th}}),MacData.schema(t.macData||{names:{blockName:rh,optional:!0}})]})}fromSchema(e){clearProps(e,ah);const t=compareSchema(e,e,PFX.schema({names:{version:eh,authSafe:{names:{blockName:th}},macData:{names:{blockName:rh}}}}));AsnError.assertSchema(t,this.className),this.version=t.result.version.valueBlock.valueDec,this.authSafe=new ContentInfo({schema:t.result.authSafe}),rh in t.result&&(this.macData=new MacData({schema:t.result.macData}))}toSchema(){const e=[new Integer({value:this.version}),this.authSafe.toSchema()];return this.macData&&e.push(this.macData.toSchema()),new Sequence({value:e})}toJSON(){const e={version:this.version,authSafe:this.authSafe.toJSON()};return this.macData&&(e.macData=this.macData.toJSON()),e}async makeInternalValues(e={},t=getCrypto(!0)){if(ArgumentError.assert(e,"parameters","object"),!this.parsedValue)throw new Error('Please call "parseValues" function first in order to make "parsedValue" data');switch(ParameterError.assertEmpty(this.parsedValue.integrityMode,"integrityMode","parsedValue"),ParameterError.assertEmpty(this.parsedValue.authenticatedSafe,"authenticatedSafe","parsedValue"),this.parsedValue.integrityMode){case 0:{if(!("iterations"in e))throw new ParameterError("iterations");ParameterError.assertEmpty(e.pbkdf2HashAlgorithm,"pbkdf2HashAlgorithm"),ParameterError.assertEmpty(e.hmacHashAlgorithm,"hmacHashAlgorithm"),ParameterError.assertEmpty(e.password,"password");const r=new ArrayBuffer(64),s=new Uint8Array(r);t.getRandomValues(s);const a=this.parsedValue.authenticatedSafe.toSchema().toBER(!1);this.authSafe=new ContentInfo({contentType:ContentInfo.DATA,content:new OctetString({valueHex:a})});const i=await t.stampDataWithPassword({password:e.password,hashAlgorithm:e.hmacHashAlgorithm,salt:r,iterationCount:e.iterations,contentToStamp:a});this.macData=new MacData({mac:new DigestInfo({digestAlgorithm:new AlgorithmIdentifier({algorithmId:t.getOIDByAlgorithm({name:e.hmacHashAlgorithm},!0,"hmacHashAlgorithm")}),digest:new OctetString({valueHex:i})}),macSalt:new OctetString({valueHex:r}),iterations:e.iterations})}break;case 1:{if(!("signingCertificate"in e))throw new ParameterError("signingCertificate");ParameterError.assertEmpty(e.privateKey,"privateKey"),ParameterError.assertEmpty(e.hashAlgorithm,"hashAlgorithm");const r=this.parsedValue.authenticatedSafe.toSchema().toBER(!1),s=new SignedData({version:1,encapContentInfo:new EncapsulatedContentInfo({eContentType:"1.2.840.113549.1.7.1",eContent:new OctetString({valueHex:r})}),certificates:[e.signingCertificate]}),a=await t.digest({name:e.hashAlgorithm},new Uint8Array(r)),i=[];i.push(new Attribute({type:"1.2.840.113549.1.9.3",values:[new ObjectIdentifier({value:"1.2.840.113549.1.7.1"})]})),i.push(new Attribute({type:"1.2.840.113549.1.9.5",values:[new UTCTime({valueDate:new Date})]})),i.push(new Attribute({type:"1.2.840.113549.1.9.4",values:[new OctetString({valueHex:a})]})),s.signerInfos.push(new SignerInfo({version:1,sid:new IssuerAndSerialNumber({issuer:e.signingCertificate.issuer,serialNumber:e.signingCertificate.serialNumber}),signedAttrs:new SignedAndUnsignedAttributes({type:0,attributes:i})})),await s.sign(e.privateKey,0,e.hashAlgorithm,void 0,t),this.authSafe=new ContentInfo({contentType:"1.2.840.113549.1.7.2",content:s.toSchema(!0)})}break;default:throw new Error(`Parameter "integrityMode" has unknown value: ${this.parsedValue.integrityMode}`)}}async parseInternalValues(e,t=getCrypto(!0)){switch(ArgumentError.assert(e,"parameters","object"),void 0===e.checkIntegrity&&(e.checkIntegrity=!0),this.parsedValue={},this.authSafe.contentType){case ContentInfo.DATA:{ParameterError.assertEmpty(e.password,"password"),this.parsedValue.integrityMode=0,ArgumentError.assert(this.authSafe.content,"authSafe.content",OctetString);const r=this.authSafe.content.getValue();if(this.parsedValue.authenticatedSafe=AuthenticatedSafe.fromBER(r),e.checkIntegrity){if(!this.macData)throw new Error('Absent "macData" value, can not check PKCS#12 data integrity');const s=t.getAlgorithmByOID(this.macData.mac.digestAlgorithm.algorithmId,!0,"digestAlgorithm");if(!await t.verifyDataStampedWithPassword({password:e.password,hashAlgorithm:s.name,salt:BufferSourceConverter.toArrayBuffer(this.macData.macSalt.valueBlock.valueHexView),iterationCount:this.macData.iterations||1,contentToVerify:r,signatureToVerify:BufferSourceConverter.toArrayBuffer(this.macData.mac.digest.valueBlock.valueHexView)}))throw new Error("Integrity for the PKCS#12 data is broken!")}}break;case ContentInfo.SIGNED_DATA:{this.parsedValue.integrityMode=1;const e=new SignedData({schema:this.authSafe.content}),r=e.encapContentInfo.eContent;ParameterError.assert(r,"eContent","cmsSigned.encapContentInfo"),ArgumentError.assert(r,"eContent",OctetString);const s=r.getValue();this.parsedValue.authenticatedSafe=AuthenticatedSafe.fromBER(s);if(!await e.verify({signer:0,checkChain:!1},t))throw new Error("Integrity for the PKCS#12 data is broken!")}break;default:throw new Error(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`)}}}PFX.CLASS_NAME="PFX";const ih="status",nh="statusStrings",oh="failInfo",lh=[ih,nh,oh];var ch;!function(e){e[e.granted=0]="granted",e[e.grantedWithMods=1]="grantedWithMods",e[e.rejection=2]="rejection",e[e.waiting=3]="waiting",e[e.revocationWarning=4]="revocationWarning",e[e.revocationNotification=5]="revocationNotification"}(ch||(ch={}));class PKIStatusInfo extends PkiObject{constructor(e={}){super(),this.status=getParametersValue(e,ih,PKIStatusInfo.defaultValues(ih)),nh in e&&(this.statusStrings=getParametersValue(e,nh,PKIStatusInfo.defaultValues(nh))),oh in e&&(this.failInfo=getParametersValue(e,oh,PKIStatusInfo.defaultValues(oh))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case ih:return 2;case nh:return[];case oh:return new BitString;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case ih:return t===PKIStatusInfo.defaultValues(e);case nh:return 0===t.length;case oh:return t.isEqual(PKIStatusInfo.defaultValues(e));default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Ce,value:[new Integer({name:t.status||Ce}),new Sequence({optional:!0,value:[new Repeated({name:t.statusStrings||Ce,value:new Utf8String})]}),new BitString({name:t.failInfo||Ce,optional:!0})]})}fromSchema(e){clearProps(e,lh);const t=compareSchema(e,e,PKIStatusInfo.schema({names:{status:ih,statusStrings:nh,failInfo:oh}}));AsnError.assertSchema(t,this.className);const r=t.result.status;if(!0===r.valueBlock.isHexOnly||r.valueBlock.valueDec<0||r.valueBlock.valueDec>5)throw new Error('PKIStatusInfo "status" has invalid value');this.status=r.valueBlock.valueDec,nh in t.result&&(this.statusStrings=t.result.statusStrings),oh in t.result&&(this.failInfo=t.result.failInfo)}toSchema(){const e=[];return e.push(new Integer({value:this.status})),this.statusStrings&&e.push(new Sequence({optional:!0,value:this.statusStrings})),this.failInfo&&e.push(this.failInfo),new Sequence({value:e})}toJSON(){const e={status:this.status};return this.statusStrings&&(e.statusStrings=Array.from(this.statusStrings,e=>e.toJSON())),this.failInfo&&(e.failInfo=this.failInfo.toJSON()),e}}PKIStatusInfo.CLASS_NAME="PKIStatusInfo";const uh="version",hh="messageImprint",mh="reqPolicy",fh="nonce",gh="certReq",dh="extensions",ph="TimeStampReq",Sh=`${ph}.${uh}`,yh=`${ph}.${hh}`,wh=`${ph}.${mh}`,vh=`${ph}.${fh}`,bh=`${ph}.${gh}`,Ah=`${ph}.${dh}`,kh=[Sh,yh,wh,vh,bh,Ah];class TimeStampReq extends PkiObject{constructor(e={}){super(),this.version=getParametersValue(e,uh,TimeStampReq.defaultValues(uh)),this.messageImprint=getParametersValue(e,hh,TimeStampReq.defaultValues(hh)),mh in e&&(this.reqPolicy=getParametersValue(e,mh,TimeStampReq.defaultValues(mh))),fh in e&&(this.nonce=getParametersValue(e,fh,TimeStampReq.defaultValues(fh))),gh in e&&(this.certReq=getParametersValue(e,gh,TimeStampReq.defaultValues(gh))),dh in e&&(this.extensions=getParametersValue(e,dh,TimeStampReq.defaultValues(dh))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case uh:return 0;case hh:return new MessageImprint;case mh:return Ce;case fh:return new Integer;case gh:return!1;case dh:return[];default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case uh:case mh:case gh:return t===TimeStampReq.defaultValues(e);case hh:return MessageImprint.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&MessageImprint.compareWithDefault("hashedMessage",t.hashedMessage);case fh:return t.isEqual(TimeStampReq.defaultValues(e));case dh:return 0===t.length;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||ph,value:[new Integer({name:t.version||Sh}),MessageImprint.schema(t.messageImprint||{names:{blockName:yh}}),new ObjectIdentifier({name:t.reqPolicy||wh,optional:!0}),new Integer({name:t.nonce||vh,optional:!0}),new Boolean({name:t.certReq||bh,optional:!0}),new Constructed({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new Repeated({name:t.extensions||Ah,value:Extension.schema()})]})]})}fromSchema(e){clearProps(e,kh);const t=compareSchema(e,e,TimeStampReq.schema());AsnError.assertSchema(t,this.className),this.version=t.result[Sh].valueBlock.valueDec,this.messageImprint=new MessageImprint({schema:t.result[yh]}),wh in t.result&&(this.reqPolicy=t.result[wh].valueBlock.toString()),vh in t.result&&(this.nonce=t.result[vh]),bh in t.result&&(this.certReq=t.result[bh].valueBlock.value),Ah in t.result&&(this.extensions=Array.from(t.result[Ah],e=>new Extension({schema:e})))}toSchema(){const e=[];return e.push(new Integer({value:this.version})),e.push(this.messageImprint.toSchema()),this.reqPolicy&&e.push(new ObjectIdentifier({value:this.reqPolicy})),this.nonce&&e.push(this.nonce),gh in this&&!1===TimeStampReq.compareWithDefault(gh,this.certReq)&&e.push(new Boolean({value:this.certReq})),this.extensions&&e.push(new Constructed({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.extensions,e=>e.toSchema())})),new Sequence({value:e})}toJSON(){const e={version:this.version,messageImprint:this.messageImprint.toJSON()};return void 0!==this.reqPolicy&&(e.reqPolicy=this.reqPolicy),void 0!==this.nonce&&(e.nonce=this.nonce.toJSON()),void 0!==this.certReq&&!1===TimeStampReq.compareWithDefault(gh,this.certReq)&&(e.certReq=this.certReq),this.extensions&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}}TimeStampReq.CLASS_NAME="TimeStampReq";const Ch="status",Vh="timeStampToken",Bh="TimeStampResp",Ih=`${Bh}.${Ch}`,Nh=`${Bh}.${Vh}`,Ph=[Ih,Nh];class TimeStampResp extends PkiObject{constructor(e={}){super(),this.status=getParametersValue(e,Ch,TimeStampResp.defaultValues(Ch)),Vh in e&&(this.timeStampToken=getParametersValue(e,Vh,TimeStampResp.defaultValues(Vh))),e.schema&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case Ch:return new PKIStatusInfo;case Vh:return new ContentInfo;default:return super.defaultValues(e)}}static compareWithDefault(e,t){switch(e){case Ch:return PKIStatusInfo.compareWithDefault(Ch,t.status)&&"statusStrings"in t==!1&&"failInfo"in t==!1;case Vh:return t.contentType===Ce&&t.content instanceof Any;default:return super.defaultValues(e)}}static schema(e={}){const t=getParametersValue(e,"names",{});return new Sequence({name:t.blockName||Bh,value:[PKIStatusInfo.schema(t.status||{names:{blockName:Ih}}),ContentInfo.schema(t.timeStampToken||{names:{blockName:Nh,optional:!0}})]})}fromSchema(e){clearProps(e,Ph);const t=compareSchema(e,e,TimeStampResp.schema());AsnError.assertSchema(t,this.className),this.status=new PKIStatusInfo({schema:t.result[Ih]}),Nh in t.result&&(this.timeStampToken=new ContentInfo({schema:t.result[Nh]}))}toSchema(){const e=[];return e.push(this.status.toSchema()),this.timeStampToken&&e.push(this.timeStampToken.toSchema()),new Sequence({value:e})}toJSON(){const e={status:this.status.toJSON()};return this.timeStampToken&&(e.timeStampToken=this.timeStampToken.toJSON()),e}async sign(e,t,r=getCrypto(!0)){this.assertContentType();return new SignedData({schema:this.timeStampToken.content}).sign(e,0,t,void 0,r)}async verify(e={signer:0,trustedCerts:[],data:ke},t=getCrypto(!0)){this.assertContentType();return new SignedData({schema:this.timeStampToken.content}).verify(e,t)}assertContentType(){if(!this.timeStampToken)throw new Error("timeStampToken is absent in TSP response");if(this.timeStampToken.contentType!==ft)throw new Error(`Wrong format of timeStampToken: ${this.timeStampToken.contentType}`)}}TimeStampResp.CLASS_NAME="TimeStampResp",function(){if("undefined"!=typeof self){if("crypto"in self){let e="webcrypto";"webkitSubtle"in self.crypto&&(e="safari"),setEngine(e,new CryptoEngine({name:e,crypto:crypto}))}}else if("undefined"!=typeof crypto&&"webcrypto"in crypto){const e="NodeJS ^15",t=crypto.webcrypto;setEngine(e,new CryptoEngine({name:e,crypto:t}))}}();const verifySignatureWithPem=async(e,t,r)=>{try{const s=e.replace(/-----BEGIN [^-]+-----/,"").replace(/-----END [^-]+-----/,"").replace(/\s+/g,""),a=fromBER(base64ToUint8Array(s).buffer),i=new Certificate({schema:a.result}).subjectPublicKeyInfo;if(!i||!i.algorithm||!i.algorithm.algorithmId)throw console.error("Parsed publicKeyInfo:",i),new Error("Could not extract algorithm information from public key");const n=function(e){const t=e.algorithm.algorithmId,r=e.algorithm.algorithmParams;let s;if(t&&"object"==typeof t&&t.valueBlock&&"function"==typeof t.valueBlock.toString)s=t.valueBlock.toString();else{if("string"!=typeof t)throw new Error("Unsupported algorithmOid format");s=t}switch(s){case"1.2.840.10045.2.1":let e;switch(e=r&&"object"==typeof r&&r.valueBlock&&"function"==typeof r.valueBlock.toString?r.valueBlock.toString():"string"==typeof r?r:void 0,e){case"1.2.840.10045.3.1.7":return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};case"1.3.132.0.34":return{name:"ECDSA",namedCurve:"P-384",hash:{name:"SHA-384"}};case"1.3.132.0.35":return{name:"ECDSA",namedCurve:"P-521",hash:{name:"SHA-512"}};case void 0:return{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}};default:throw new Error(`Unsupported EC curve: ${e}`)}case"1.2.840.113549.1.1.1":return{name:"RSASSA-PKCS1-v1_5"};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};default:throw new Error(`Unsupported algorithm OID: ${s}`)}}(i),o=i.toSchema().toBER(),l=await crypto.subtle.importKey("spki",o,n,!1,["verify"]);let c;if("ECDSA"===n.name){let e=32;"P-384"===n.namedCurve&&(e=48),"P-521"===n.namedCurve&&(e=66),c=function(e,t){try{const r=fromBER(base64ToUint8Array(e).buffer);if(2!==r.result.valueBlock.value.length)throw new Error("Invalid DER signature structure");const s=r.result.valueBlock.value[0],a=r.result.valueBlock.value[1],i=new Uint8Array(s.valueBlock.valueHex),n=new Uint8Array(a.valueBlock.valueHex),o=padOrTrimUint8Array(i,t),l=padOrTrimUint8Array(n,t),c=new Uint8Array(2*t);return c.set(o,0),c.set(l,t),c.buffer}catch(e){throw console.error("Error converting DER signature to raw:",e),e}}(t,e)}else c=base64ToUint8Array(t).buffer;return await crypto.subtle.verify(n,l,c,r)}catch(e){throw console.error("Error converting PEM to SPKI key:",e),e}};function base64ToUint8Array(e){if("function"==typeof Buffer)return new Uint8Array(Buffer.from(e,"base64"));{const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r}}function padOrTrimUint8Array(e,t){if(e.length===t)return e;if(e.length>t)return e.slice(e.length-t);const r=new Uint8Array(t);return r.set(e,t-e.length),r}let Eh,Dh,Oh="",xh="";const Rh=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,Kh={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"};function quote(e){return Rh.lastIndex=0,Rh.test(e)?'"'+e.replace(Rh,e=>Kh[e]||"\\u"+("0000"+e.charCodeAt(0).toString(16)).slice(-4))+'"':'"'+e+'"'}function str(e,t){let r=t[e];switch(r&&"object"==typeof r&&"function"==typeof r.toJSON&&(r=r.toJSON(e)),"function"==typeof Eh&&(r=Eh.call(t,e,r)),typeof r){case"string":return quote(r);case"number":return isFinite(r)?String(r):"null";case"boolean":case"undefined":case"object":if(null===r)return"null";const e=Oh;Oh+=xh;const t=[];if(Array.isArray(r))for(let e=0;e<r.length;e++)t[e]=str(e,r)||"null";else{const e=Object.keys(r).sort(Dh);for(const s of e)if(Object.prototype.hasOwnProperty.call(r,s)){const e=str(s,r);e&&t.push(quote(s)+(Oh?": ":":")+e)}}let s;return s=Array.isArray(r)?0===t.length?"[]":Oh?"[\n"+Oh+t.join(",\n"+Oh)+"\n"+e+"]":"["+t.join(",")+"]":0===t.length?"{}":Oh?"{\n"+Oh+t.join(",\n"+Oh)+"\n"+e+"}":"{"+t.join(",")+"}",Oh=e,s;default:return String(r)}}function stringify(e,t,r,s){return Oh="",xh="",Eh=t,Dh=void 0,str("",{"":e})}class TrustedIssuerRegistry{constructor(e={}){this._cacheEnabled=e.cacheEnabled??!0,this._cacheTTL=e.cacheTTL??864e5,this._urlBase=e.useTestData?r:t,this._cache={}}async getEndOfLifeDate(){const t=await fetch(`${this._urlBase}/deprecation_notice.json`);if(t.ok){const r=await t.json();if(!r.version)return null;let[s,a]=r.version.split(".").map(Number),[i,n]=e.split(".").map(Number);return s<i||s===i&&a<n?null:new Date(1e3*r.end_of_life)}return null}async getIssuerFromX509AKI(e){if(this._cacheEnabled&&e in this._cache&&this._cache[e].expiresAt>Date.now())return this._deepCopy(this._cache[e].issuer);const t=await fetch(`${this._urlBase}/issuers/x509_aki/${e}.json`);if(t.ok){const r=await t.json();return await this._verifyIssuer(r)?(this._cacheEnabled&&(this._cache[e]={issuer:r,expiresAt:Date.now()+this._cacheTTL}),this._deepCopy(r)):null}return this._cacheEnabled&&(this._cache[e]={issuer:null,expiresAt:Date.now()+this._cacheTTL}),null}async _verifyIssuer(e){const t={...e},r=t.signature;delete t.signature;const s=stringify(t);let a=!1;try{const e=(new TextEncoder).encode(s).buffer;a=await verifySignatureWithPem("-----BEGIN CERTIFICATE-----\nMIIBnDCCAUGgAwIBAgIURT5mnI9WbENrqzrB0RYtXGuc0n8wCgYIKoZIzj0EAwIw\nIzEhMB8GA1UEAwwYVW5pdmVyc2FsIFZlcmlmeSBSb290IENBMB4XDTI1MDcwNDEz\nNTY0OVoXDTM1MDcwMjEzNTY0OVowIzEhMB8GA1UEAwwYVW5pdmVyc2FsIFZlcmlm\neSBSb290IENBMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsOasxJHsq+tmAy5L\nYz0KeT2UyGo1PqS0mr7Z5zn7Ai7vCEzea57QiQMQVYpiQGvkr3bS2T2l6xK7Oduj\nMhUWs6NTMFEwHQYDVR0OBBYEFPJpi7yR7+yf44xcCfHDypGmlDosMB8GA1UdIwQY\nMBaAFPJpi7yR7+yf44xcCfHDypGmlDosMA8GA1UdEwEB/wQFMAMBAf8wCgYIKoZI\nzj0EAwIDSQAwRgIhAJvh/bVs8EXtzYWZm4ijR9J0+BwtqzCXJE4dDML4JafpAiEA\n/7cvgi4SoK+Xn6WRfsgg9BNymAfJbejzDrQbLqHh4v8=\n-----END CERTIFICATE-----",r,e)}catch(e){console.error("Issuer signature verification failed",e)}return a}_deepCopy(e){return JSON.parse(JSON.stringify(e))}static minorVersion=e}TrustedIssuerRegistry.verifySignatureWithPem=verifySignatureWithPem;export{TrustedIssuerRegistry as default,verifySignatureWithPem};
